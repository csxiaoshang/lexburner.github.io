<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>徐靖峰|个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lexburner.github.io/"/>
  <updated>2019-10-08T06:07:36.232Z</updated>
  <id>http://lexburner.github.io/</id>
  
  <author>
    <name>徐靖峰</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一文聊透 Dubbo 优雅停机</title>
    <link href="http://lexburner.github.io/dubbo-gracefully-shutdown/"/>
    <id>http://lexburner.github.io/dubbo-gracefully-shutdown/</id>
    <published>2019-09-29T14:46:55.000Z</published>
    <updated>2019-10-08T06:07:36.232Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>一年之前，我曾经写过一篇《研究优雅停机时的一点思考》，主要介绍了 kill -9，kill -15 两个 Linux 指令的含义，并且针对性的聊到了 Spring Boot 应用如何正确的优雅停机，算是本文的前置文章，如果你对上述概念不甚了解，建议先去浏览一遍，再回头来看这篇文章。这篇文章将会以 Dubbo 为例，既聊架构设计，也聊源码，聊聊服务治理框架要真正实现优雅停机，需要注意哪些细节。</p><p>本文的写作思路是从 Dubbo 2.5.x 开始，围绕优雅停机这个优化点，一直追溯到最新的 2.7.x。先对 Dubbo 版本做一个简单的科普：2.7.x 和 2.6.x 是目前官方推荐使用的版本，其中 2.7.x 是捐献给 Apache 的版本，具备了很多新的特性，目前最新的 release 版本是 2.7.4，处于生产基本可用的状态；2.6.x 处于维护态，主要以 bugfix 为主，但经过了很多公司线上环境的验证，所以求稳的话，可以使用 2.6.x 分支最新的版本。至于 2.5.x，社区已经放弃了维护，并且 2.5.x 存在一定数量的 bug，本文介绍的 Dubbo 优雅停机特性便体现了这一点。</p><a id="more"></a><h2 id="2-优雅停机的意义"><a href="#2-优雅停机的意义" class="headerlink" title="2 优雅停机的意义"></a>2 优雅停机的意义</h2><p>优雅停机一直是一个非常严谨的话题，但由于其仅仅存在于重启、下线这样的部署阶段，导致很多人忽视了它的重要性，但没有它，你永远不能得到一个完整的应用生命周期，永远会对系统的健壮性持怀疑态度。</p><p>同时，优雅停机又是一个庞大的话题</p><ul><li>操作系统层面，提供了 kill -9 （SIGKILL）和 kill -15（SIGTERM） 两种停机策略</li><li>语言层面，Java 应用有 JVM shutdown hook 这样的概念</li><li>框架层面，Spring Boot 提供了 actuator 的下线 endpoint，提供了 ContextClosedEvent 事件</li><li>容器层面，Docker ：当执行 docker stop 命令时，容器内的进程会收到 SIGTERM 信号，那么 Docker Daemon 会在 10s 后，发出 SIGKILL 信号；K8S 在管理容器生命周期阶段中提供了 prestop 钩子方法</li><li>应用架构层面，不同架构存在不同的部署方案。单体式应用中，一般依靠 nginx 这样的负载均衡组件进行手动切流，逐步部署集群；微服务架构中，各个节点之间有复杂的调用关系，上述这种方案就显得不可靠了，需要有自动化的机制。</li></ul><p>为避免该话题过度发散，本文的重点将会集中在框架和应用架构层面，探讨以 Dubbo 为代表的微服务架构在优雅停机上的最佳实践。Dubbo 的优雅下线主要依赖于注册中心组件，由其通知消费者摘除下线的节点，如下图所示：</p><p><img src="http://kirito.iocoder.cn/image-20191001173747692.png" alt="image-20191001173747692"></p><p>上述的操作旨在让服务消费者避开已经下线的机器，但这样就算实现了优雅停机了吗？似乎还漏掉了一步，在应用停机时，可能还存在执行到了一半的任务，试想这样一个场景：一个 Dubbo 请求刚到达提供者，服务端正在处理请求，收到停机指令后，提供者直接停机，留给消费者的只会是一个没有处理完毕的超时请求。</p><p>结合上述的案例，我们总结出 Dubbo 优雅停机需要满足两点基本诉求：</p><ol><li>服务消费者不应该请求到已经下线的服务提供者</li><li>在途请求需要处理完毕，不能被停机指令中断</li></ol><p>优雅停机的意义：应用的重启、停机等操作，不影响业务的连续性。</p><h2 id="3-优雅停机初始方案-—-2-5-x"><a href="#3-优雅停机初始方案-—-2-5-x" class="headerlink" title="3 优雅停机初始方案 — 2.5.x"></a>3 优雅停机初始方案 — 2.5.x</h2><p>为了让读者对 Dubbo 的优雅停机有一个最基础的理解，我们首先研究下 Dubbo 2.5.x 的版本，这个版本实现优雅停机的方案相对简单，容易理解。</p><h3 id="3-1-入口类：AbstractConfig"><a href="#3-1-入口类：AbstractConfig" class="headerlink" title="3.1 入口类：AbstractConfig"></a>3.1 入口类：AbstractConfig</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractConfig</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                ProtocolConfig.destroyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"DubboShutdownHook"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 AbstractConfig 的静态块中，Dubbo 注册了一个 shutdown hook，用于执行 Dubbo 预设的一些停机逻辑，继续跟进 <code>ProtocolConfig.destroyAll()</code> 。</p><h3 id="3-2-ProtocolConfig"><a href="#3-2-ProtocolConfig" class="headerlink" title="3.2 ProtocolConfig"></a>3.2 ProtocolConfig</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroyAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!destroyed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    AbstractRegistryFactory.destroyAll(); <span class="comment">// ①注册中心注销</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for registry notification</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(ConfigUtils.getServerShutdownTimeout()); <span class="comment">// ② sleep 等待</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        logger.warn(<span class="string">"Interrupted unexpectedly when waiting for registry notification during shutdown process!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ExtensionLoader&lt;Protocol&gt; loader = ExtensionLoader.getExtensionLoader(Protocol.class);</span><br><span class="line">    <span class="keyword">for</span> (String protocolName : loader.getLoadedExtensions()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Protocol protocol = loader.getLoadedExtension(protocolName);</span><br><span class="line">            <span class="keyword">if</span> (protocol != <span class="keyword">null</span>) &#123;</span><br><span class="line">                protocol.destroy(); <span class="comment">// ③协议/流程注销</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.warn(t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dubbo 中的 <code>Protocol</code> 这个词不太能望文生义，它一般被翻译为”协议”，但我更习惯将它理解为“流程”，从 <code>Protocol</code> 接口的三个方法反而更加容易理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line">    &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它定义了暴露、订阅、注销这三个生命周期方法，所以不难理解为什么 Dubbo 会把 shutdown hook 触发后的注销方法定义在 <code>ProtocolConfig</code> 中了。</p><p>回到 <code>ProtocolConfig</code> 的源码中，我把 <code>ProtocolConfig</code> 中执行的优雅停机逻辑分成了三部分，其中第 1，2 部分和注册中心（Registry）相关，第 3 部分和协议/流程（Protocol）相关，分成下面的 3.3 和 3.4 两部分来介绍。</p><h3 id="3-3-注册中心注销逻辑"><a href="#3-3-注册中心注销逻辑" class="headerlink" title="3.3 注册中心注销逻辑"></a>3.3 注册中心注销逻辑</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRegistryFactory</span> <span class="keyword">implements</span> <span class="title">RegistryFactory</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroyAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOCK.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Registry registry : getRegistries()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    registry.destroy();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    LOGGER.error(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            REGISTRIES.clear();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Release the lock</span></span><br><span class="line">            LOCK.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码对应了 3.2 小节 ProtocolConfig 源码的第 1 部分，代表了注册中心的注销逻辑，更深一层的源码不需要 debug 进去了，大致的逻辑就是删除掉注册中心中本节点对应的服务提供者地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wait for registry notification</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(ConfigUtils.getServerShutdownTimeout());</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    logger.warn(<span class="string">"Interrupted unexpectedly when waiting for registry notification during shutdown process!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码对应了 3.2 小节 ProtocolConfig 源码的第 2 部分，<code>ConfigUtils.getServerShutdownTimeout()</code> 默认值是 10s，为什么需要在 shutdown hook 中等待 10s 呢？在注释中可以发现这段代码的端倪，原来是为了给服务消费者一点时间，确保等到注册中心的通知。10s 显然是一个经验值，这里也不妨和大家探讨一下，如何稳妥地设置这个值呢？</p><ul><li>设置的过短。由于注册中心通知消费者取消订阅某个地址是异步通知过去的，可能消费者还没收到通知，提供者这边就停机了，这就违背了我们的诉求 1：<strong>服务消费者不应该请求到已经下线的服务提供者</strong>。</li><li>设置的过长。这会导致发布时间变长，带来不必要的等待。</li></ul><p>两个情况对比下，起码可以得出一个实践经验：如果拿捏不准等待时间，尽量设置一个宽松的一点的等待时间。</p><p>这个值主要取决三点因素：</p><ul><li>集群规模的大小。如果只有几个服务，每个服务只有几个实例，那么再弱鸡的注册中心也能很快的下发通知。</li><li>注册中心的选型。以 Naocs 和 Zookeeper 为例，同等规模服务实例下 Nacos 在推送地址方面的能力远超 Zookeeper。</li><li>网络状况。服务提供者和服务消费者与注册中心的交互逻辑走的 TCP 通信，网络状况也会影响到推送时间。</li></ul><p>所以需要根据实际部署场景测量出最合适的值。</p><h3 id="3-4-协议-流程注销逻辑"><a href="#3-4-协议-流程注销逻辑" class="headerlink" title="3.4 协议/流程注销逻辑"></a>3.4 协议/流程注销逻辑</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ExtensionLoader&lt;Protocol&gt; loader = ExtensionLoader.getExtensionLoader(Protocol.class);</span><br><span class="line"><span class="keyword">for</span> (String protocolName : loader.getLoadedExtensions()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Protocol protocol = loader.getLoadedExtension(protocolName);</span><br><span class="line">        <span class="keyword">if</span> (protocol != <span class="keyword">null</span>) &#123;</span><br><span class="line">            protocol.destroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.warn(t.getMessage(), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码对应了 3.2 小节 ProtocolConfig 源码的第 3 部分，在运行时，<code>loader.getLoadedExtension(protocolName)</code>  这段代码会加载到两个协议 ：<code>DubboProtocol</code> 和 <code>Injvm</code> 。后者 <code>Injvm</code> 实在没啥好讲的，主要来分析一下 <code>DubboProtocol</code> 的逻辑。</p><p><code>DubboProtocol</code> 实现了我们前面提到的 <code>Protocol</code> 接口，它的 destory 方法是我们重点要看的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboProtocol</span> <span class="keyword">extends</span> <span class="title">AbstractProtocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String key : <span class="keyword">new</span> ArrayList&lt;String&gt;(serverMap.keySet())) &#123;</span><br><span class="line">            ExchangeServer server = serverMap.remove(key);</span><br><span class="line">            <span class="keyword">if</span> (server != <span class="keyword">null</span>) &#123;</span><br><span class="line">            server.close(ConfigUtils.getServerShutdownTimeout());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String key : <span class="keyword">new</span> ArrayList&lt;String&gt;(referenceClientMap.keySet())) &#123;</span><br><span class="line">            ExchangeClient client = referenceClientMap.remove(key);</span><br><span class="line">            <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">            client.close(ConfigUtils.getServerShutdownTimeout());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String key : <span class="keyword">new</span> ArrayList&lt;String&gt;(ghostClientMap.keySet())) &#123;</span><br><span class="line">            ExchangeClient client = ghostClientMap.remove(key);</span><br><span class="line">            <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">                client.close(ConfigUtils.getServerShutdownTimeout());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stubServiceMethodsMap.clear();</span><br><span class="line">        <span class="keyword">super</span>.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要分成了两部分注销逻辑：server 和 client，注意这里是先注销了服务提供者后，再注销了服务消费者，这样做是有意为之。在 RPC 调用中，经常是一个远程调用触发一个远程调用，所以在关闭一个节点时，应该先切断上游的流量，所以这里是先注销了服务提供者，这样从一定程度上，降低了后面服务消费者被调用到的可能性（当然，服务消费者也有可能被单独调用到）。由于 server 和 client 的流程类似，所以我只选取了 server 部分来分析具体的注销逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">       startClose();</span><br><span class="line">       <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">long</span> max = (<span class="keyword">long</span>) timeout;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (getUrl().getParameter(Constants.CHANNEL_SEND_READONLYEVENT_KEY, <span class="keyword">true</span>)) &#123;</span><br><span class="line">               <span class="comment">// 如果注册中心有延迟，会立即受到readonly事件，下次不会再调用这台机器，当前已经调用的会处理完</span></span><br><span class="line">               sendChannelReadOnlyEvent();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">while</span> (HeaderExchangeServer.<span class="keyword">this</span>.isRunning() <span class="comment">// ①</span></span><br><span class="line">                   &amp;&amp; System.currentTimeMillis() - start &lt; max) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(<span class="number">10</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   logger.warn(e.getMessage(), e);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       doClose(); <span class="comment">// ②</span></span><br><span class="line">       server.close(timeout); <span class="comment">// ③</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Collection&lt;Channel&gt; channels = getChannels();</span><br><span class="line">       <span class="keyword">for</span> (Channel channel : channels) &#123;</span><br><span class="line">           <span class="keyword">if</span> (DefaultFuture.hasFuture(channel)) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!closed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       stopHeartbeatTimer();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           scheduled.shutdown();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">           logger.warn(t.getMessage(), t);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>化繁为简，这里只挑选上面代码中打标的两个地方进行分析</p><ol><li>判断服务端是否还在处理请求，在超时时间内一直等待到所有任务处理完毕</li><li>关闭心跳检测</li><li>关闭 NettyServer</li></ol><p>特别需要关注第一点，正符合我们在一开始提出的优雅停机的诉求 2：<strong>“在途请求需要处理完毕，不能被停机指令中断”</strong>。</p><h3 id="3-5-优雅停机初始方案总结"><a href="#3-5-优雅停机初始方案总结" class="headerlink" title="3.5 优雅停机初始方案总结"></a>3.5 优雅停机初始方案总结</h3><p>上述介绍的几个类构成了 Dubbo 2.5.x 的优雅停机方案，简单做一下总结，Dubbo 的优雅停机逻辑时序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Registry 注销</span><br><span class="line">等待 -Ddubbo.service.shutdown.wait 秒，等待消费方收到下线通知</span><br><span class="line">Protocol 注销</span><br><span class="line">    DubboProtocol 注销</span><br><span class="line">NettyServer 注销</span><br><span class="line">等待处理中的请求完毕</span><br><span class="line">            停止发送心跳</span><br><span class="line">            关闭 Netty 相关资源</span><br><span class="line">NettyClient 注销</span><br><span class="line">            停止发送心跳</span><br><span class="line">            等待处理中的请求完毕</span><br><span class="line">            关闭 Netty 相关资源</span><br></pre></td></tr></table></figure><blockquote><p>Dubbo 2.5.3 优雅停机的缺陷</p><p>如果你正在使用的 Dubbo 版本 &lt;= 2.5.3，一些并发问题和代码缺陷会导致你的应用不能很好的实现优雅停机功能，请尽快升级。</p><p>详情可以参考该 pull request 的变更：<a href="https://github.com/apache/dubbo/pull/568" target="_blank" rel="noopener">https://github.com/apache/dubbo/pull/568</a></p></blockquote><h2 id="4-Spring-容器下-Dubbo-的优雅停机"><a href="#4-Spring-容器下-Dubbo-的优雅停机" class="headerlink" title="4 Spring 容器下 Dubbo 的优雅停机"></a>4 Spring 容器下 Dubbo 的优雅停机</h2><p>上述的方案在不使用 Spring 时的确是无懈可击的，但由于现在大多数开发者选择使用 Spring 构建 Dubbo 应用，上述的方案会存在一些缺陷。</p><p>由于 Spring 框架本身也依赖于 shutdown hook 执行优雅停机，并且与 Dubbo 的优雅停机会并发执行，而 Dubbo 的一些 Bean 受 Spring 托管，当 Spring 容器优先关闭时，会导致 Dubbo 的优雅停机流程无法获取相关的 Bean，从而优雅停机失效。</p><p>Dubbo 开发者们迅速意识到了 shutdown hook 并发执行的问题，开始了一系列的补救措施。</p><h3 id="4-1-增加-ShutdownHookListener"><a href="#4-1-增加-ShutdownHookListener" class="headerlink" title="4.1 增加 ShutdownHookListener"></a>4.1 增加 ShutdownHookListener</h3><p>Spring 如此受欢迎的原因之一便是它的扩展点非常丰富，例如它提供了 <code>ApplicationListener</code> 接口，开发者可以实现这个接口监听到 Spring 容器的关闭事件，为解决 shutdown hook 并发执行的问题，在 Dubbo 2.6.3 中新增了 <code>ShutdownHookListener</code> 类，用作 Spring 容器下的关闭 Dubbo 应用的钩子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownHookListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextClosedEvent) &#123;</span><br><span class="line">            <span class="comment">// we call it anyway since dubbo shutdown hook make sure its destroyAll() is re-entrant.</span></span><br><span class="line">            <span class="comment">// pls. note we should not remove dubbo shutdown hook when spring framework is present, this is because</span></span><br><span class="line">            <span class="comment">// its shutdown hook may not be installed.</span></span><br><span class="line">            DubboShutdownHook shutdownHook = DubboShutdownHook.getDubboShutdownHook();</span><br><span class="line">            shutdownHook.destroyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当服务提供者 <code>ServiceBean</code> 和服务消费者 <code>ReferenceBean</code> 被初始化时，会触发该钩子被创建。</p><p>再来看看 AbstractConfig 中的代码，依旧保留了 JVM 的 shutdown hook</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractConfig</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(DubboShutdownHook.getDubboShutdownHook());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，在 Spring 环境下会注册两个钩子，在 Non-Spring 环境下只会有一个钩子，但看到 2.6.x 的实现大家是否意识到了两个问题呢？</p><ol><li>两个钩子并发执行不会报错吗？</li><li>为什么在 Spring 下不取消 JVM 的钩子，只保留 Spring 的钩子不就可以工作了吗？</li></ol><p>先解释第一个问题，这个按照我的理解，这段代码的 Commiter 可能认为只需要有一个 Spring 的钩子能正常注销就完事了，不需要考虑另外一个报不报错，因为都是独立的线程，不会有很大的影响。</p><p>再解释第二个问题，其实这个疑问的答案就藏在上面 <code>ShutdownHookListener</code> 代码的注释中，这段注释的意思是说：在 Spring 框架下不能直接移除原先的 JVM 钩子，因为 Spring 框架可能没有注册 ContextClosed 事件。啥意思呢？这里涉及到 Spring 框架生命周期的一个细节，我打算单独介绍一下。</p><h3 id="4-2-Spring-的容器关闭事件详解"><a href="#4-2-Spring-的容器关闭事件详解" class="headerlink" title="4.2 Spring 的容器关闭事件详解"></a>4.2 Spring 的容器关闭事件详解</h3><p>在 Spring 中，我们可以使用至少三种方式来注册容器关闭时一些收尾工作：</p><ol><li><p>使用 DisposableBean 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDisposableBean</span> <span class="keyword">implements</span> <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"== invoke DisposableBean =="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 @PreDestroy 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPreDestroy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"== invoke preDestroy =="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 ApplicationListener 监听 ContextClosedEvent</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">applicationContext.addApplicationListener(<span class="keyword">new</span> ApplicationListener&lt;ApplicationEvent&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent applicationEvent)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (applicationEvent <span class="keyword">instanceof</span> ContextClosedEvent) &#123;</span><br><span class="line">System.out.println(<span class="string">"== receive context closed event =="</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>但需要注意的是，在使用 SpringBoot 内嵌 Tomcat 容器时，容器关闭钩子是自动被注册，但使用纯粹的 Spring 框架或者外部 Tomcat 容器，需要显式的调用 <code>context.registerShutdownHook();</code> 接口进行注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring/beans.xml"</span>);</span><br><span class="line">context.start();</span><br><span class="line">context.registerShutdownHook();</span><br><span class="line">context.addApplicationListener(<span class="keyword">new</span> ApplicationListener&lt;ApplicationEvent&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent applicationEvent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (applicationEvent <span class="keyword">instanceof</span> ContextClosedEvent) &#123;</span><br><span class="line">            System.out.println(<span class="string">"== receive context closed event =="</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>否则，上述三种回收方法都无法工作。我们来看看 <code>registerShutdownHook()</code> 都干了啥</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title">DefaultResourceLoader</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">ConfigurableApplicationContext</span>, <span class="title">DisposableBean</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerShutdownHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.shutdownHook == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// No shutdown hook registered yet.</span></span><br><span class="line"><span class="keyword">this</span>.shutdownHook = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (startupShutdownMonitor) &#123;</span><br><span class="line">doClose();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Runtime.getRuntime().addShutdownHook(<span class="keyword">this</span>.shutdownHook); <span class="comment">// 重点！</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实也就是显式注册了一个属于 Spring 的钩子。这也解释上了 4.1 小节中，为什么有那段注释了，注册了事件不一定管用，还得保证 Spring 容器注册了它自己的钩子。</p><h3 id="4-3-Dubbo-优雅停机中级方案总结"><a href="#4-3-Dubbo-优雅停机中级方案总结" class="headerlink" title="4.3 Dubbo 优雅停机中级方案总结"></a>4.3 Dubbo 优雅停机中级方案总结</h3><p>第 4 节主要介绍了 Dubbo 开发者们在 Spring 环境下解决 Dubbo 优雅停机并发执行 shutdown hook 时的缺陷问题，但其实还不完善，因为在 Spring 环境下，如果没有显式注册 Spring 的 shutdown， 还是会存在缺陷的，准确的说，Dubbo 2.6.x 版本可以很好的在 Non-Spring、Spring Boot、Spring + ContextClosedEvent 环境下很好的工作。</p><h2 id="5-Dubbo-2-7-最终方案"><a href="#5-Dubbo-2-7-最终方案" class="headerlink" title="5 Dubbo 2.7 最终方案"></a>5 Dubbo 2.7 最终方案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringExtensionFactory</span> <span class="keyword">implements</span> <span class="title">ExtensionFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addApplicationContext</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">        CONTEXTS.add(context);</span><br><span class="line">        <span class="keyword">if</span> (context <span class="keyword">instanceof</span> ConfigurableApplicationContext) &#123;</span><br><span class="line">            ((ConfigurableApplicationContext) context).registerShutdownHook();</span><br><span class="line">            DubboShutdownHook.getDubboShutdownHook().unregister();</span><br><span class="line">        &#125;</span><br><span class="line">        BeanFactoryUtils.addApplicationListener(context, SHUTDOWN_HOOK_LISTENER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码寥寥数行，却是经过了深思熟虑之后的产物，期间迭代了 3 个大版本，真是不容易。这段代码很好地解决了第 4 节提出的两个问题</p><ol><li>担心两个钩子并发执行有问题？那就在可以注册 Spring 钩子的时候取消掉 JVM 的钩子。</li><li>担心当前 Spring 容器没有注册 Spring 钩子？那就显示调用 registerShutdownHook 进行注册。</li></ol><p>其他细节方面的优化和 bugfix 我就不进行详细介绍了，可以见得实现一个优雅停机需要考虑的点非常之多。</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h2><p>优雅停机看似是一个不难的技术点，但在一个通用框架中，使用者的业务场景类型非常多，这会大大加剧整个代码实现的复杂度。</p><p>摸清楚整个 Dubbo 优雅停机演化的过程，也着实花费了我一番功夫，有很多实现需要 checkout 到非常古老的分支，同时翻阅了很多 issue、pull request 的讨论，最终才形成了这篇文章，虽然研究的过程是困难的，但获取到真相是让人喜悦的。</p><p>在开源产品的研发过程中，服务到每一个类型的用户真的是非常难的一件事，能做的是满足大部分用户。例如 2.6.x 在大多数环境下其实已经没问题了，在 2.7.x 中则是得到了更加的完善，但是我相信，在使用 Dubbo 的部分用户中，可能还是会存在优雅停机的问题，只不过还没有被发现。</p><p>商业化的思考：和开源产品一样，商业化产品的研发也同样是一个逐渐迭代的过程，需要数代开发者一起维护一份代码，使用者发现问题，开发者修复问题，这样的正反馈可以形成一个正反馈，促使产品更加优秀。</p><p><strong>相关 pull request:</strong></p><p>修复 2.5.3 bug 的 pr：</p><p><a href="https://github.com/apache/dubbo/pull/568" target="_blank" rel="noopener">https://github.com/apache/dubbo/pull/568</a> 作者：@<strong>qinliujie</strong> </p><p>2.6.x Spring Shutdown Hook Enhancement: </p><p><a href="https://github.com/apache/dubbo/pull/1763" target="_blank" rel="noopener">https://github.com/apache/dubbo/pull/1763</a> 作者：@<strong>ralf0131</strong></p><p><a href="https://github.com/apache/dubbo/pull/1820" target="_blank" rel="noopener">https://github.com/apache/dubbo/pull/1820</a> 作者：@<strong>ralf0131</strong></p><p>2.7.x Spring Shutdown Hook Enhancement: </p><p><a href="https://github.com/apache/dubbo/pull/3008/" target="_blank" rel="noopener">https://github.com/apache/dubbo/pull/3008/</a> 作者：@<strong>beiwei30</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1 前言&quot;&gt;&lt;/a&gt;1 前言&lt;/h2&gt;&lt;p&gt;一年之前，我曾经写过一篇《研究优雅停机时的一点思考》，主要介绍了 kill -9，kill -15 两个 Linux 指令的含义，并且针对性的聊到了 Spring Boot 应用如何正确的优雅停机，算是本文的前置文章，如果你对上述概念不甚了解，建议先去浏览一遍，再回头来看这篇文章。这篇文章将会以 Dubbo 为例，既聊架构设计，也聊源码，聊聊服务治理框架要真正实现优雅停机，需要注意哪些细节。&lt;/p&gt;
&lt;p&gt;本文的写作思路是从 Dubbo 2.5.x 开始，围绕优雅停机这个优化点，一直追溯到最新的 2.7.x。先对 Dubbo 版本做一个简单的科普：2.7.x 和 2.6.x 是目前官方推荐使用的版本，其中 2.7.x 是捐献给 Apache 的版本，具备了很多新的特性，目前最新的 release 版本是 2.7.4，处于生产基本可用的状态；2.6.x 处于维护态，主要以 bugfix 为主，但经过了很多公司线上环境的验证，所以求稳的话，可以使用 2.6.x 分支最新的版本。至于 2.5.x，社区已经放弃了维护，并且 2.5.x 存在一定数量的 bug，本文介绍的 Dubbo 优雅停机特性便体现了这一点。&lt;/p&gt;
    
    </summary>
    
      <category term="RPC" scheme="http://lexburner.github.io/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="http://lexburner.github.io/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>使用 JMeter 进行 Dubbo 性能测试</title>
    <link href="http://lexburner.github.io/dubbo-perf-benchmark/"/>
    <id>http://lexburner.github.io/dubbo-perf-benchmark/</id>
    <published>2019-09-05T11:45:52.000Z</published>
    <updated>2019-09-26T09:45:31.281Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>说道性能测试工具，你会立刻联想到哪一个？ab（ApacheBench）、JMeter、LoadRunner、wrk…可以说市面上的压测工具实在是五花八门。那如果再问一句，对 Dubbo 进行性能压测，你会 pick 哪一个？可能大多数人就懵逼了。可以发现，大多数的压测工具对开放的协议支持地比较好，例如：HTTP 协议，但对于 Dubbo 框架的私有协议：<code>dubbo</code>，它们都显得力不从心了。</p><p>如果不从通用的压测工具上解决 Dubbo 的压测需求问题，可以自己写 Dubbo 客户端，自己统计汇总结果，但总归不够优雅，再加上很多开发同学没有丰富的测试经验，很容易出现一些偏差。说到底，还是压测工具靠谱，于是便引出了本文的主角 —— <strong><a href="https://github.com/thubbo/jmeter-plugins-for-apache-dubbo" target="_blank" rel="noopener">jmeter-plugins-for-apache-dubbo</a></strong>。这是一款由 Dubbo 社区 Commiter – <a href="https://ningyu1.github.io/blog/about/" target="_blank" rel="noopener">凝雨</a> 同学开发的 JMeter 插件，可以非常轻松地对 Dubbo 实现性能测试。</p><a id="more"></a><h2 id="2-JMeter-介绍"><a href="#2-JMeter-介绍" class="headerlink" title="2 JMeter 介绍"></a>2 JMeter 介绍</h2><p>在开始压测 Dubbo 之前，先简单介绍一下这款开源的性能测试工具 —— JMeter。JMeter 是 Apache 组织基于 Java 开发的一款性能测试工具。它最初被设计用于 Web 应用测试，但后来扩展到其他测试领域，并可以在 Windows、Mac、Linux 环境下安装使用。JMeter 还提供了图形界面，这使得编写测试用例变得非常简单，具有易学和易操作的特点。</p><blockquote><p>JMeter 官网：<a href="http://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="noopener">http://jmeter.apache.org/download_jmeter.cgi</a></p></blockquote><h3 id="2-1-安装-JMeter"><a href="#2-1-安装-JMeter" class="headerlink" title="2.1 安装 JMeter"></a>2.1 安装 JMeter</h3><p>截止本文发布，官方的最新版本为：<a href="http://mirrors.tuna.tsinghua.edu.cn/apache//jmeter/binaries/apache-jmeter-5.1.1.zip" target="_blank" rel="noopener">apache-jmeter-5.1.1.zip</a> , 下载后直接解压即可。</p><p><img src="http://kirito.iocoder.cn/image-20190905204943326.png" alt="jmeter 目录"></p><p>在 ${JMETER_HOME}/bin 下找到启动脚本，可以打开图形化界面</p><ul><li>Mac/Linux 用户可以直接使用 jmeter 可执行文件，或者 jmeter.sh 启动脚本</li><li>Windows 用户可以使用 jmeter.bat 启动脚本</li></ul><h3 id="2-2-命令行提示信息"><a href="#2-2-命令行提示信息" class="headerlink" title="2.2 命令行提示信息"></a>2.2 命令行提示信息</h3><p>启动过程中会有一段命令行日志输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">================================================================================</span><br><span class="line">Don't use GUI mode for load testing !, only for Test creation and Test debugging.</span><br><span class="line">For load testing, use CLI Mode (was NON GUI):</span><br><span class="line">   jmeter -n -t [jmx file] -l [results file] -e -o [Path to web report folder]</span><br><span class="line">&amp; increase Java Heap to meet your test requirements:</span><br><span class="line">   Modify current env variable HEAP="-Xms1g -Xmx1g -XX:MaxMetaspaceSize=256m" in the jmeter batch file</span><br><span class="line">Check : https://jmeter.apache.org/usermanual/best-practices.html</span><br><span class="line">================================================================================</span><br></pre></td></tr></table></figure><p>注意到第一行的提示，GUI 仅仅能够用于调试和创建测试计划，实际的性能测试需要使用命令行工具进行。</p><p><code>jmeter -n -t [jmx file] -l [results file] -e -o [Path to web report folder]</code></p><ul><li>【jmx file】：使用 GUI 创建的测试计划文件，后缀名为 <code>.jmx</code></li><li>【results file】：测试结果文本文件输出路径</li><li>【Path to web report folder】：测试报告输出路径，JMeter 的强大之处，可以生成图文并茂的测试报告</li></ul><h3 id="2-3-GUI-界面展示"><a href="#2-3-GUI-界面展示" class="headerlink" title="2.3 GUI 界面展示"></a>2.3 GUI 界面展示</h3><p><img src="http://kirito.iocoder.cn/image-20190905211412101.png" alt="image-20190905211412101"></p><p>上图所示为 JMeter 的主界面。官方提供了国际化支持，通过 【Options】-&gt;【Choose Language】可以将界面语言变更为简体中文。</p><h2 id="3-JMeter-压测-HTTP"><a href="#3-JMeter-压测-HTTP" class="headerlink" title="3 JMeter 压测 HTTP"></a>3 JMeter 压测 HTTP</h2><p>本节以 JMeter 压测 HTTP 为引子，介绍 JMeter 的使用方式，让没有使用过 JMeter 的读者对这款工具有一个较为直观的感受。</p><h3 id="3-1-创建线程组"><a href="#3-1-创建线程组" class="headerlink" title="3.1 创建线程组"></a>3.1 创建线程组</h3><p>在“测试计划”上右键 【添加】–&gt;【线程（用户）】–&gt;【线程组】。</p><p><img src="http://kirito.iocoder.cn/image-20190905211637435.png" alt="image-20190905211637435"></p><p>给线程组起一个名字，方便记忆。</p><p><img src="http://kirito.iocoder.cn/image-20190905211831670.png" alt="image-20190905211831670"></p><ul><li>线程数：决定了由多少线程并发压测</li><li>Ramp-Up：代表了 JMeter 创建所有线程所需要的时间，如图所示则代表每 0.1s 创建一个线程</li><li>循环次数：在运行所设置的次数之后，压测将会终止。如果想要运行固定时长的压测，可以设置为：永远，并在下面的调度器中指定持续时间</li></ul><h3 id="3-2-增加-HTTP-取样器"><a href="#3-2-增加-HTTP-取样器" class="headerlink" title="3.2 增加 HTTP 取样器"></a>3.2 增加 HTTP 取样器</h3><p>在刚刚创建的线程组上右键 【添加】–&gt;【取样器】–&gt;【HTTP 请求】。</p><p><img src="http://kirito.iocoder.cn/image-20190905211606505.png" alt="image-20190905211606505"></p><p>为 HTTP 取样器配置上压测地址和必要的参数</p><p><img src="http://kirito.iocoder.cn/image-20190905212937824.png" alt="image-20190905212937824"></p><h3 id="3-3-添加察看结果树"><a href="#3-3-添加察看结果树" class="headerlink" title="3.3 添加察看结果树"></a>3.3 添加察看结果树</h3><p>在刚刚创建的线程组上右键 【添加】–&gt;【监听器】–&gt;【察看结果树】。</p><p><img src="http://kirito.iocoder.cn/image-20190905213114409.png" alt="image-20190905213114409"></p><p>只有添加了【察看结果树】才能让我们看到 GUI 中测试的结果。</p><h3 id="3-4-准备-HTTP-Server"><a href="#3-4-准备-HTTP-Server" class="headerlink" title="3.4 准备 HTTP Server"></a>3.4 准备 HTTP Server</h3><p>使用 SpringBoot 可以快速构建一个 RestController，其暴露了 <code>localhost:8080/queryOrder/{orderNo}</code> 做为压测入口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderRestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/queryOrder/&#123;orderNo&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderDTO <span class="title">queryOrder</span><span class="params">(@PathVariable(<span class="string">"orderNo"</span>)</span> <span class="keyword">long</span> orderNo) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderService.queryOrder(orderNo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被压测的服务 OrderService ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderDTO <span class="title">queryOrder</span><span class="params">(<span class="keyword">long</span> orderNo)</span> </span>&#123;</span><br><span class="line">        OrderDTO orderDTO = <span class="keyword">new</span> OrderDTO();</span><br><span class="line">        orderDTO.setOrderNo(orderNo);</span><br><span class="line">        orderDTO.setTotalPrice(<span class="keyword">new</span> BigDecimal(ThreadLocalRandom.current().nextDouble(<span class="number">100.0</span>D)));</span><br><span class="line">        orderDTO.setBody(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>]);</span><br><span class="line">        <span class="keyword">return</span> orderDTO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-验证结果"><a href="#3-5-验证结果" class="headerlink" title="3.5 验证结果"></a>3.5 验证结果</h3><p> 在刚刚创建的线程组上右键 【验证】，执行单次验证，可以用来测试与服务端的连通性。在【察看结果树】选项卡中可以看到【响应数据】已经正常返回了。</p><p><img src="http://kirito.iocoder.cn/image-20190905214317033.png" alt="image-20190905214317033"></p><h3 id="3-6-执行测试计划"><a href="#3-6-执行测试计划" class="headerlink" title="3.6 执行测试计划"></a>3.6 执行测试计划</h3><p>还记得之前启动 GUI 时控制台曾经提示过我们，GUI 只负责创建测试计划并验证，不能用于执行实际的并发压测。在 GUI 中准备就绪之后，我们可以在【文件】-&gt;【保存测试计划为】中将测试计划另存为 <code>rest-order-thread-group.jmx</code> 测试文件，以便我们在命令行进行压测：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmeter -n -t ./rest-order-thread-group.jmx -l ./result.txt -e -o ./webreport</span><br></pre></td></tr></table></figure><p>下图展示了最终生成的测试报告，主要汇总了执行次数、响应时间、吞吐量、网络传输速率。</p><p><img src="http://kirito.iocoder.cn/image-20190905215339406.png" alt="image-20190905215339406"></p><p>在实际的测试报告中，还有更加详细的维度可以展示，上述只是展示了汇总信息。</p><h2 id="4-JMeter-压测-Dubbo"><a href="#4-JMeter-压测-Dubbo" class="headerlink" title="4 JMeter 压测 Dubbo"></a>4 JMeter 压测 Dubbo</h2><p>JMeter 默认并不支持私有的 dubbo 协议，但其优秀的扩展机制使得只需要添加插件，就可以完成 Dubbo 压测，这一节也是本文重点介绍的部分。</p><h3 id="4-1-安装-jmeter-plugins-for-apache-dubbo"><a href="#4-1-安装-jmeter-plugins-for-apache-dubbo" class="headerlink" title="4.1 安装 jmeter-plugins-for-apache-dubbo"></a>4.1 安装 jmeter-plugins-for-apache-dubbo</h3><blockquote><p>插件地址：<a href="https://github.com/thubbo/jmeter-plugins-for-apache-dubbo" target="_blank" rel="noopener">https://github.com/thubbo/jmeter-plugins-for-apache-dubbo</a></p></blockquote><p>目前该插件支持对最新版本的 Dubbo 进行压测，推荐的安装方式：</p><ol><li><p>克隆项目：<code>git clone https://github.com/thubbo/jmeter-plugins-for-apache-dubbo.git</code></p></li><li><p>打包项目，构建 JMeter 插件：<code>mvn clean install</code> ，得到：jmeter-plugins-dubbo-2.7.3-jar-with-dependencies.jar</p></li><li>将插件添加到 <code>${JMETER_HOME}\lib\ext</code></li></ol><p><img src="http://kirito.iocoder.cn/image-20190906140927770.png" alt="安装插件后的 ext 目录"></p><h3 id="4-2-增加-Dubbo-取样器"><a href="#4-2-增加-Dubbo-取样器" class="headerlink" title="4.2 增加 Dubbo 取样器"></a>4.2 增加 Dubbo 取样器</h3><p>之前的小结已经介绍了如何添加线程组和 HTTP 取样器，现在想要对 Dubbo 应用进行性能测试，可以直接复用之前的线程组配置，在线程组上右键 【添加】–&gt;【取样器】–&gt;【Dubbo Sample】。</p><p><img src="http://kirito.iocoder.cn/image-20190906141506679.png" alt="image-20190906141506679"></p><p>创建 Dubbo 取样器之后，可以对其进行配置</p><p><img src="http://kirito.iocoder.cn/image-20190906143444779.png" alt="image-20190906143444779"></p><h3 id="4-3-准备-Dubbo-Provider"><a href="#4-3-准备-Dubbo-Provider" class="headerlink" title="4.3 准备 Dubbo Provider"></a>4.3 准备 Dubbo Provider</h3><p>复用 HTTP 取样器时的 <code>OrderService</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderDubboProvider</span> <span class="keyword">implements</span> <span class="title">OrderApi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderDTO <span class="title">queryOrder</span><span class="params">(<span class="keyword">long</span> orderNo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderService.queryOrder(orderNo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置 application.properties，注册服务到 Zookeeper 注册中心:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dubbo.scan.basePackages=com.alibaba.edas.benchmark</span><br><span class="line">dubbo.application.name=dubbo-provider-demo</span><br><span class="line">dubbo.registry.address=zookeeper://127.0.0.1:2181</span><br><span class="line">dubbo.protocol.port=20880</span><br></pre></td></tr></table></figure><h3 id="4-4-验证结果"><a href="#4-4-验证结果" class="headerlink" title="4.4 验证结果"></a>4.4 验证结果</h3><p>在 JMeter 中配置好 Dubbo 服务所连接的注册中心，接着通过 <code>Get Provider List</code> 可以获取到服务提供者列表，以供压测选择。在线程组上右键 【验证】，执行单次验证，可以用来测试与服务端的连通性。在【察看结果树】选项卡中可以看到【响应数据】可以正常执行 Dubbo 调用了。</p><p><img src="http://kirito.iocoder.cn/image-20190906143425928.png" alt="image-20190906143425928"></p><h3 id="4-5-执行测试计划"><a href="#4-5-执行测试计划" class="headerlink" title="4.5 执行测试计划"></a>4.5 执行测试计划</h3><p>可以将 Dubbo 取样器和 HTTP 取样器包含在同一个测试计划中一起执行，同时进行了 Dubbo 接口与 Rest 接口的性能对比。在命令行进行压测：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmeter -n -t ./rest-order-thread-group.jmx -l ./result.txt -e -o ./webreport</span><br></pre></td></tr></table></figure><p>下图展示了最终生成的测试报告：</p><p><img src="http://kirito.iocoder.cn/image-20190906144422407.png" alt="image-20190906144422407"></p><p>Dubbo 接口与 Rest 接口所封装的业务接口均为 <code>OrderService</code>，所以压测上的差距直接体现出了 Dubbo 和 Rest 的差距。从报告对比上来看，Dubbo 接口的平均 RT 远低于 Rest 接口。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>本文从零到一介绍了使用 JMeter 压测 HTTP 的方法，让读者熟悉 JMeter 的使用方式，并着重介绍了使用 jmeter-plugins-for-apache-dubbo 插件压测 Dubbo 的方法。</p><p>由于 JMeter Plugin 的限制，目前 Dubbo 的压测请求是通过泛化调用进行发送的，会有一定程度的性能下降，所以在实际评估 Dubbo 接口性能时，接口实际性能会比压测结果更加乐观。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1 前言&quot;&gt;&lt;/a&gt;1 前言&lt;/h2&gt;&lt;p&gt;说道性能测试工具，你会立刻联想到哪一个？ab（ApacheBench）、JMeter、LoadRunner、wrk…可以说市面上的压测工具实在是五花八门。那如果再问一句，对 Dubbo 进行性能压测，你会 pick 哪一个？可能大多数人就懵逼了。可以发现，大多数的压测工具对开放的协议支持地比较好，例如：HTTP 协议，但对于 Dubbo 框架的私有协议：&lt;code&gt;dubbo&lt;/code&gt;，它们都显得力不从心了。&lt;/p&gt;
&lt;p&gt;如果不从通用的压测工具上解决 Dubbo 的压测需求问题，可以自己写 Dubbo 客户端，自己统计汇总结果，但总归不够优雅，再加上很多开发同学没有丰富的测试经验，很容易出现一些偏差。说到底，还是压测工具靠谱，于是便引出了本文的主角 —— &lt;strong&gt;&lt;a href=&quot;https://github.com/thubbo/jmeter-plugins-for-apache-dubbo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;jmeter-plugins-for-apache-dubbo&lt;/a&gt;&lt;/strong&gt;。这是一款由 Dubbo 社区 Commiter – &lt;a href=&quot;https://ningyu1.github.io/blog/about/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;凝雨&lt;/a&gt; 同学开发的 JMeter 插件，可以非常轻松地对 Dubbo 实现性能测试。&lt;/p&gt;
    
    </summary>
    
      <category term="RPC" scheme="http://lexburner.github.io/categories/RPC/"/>
    
    
      <category term="DUBBO" scheme="http://lexburner.github.io/tags/DUBBO/"/>
    
      <category term="JMeter" scheme="http://lexburner.github.io/tags/JMeter/"/>
    
  </entry>
  
  <entry>
    <title>华为云 TaurusDB 性能挑战赛赛题总结</title>
    <link href="http://lexburner.github.io/taurusdb-race/"/>
    <id>http://lexburner.github.io/taurusdb-race/</id>
    <published>2019-09-02T12:19:23.000Z</published>
    <updated>2019-09-26T09:45:29.481Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p><img src="http://kirito.iocoder.cn/image-20190902204538276.png" alt="image-20190902204538276"></p><p>回顾第一次参加性能挑战赛 – 第四届阿里中间件性能挑战赛，那时候真的是什么都不会，只有一腔热情，借着比赛学会了 Netty、学会了文件 IO 的最佳实践，到了这次华为云举办的 TaurusDB 性能挑战赛，已经是第三次参加比赛了，同时也是最“坎坷”的一次比赛。经过我和某位不愿意透露姓名的 96 年小迷妹的不懈努力，最终跑分排名为第 3 名。</p><a id="more"></a><p>如果要挑选一个词来概括这次比赛的核心内容，那非”计算存储分离“莫属了，通过这次比赛，自己也对计算存储分离架构有了比较直观的感受。为了比较直观的体现计算存储分离的优势，以看电影来举个例子：若干年前，我总是常备一块大容量的硬盘存储小电影，但自从家里带宽升级到 100mpbs 之后，我从来不保存电影了，要看直接下载 / 缓冲，基本几分钟就好了。这在几年前还不可想象，如今是触手可及的事实，归根到底是随着互联网的发展，网络 IO 已经不再是瓶颈了。</p><p>计算存储分离架构相比传统本地存储架构而言，具有更加灵活、成本更低等特性，但架构的复杂性也会更高，也会更加考验选手的综合能力。</p><blockquote><p>计算存储分离架构的含义：</p><ul><li>存储端有状态，只存储数据，不处理业务逻辑。</li><li>计算端无状态，只处理逻辑，不持久化存储数据。</li></ul></blockquote><h2 id="2-赛题概览"><a href="#2-赛题概览" class="headerlink" title="2 赛题概览"></a>2 赛题概览</h2><p>比赛整体分成了初赛和复赛两个部分，初赛要求实现一个简化、高效的本地 kv 存储引擎，复赛在初赛的基础上增加了计算存储分离的架构，计算节点需要通过网络传输将数据递交给存储节点存储。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">KVStoreRace</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">init</span><span class="params">(<span class="keyword">final</span> String dir, <span class="keyword">final</span> <span class="keyword">int</span> thread_num)</span> <span class="keyword">throws</span> KVSException</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">set</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="keyword">byte</span>[] value)</span> <span class="keyword">throws</span> KVSException</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> Ref&lt;<span class="keyword">byte</span>[]&gt; val)</span> <span class="keyword">throws</span> KVSException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算节点和存储节点共用上述的接口，评测程序分为 2 个阶段：</p><p><strong> 正确性评测 </strong></p><p>此阶段评测程序会并发写入随机数据（key 8B、value 4KB），写入数据过程中进行任意次进程意外退出测试，引擎需要保证异常中止不影响已经写入的数据正确性。<br>异常中止后，重启引擎，验证已经写入数据正确性和完整性，并继续写入数据，重复此过程直至数据写入完毕。<br>只有通过此阶段测试才会进入下一阶段测试。</p><p><strong> 性能评测 </strong></p><p>随机写入：16 个线程并发随机写入，每个线程使用 Set 各写 400 万次随机数据（key 8B、value 4KB）<br>顺序读取：16 个线程并发按照写入顺序逐一读取，每个线程各使用 Get 读取 400 万次随机数据<br>热点读取：16 个线程并发读取，每个线程按照写入顺序热点分区，随机读取 400 万次数据，读取范围覆盖全部写入数据。热点的逻辑为：按照数据的写入顺序按 10MB 数据粒度分区，分区逆序推进，在每个 10MB 数据分区内随机读取。随机读取次数会增加约 10%。</p><p><strong> 语言限定 </strong></p><p>CPP &amp; Java，一起排名</p><h2 id="3-赛题剖析"><a href="#3-赛题剖析" class="headerlink" title="3 赛题剖析"></a>3 赛题剖析</h2><p>看过我之前《PolarDB 数据库性能大赛 Java 选手分享》的朋友应该对题目不会感到陌生，基本可以看做是在 PolarDB 数据库性能挑战赛上增加一个网络通信的部分，所以重头戏基本是在复赛网络通信的比拼上。初赛主要是文件 IO 和存储架构的设计，如果对文件 IO 常识不太了解，可以先行阅读 <a href="https://www.cnkirito.moe/file-io-best-practise/" target="_blank" rel="noopener">《文件 IO 操作的一些最佳实践》</a>。</p><p><img src="http://kirito.iocoder.cn/image-20190902214231821.png" alt="image-20190902214231821"></p><h3 id="3-1-架构设计"><a href="#3-1-架构设计" class="headerlink" title="3.1 架构设计"></a>3.1 架构设计</h3><p>计算节点只负责生成数据，在实际生产中计算节点还承担额外的计算开销，由于计算节点是无状态的，所以不能够聚合数据写入、落盘等操作，但可以在 Get 触发网络 IO 时一次读取大块数据用作缓存，减少网络 IO 次数。</p><p>存储节点负责存储数据，考验了选手对磁盘 IO 和缓存的设计，可以一次使用缓存写入 / 读取大块数据，减少磁盘 IO 次数。</p><p>所以选手们将会围绕网络 IO、磁盘 IO 和缓存设计来设计整体架构。</p><h3 id="3-2-正确性检测"><a href="#3-2-正确性检测" class="headerlink" title="3.2 正确性检测"></a>3.2 正确性检测</h3><p>赛题明确表示会进行 kill -9 并验证数据的一致性，正确性检测主要影响的是写入阶段。</p><p>存储节点负责存储数据，需要保证 kill -9 不丢失数据，但并不要求断电不丢失，这间接地阐释了一点：我们可以使用 PageCache 来做写入缓存；正确性检测对于计算节点与存储节点之间通信影响便是：每次写入操作都必须 ack，所以选手必须保证同步通信，类似于 ping/pong 模型。</p><h3 id="3-3-性能评测"><a href="#3-3-性能评测" class="headerlink" title="3.3 性能评测"></a>3.3 性能评测</h3><p>性能评测由随机写、顺序读、热点读（随机读取热点数据）三部分构成。</p><p>随机写阶段与 PolarDB 的评测不同，TaurusDB 随机写入 key 的 16 个线程是隔离的，即 A 线程写入的数据只会由 A 线程读出，可以认为是彼此独立的 16 个实例在执行评测，这大大简化了我们的架构。</p><p>顺序读阶段的描述也很容易理解，需要注意的是这里的顺序是按照写入顺序，而不是 Key 的字典序，所以随机写可以转化为顺序写，也方便了选手去设计顺序读的架构。</p><p>热点读阶段有点故弄玄虚了，其实就是按照 10M 数据为一个分区进行逆序读，同时在 10M 数据范围内掺杂一些随机读，由于操作系统的预读机制只会顺序预读，无法逆序预读，PageCache 将会在这个环节会失效，考验了选手自己设计磁盘 IO 缓存的能力。 </p><h2 id="4-架构详解"><a href="#4-架构详解" class="headerlink" title="4 架构详解"></a>4 架构详解</h2><h3 id="4-1-全局架构"><a href="#4-1-全局架构" class="headerlink" title="4.1 全局架构"></a>4.1 全局架构</h3><p><img src="http://kirito.iocoder.cn/image-20190903130239656.png" alt="image-20190903130239656"></p><p>计算存储分离架构自然会分成计算节点和存储节点两部分来介绍。计算节点会在内存维护数据的索引表；存储节点负责存储持久化数据，包括索引文件和数据文件；计算节点与存储节点之间的读写都会经过网络 IO。</p><h3 id="4-2-随机写架构"><a href="#4-2-随机写架构" class="headerlink" title="4.2 随机写架构"></a>4.2 随机写架构</h3><p><img src="http://kirito.iocoder.cn/image-20190903134509621.png" alt="image-20190903134509621"></p><p>随机写阶段，评测程序调用计算节点的 set 接口，发起网络 IO，存储节点接受到数据后不会立刻落盘，针对 data 和 index 的处理也会不同。针对 data 部分，会使用一块缓冲区（如图：Mmap Merge IO）承接数据，由于 Mmap 的特性，会形成 Merge File 文件，一个数据缓冲区可以聚合 16 个数据，当缓冲区满后，将缓冲区的数据追加到数据文件后，并清空 Merge File；针对 index 部分，使用 Mmap 直接追加到索引文件中。</p><blockquote><p>F: 1. data 部分为什么搞这么复杂，需要聚合 16 个数据再刷盘？</p><p>Q:     针对此次比赛的数据盘，实测下来 16 个数据刷盘可以打满 IO。</p><p>F: 2. 为什么使用 Mmap Merge IO 而不直接使用内存 Merge IO？</p><p>Q:    正确性检测阶段，存储节点可能会被随机 kill，Mmap 做缓存的好处是操作系统会帮我们落盘，不会丢失数据</p><p>F: 3. 为什么 index 部分直接使用 Mmap，而不和 data 部分一样处理？</p><p>Q:    这需要追溯到 Mmap 的特点，Mmap 适合直接写索引这种小数据，所以不需要聚合。</p></blockquote><h3 id="4-3-热点读-amp-顺序读架构"><a href="#4-3-热点读-amp-顺序读架构" class="headerlink" title="4.3 热点读 &amp; 顺序读架构"></a>4.3 热点读 &amp; 顺序读架构</h3><p><img src="http://kirito.iocoder.cn/image-20190903134612617.png" alt="image-20190903134612617"></p><p>热点读取阶段 &amp; 顺序读取阶段 ，这两个阶段其实可以认为是一种策略，只不过一个正序，一个逆序，这里以热点读为例介绍。我们采取了贪心的思想，一次读取操作本应该只会返回 4kb 的数据，但为了做预读缓存，我们决定会存储节点返回 10M 的数据，并缓存在计算节点中，模拟了一个操作系统预读的机制，同时为了能够让计算节点精确知道缓存是否命中，会同时返回索引数据，并在计算节点的内存中维护索引表，这样便减少了成吨的网络 IO 次数。</p><h3 id="4-4-存储设计"><a href="#4-4-存储设计" class="headerlink" title="4.4 存储设计"></a>4.4 存储设计</h3><p><img src="http://kirito.iocoder.cn/image-20190903133433218.png" alt="image-20190903133433218"></p><p>站在每个线程的视角，可以发现在我们的架构中，每个线程都是独立的。评测程序会对每个线程写入 400w 数据，最终形成 16 <em> 16G 的数据文件和 16 </em> 32M 左右的索引文件。</p><p>数据文件不停追加 MergeFile，相当于一次落盘单位是 64K（16 个数据），由于自行聚合了数据，所以可以采用 Direct IO，减少操作系统的 overhead。</p><p>索引文件由小数据构成，所以采用 Mmap 方式直接追加写</p><p>计算节点由于无状态的特性，只能在内存中维护索引结构。</p><h3 id="4-5-网络通信设计"><a href="#4-5-网络通信设计" class="headerlink" title="4.5 网络通信设计"></a>4.5 网络通信设计</h3><p><img src="http://kirito.iocoder.cn/image-20190903193128706.png" alt="image-20190903193128706"></p><p>我们都知道 Java 中有 BIO（阻塞 IO）和 NIO（非阻塞 IO）之分，并且大多数人可能会下意识觉得：NIO 就是比 BIO 快。而这次比赛恰恰是要告诉大家，这两种 IO 方式没有绝对的快慢之分，只有在合适的场景中选择合适的 IO 方式才能发挥出最佳性能。</p><p>稍微分析下这次比赛的通信模型，写入阶段由于需要保证每次 set 不受 kill 的影响，所以需要等到同步返回后才能进行下一次 set，而 get 本身依赖于返回值进行数据校验，所以从通信模型上看只能是同步 ping/pong 模型；从线程数上来看，只有固定的 16 个线程进行收发消息。以上两个因素暗示了 BIO 将会非常契合这次比赛。</p><blockquote><p>在很多人的刻板印象中，阻塞就意味着慢，非阻塞就意味着快，这种理解是完全错误的，快慢取决于通信模型、系统架构、带宽、网卡等因素。我测试了 NIO + CountDownLatch 和 BIO 的差距，前者会比后者整体慢 100s ~ 130s。</p></blockquote><h2 id="5-细节优化点"><a href="#5-细节优化点" class="headerlink" title="5 细节优化点"></a>5 细节优化点</h2><h3 id="5-1-最大化磁盘吞吐量"><a href="#5-1-最大化磁盘吞吐量" class="headerlink" title="5.1 最大化磁盘吞吐量"></a>5.1 最大化磁盘吞吐量</h3><p>但凡是涉及到磁盘 IO 的比赛，首先需要测试便是在 Direct IO 下，一次读写多大的块能够打满 IO，在此基础上，才能进行写入缓冲设计和读取缓存设计，否则在这种争分夺秒的性能挑战赛中不可能取得较好的名次。测试方法也很简单，如果能够买到对应的机器，直接使用 iostat 观察不同刷盘大小下的 iops 即可，如果比赛没有机器，只能祭出调参大法，不停提交了，这次 TaurusDB 的盘实测下来 64k、128K 都可以获得最大的吞吐量。</p><h3 id="5-2-批量回传数据"><a href="#5-2-批量回传数据" class="headerlink" title="5.2 批量回传数据"></a>5.2 批量回传数据</h3><p>计算节点设计缓存是一个比较容易想到的优化点，按照常规的思路，索引应该是维护在存储节点，但这样做的话，计算节点在 get 数据时就无法判断是否命中缓存，所以在前文的架构介绍中，我们将索引维护在了计算节点之上，在第一次 get 时，顺便恢复索引。批量返回数据的优势在于增加了缓存命中率、降低总网络 IO 次数、减少上行网络 IO 数据量，是整个比赛中分量较重的一个优化点。</p><h3 id="5-3-流控"><a href="#5-3-流控" class="headerlink" title="5.3 流控"></a>5.3 流控</h3><p><img src="http://kirito.iocoder.cn/image-20190903201156406.png" alt="image-20190903201156406"></p><p>在比赛中容易出现的一个问题，在批量返回 10M 数据时经常会出现网络卡死的情况，一时间无法定位到问题，以为是代码 BUG，但有时候又能跑出分数，不得以尝试过一次返回较少的数据量，就不会报错。最后还是机智的小迷妹定位到问题是 CPU 和 IO 速率不均等导致的，解决方案便是在一次 pong 共计返回 10M 的基础上，将报文拆分成 64k 的小块，中间插入额外的 CPU 操作，最终保证了程序稳定性的同时，也保障了最佳性能。</p><blockquote><p>额外的 CPU 操作例如：for(int i=0;i&lt;700;i++)，不要小看这个微不足道的一个 for 循环哦。</p></blockquote><p>流控其实也是计算存储分离架构一个常见设计点，存储节点与计算节点的写入速度需要做一个平衡，避免直接打垮存储节点，也有一种”滑动窗口“机制专门应对这种问题，不在此赘述了。</p><h3 id="5-4-预分配文件"><a href="#5-4-预分配文件" class="headerlink" title="5.4 预分配文件"></a>5.4 预分配文件</h3><p>在 Cpp 中可以使用 fallocate 预先分配好文件大小，会使得写入速度提升 2s。在 Java 中没有 fallocate 机制，但是可以利用评测程序的漏洞，在 static 块中事先写好 16 * 16G 的文件，同样可以获得 fallocate 的效果。</p><h3 id="5-5-合理设计索引结构"><a href="#5-5-合理设计索引结构" class="headerlink" title="5.5 合理设计索引结构"></a>5.5 合理设计索引结构</h3><p>get 时需要根据 key 查询到文件偏移量，这显示是一个 Map 结构，在这个 Map 上也有几个点需要注意。以 Java 为例，使用 HashMap 是否可行呢？当然可以，但是缺点也很明显，其会占用比较大的内存，而且存取性能不好，可以使用 LongIntHashMap 来代替，看过我之前文章的朋友应该不会对这个数据结构感到陌生，它是专门为基础数据类型设计的 Map 容器。</p><p>每个线程 400w 数据，每个线程独享一个索引 Map，为了避免出现扩容，需要合理的设置扩容引子和初始化容量：new LongIntHashMap(410_0000, 0.99);</p><h3 id="5-6-Direct-IO"><a href="#5-6-Direct-IO" class="headerlink" title="5.6 Direct IO"></a>5.6 Direct IO</h3><p>最终进入决赛的，有三支 Java 队伍，相比较 Cpp 得天独厚的对操作系统的灵活控制性，Java 选手更像是带着镣铐在舞蹈，幸好有了上次 PolarDB 比赛的经验，我提前封装好了 Java 的 Direct IO 类库：<a href="https://github.com/lexburner/kdio" target="_blank" rel="noopener">https://github.com/lexburner/kdio</a>，相比 FileChannel，它能够使得磁盘 IO 效率更高。得知有 Java 选手真的在比赛中使用了我的 Direct IO 类库，也是比赛中实实切切的乐趣之一。</p><h2 id="6-失败的优化点"><a href="#6-失败的优化点" class="headerlink" title="6 失败的优化点"></a>6 失败的优化点</h2><h3 id="6-1-预读线程先行"><a href="#6-1-预读线程先行" class="headerlink" title="6.1 预读线程先行"></a>6.1 预读线程先行</h3><p>考虑到网络 IO 还是比本地磁盘 IO 要慢的，一个本以为可行的方案是单独使用预读线程进行存储节点的磁盘 IO，设计一个 RingBuffer，不断往前预读，直到环满，计算阶段 get 时会消费 RingBuffer 的一格缓存，从而使得网络 IO 和磁盘 IO 不会相互等待。实际测试下来，发现瓶颈主要还是在于网络 IO，这样的优化徒增了不少代码，不利于进行其他的优化尝试，最终放弃。</p><h3 id="6-2-计算节点聚合写入缓冲"><a href="#6-2-计算节点聚合写入缓冲" class="headerlink" title="6.2 计算节点聚合写入缓冲"></a>6.2 计算节点聚合写入缓冲</h3><p>既然在 get 阶段时存储节点批量返回数据给计算节点可以提升性能，那 set 阶段聚合批量的数据再发送给存储节点按理来说也能提升性能吧？的确如此，如果不考虑正确性检测，这的确是一个不错的优化点，但由于 kill 的特性使得我们不得不每一次 set 都进行 ACK。但是！可以对将 4/8/16 个线程编为一组进行聚合呀！通过调整参数来确定该方案是否可行。</p><p><img src="http://kirito.iocoder.cn/image-20190903215024344.png" alt="image-20190903215024344"></p><p>然后事与愿违，该方案并没有取得成效。</p><h2 id="7-聊聊比赛吧"><a href="#7-聊聊比赛吧" class="headerlink" title="7 聊聊比赛吧"></a>7 聊聊比赛吧</h2><p>之前此类工程性质的性能挑战赛只有阿里一家互联网公司承办过，作为热衷于中间件性能优化的参赛选手而言，非常高兴华为也能够举办这样性质的比赛。虽然比赛中出现了诸多的幺蛾子，但毕竟是第一次承办比赛，我也就不表了。</p><p>如果你同样也是性能挑战赛的爱好者，想要在下一次中间件性能挑战赛中有一群小伙伴一起解题、组队，体验冲分的乐趣，欢迎关注我的微信公众号：【Kirito 的技术分享】，也欢迎加入微信技术交流群进行交流 ~</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1 前言&quot;&gt;&lt;/a&gt;1 前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://kirito.iocoder.cn/image-20190902204538276.png&quot; alt=&quot;image-20190902204538276&quot;&gt;&lt;/p&gt;
&lt;p&gt;回顾第一次参加性能挑战赛 – 第四届阿里中间件性能挑战赛，那时候真的是什么都不会，只有一腔热情，借着比赛学会了 Netty、学会了文件 IO 的最佳实践，到了这次华为云举办的 TaurusDB 性能挑战赛，已经是第三次参加比赛了，同时也是最“坎坷”的一次比赛。经过我和某位不愿意透露姓名的 96 年小迷妹的不懈努力，最终跑分排名为第 3 名。&lt;/p&gt;
    
    </summary>
    
      <category term="性能挑战赛" scheme="http://lexburner.github.io/categories/%E6%80%A7%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B/"/>
    
    
      <category term="数据库" scheme="http://lexburner.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>日本东京游记 || 内含秋叶原、动漫打卡地攻略</title>
    <link href="http://lexburner.github.io/tokyo-travel/"/>
    <id>http://lexburner.github.io/tokyo-travel/</id>
    <published>2019-09-02T12:19:23.000Z</published>
    <updated>2019-09-26T09:45:31.509Z</updated>
    
    <content type="html"><![CDATA[<p>由于表弟是个狂热的二次元爱好者，受我小姨之托，带他去日本游玩了一趟。趁着这个机会，打算给大家分享一下日本旅游的一些攻略，以祭奠我逝去的年假。这是我第二次去日本了，上一次还是大二时跟我初中舍友一起去的，所以这次去已经有了一些经验了，很多朋友表示想去日本，期待我能写一篇攻略，所以这篇攻略将会偏小白向，如果你是第一次去日本，那这篇攻略想必不会让你失望。</p><a id="more"></a><h2 id="出行准备"><a href="#出行准备" class="headerlink" title="出行准备"></a>出行准备</h2><h3 id="护照-签证"><a href="#护照-签证" class="headerlink" title="护照 / 签证"></a>护照 / 签证</h3><p>出国旅游前需要准备两样最基础的东西：护照和签证。</p><p><strong> 护照 </strong>。申请护照一般是由本人到户籍所在地的公安局出入境管理处办理，办理时长一般在 15 个工作日左右。因为我 4 年前去过日本，那时候已经办理了护照，一般护照有效期是 10 年左右，所以这次只需要办理签证就行了。</p><p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTy0quStR-Ax5GgRc2xtAryqZoCXKVMlqymWRdCf1S9G1QvMB4G" alt="护照"></p><p><strong> 签证 </strong>。日本现在有 <strong> 单次旅游 /3 年多次往返 /5 年多次往返 </strong> 三种签证。一般来讲，个人旅游办理的都是单次旅游，条件限制比较低，多次往返签证则相对要求较高。因为领区的不同，具体地区送签材料要求大家可以自己再去咨询。普通送签的话机票酒店信息，银行流水，在职在读等等都需要准备，需要的材料很多，选择跟团的话就可以省去很多麻烦事，旅行社办理签证可以节省下不少准备材料。</p><p>这次跟我表弟去日本，由于我在杭州工作，江浙沪属于上海领区，而他在广州，属于广州领区，所有即使是跟团游，我也只能找到旅行社单独办理个签。另外有一点值得注意的是，日本签证要求提供的个人照片尺寸为 4.5cm x 4.5cm，不太符合常规的中国制式，一般各个国家的签证照片都有各自的规定，准备时可以稍微留意下。</p><h3 id="行程安排"><a href="#行程安排" class="headerlink" title="行程安排"></a>行程安排</h3><p>关于行程安排，每个人自然有自己的想法，东京、北海道、大阪、京都都有各自吸引游客的景点。</p><p>有的人选择跟团，也有的人选择自由行，也有跟团和自由行的组合半自由行。我们这次选择的就是半自由行，旅行社会负责包揽机票、住宿和固定景点等事宜，也会有 2 天时间供我们在东京自由行，没有自由活动的日本之行是没有灵魂的！</p><p>赴日旅游的游客，我个人还是挺推荐这种 <strong> 半自由行 </strong> 的。旅行社会有包车穿梭于各个景点之间，酒店机票等事宜也不用自己操心，可以为前期攻略省下不少时间。提到自由行，虽然我不会日语，但是日本的中国人挺多的，并且所看到的大部分汉字基本都能看懂，服务中心一般用英语也可以沟通，自由行的时候也不用太过于担心。</p><h3 id="现金置换"><a href="#现金置换" class="headerlink" title="现金置换"></a>现金置换</h3><p><img src="http://puui.qpic.cn/qqvideo_ori/0/f0880s5eg95_496_280/0" alt="支付宝支付"></p><p>这次去日本算是体会到了日本的进步，在上次去日本时，主要还是通过现金、银联卡两种方式支付，而 2019 年的今天再去东京，大到商场百货，小到街边的拉面店，都已经支持了支付宝、微信这两种中国本土的快捷支付方式。</p><p>虽然刷卡、快捷支付很方便，但仍然还是有不少地方只支持现金的，例如日本的电车，所以出行前建议置换好足量的现金，我这次准备了 4000 人民币合 6w 日元的现金。价值较高的商品可以选择使用银联卡或者快捷支付这两种方式。</p><p>在国内置换日元。可以选择在银行柜台置换，也可以选择在机场置换。选择在机场置换大概率比银行置换要亏，需要交纳 50 块的手续费，而且汇率也不同，具体没有太多研究，但推荐大家在银行置换好日元。</p><p>在日本置换日元。在日本街头的 ATM 使用银联卡就可以取出日元了，当然也可以在到达机场兑换，另外值得一提的是日本的 711 和全家等便利连锁店都设有 ATM，秋叶原等外国游客较多的地方也设有外汇置换点，但是价格较贵。</p><blockquote><p>小 tips：￥是人民币（CNY）和日元（JPY）的货币符号。这两种货币的单位都是元，在日本可不要被高额的标价吓到哦，那是日元，不是人民币。</p></blockquote><h3 id="流量-amp-网络"><a href="#流量-amp-网络" class="headerlink" title="流量 &amp; 网络"></a>流量 &amp; 网络</h3><p>在日本，没有开通国际漫游的用户是没法使用手机的，建议赴日旅游前一定要提前准备好随身 wifi 或者开通国际流量包，两者价格都很实惠，推荐后者，毕竟随身 wifi 占据了一定的空间还需要一天充一次电。</p><p>由于我的手机卡不支持国际流量包，所以在淘宝提前租好了随身 wifi，一天只需要 9~13 块，网速还可以。如果想要租借随身 wifi，一定要记得在出发前提前 2 天下单，一般店铺都支持在机场自行取货。</p><blockquote><p>小 tips：随身 wifi 不能托运。</p></blockquote><h2 id="APP-推荐"><a href="#APP-推荐" class="headerlink" title="APP 推荐"></a>APP 推荐</h2><h3 id="谷歌地图"><a href="#谷歌地图" class="headerlink" title="谷歌地图"></a>谷歌地图</h3><p><img src="http://kirito.iocoder.cn/goog-618x338.jpg?imageMogr2/thumbnail/640x640/format/webp/blur/1x0/quality/75|imageslim" alt="goog-618x338"></p><p>自由行期间必备的 APP，基本走到哪儿都靠他了。可能会有朋友会问，为什么不推荐百度地图？实际上两个地图我这次都用到了，但总体感受是谷歌地图体验更好。</p><h3 id="换乘案内"><a href="#换乘案内" class="headerlink" title="换乘案内"></a>换乘案内</h3><p><img src="http://kirito.iocoder.cn/image-20190910162215664.png?imageMogr2/thumbnail/640x640/format/webp/blur/1x0/quality/75|imageslim" alt="换成案内"></p><p><strong> 换乘案内 </strong> 是在日本查询坐车信息的一个软件，功能跟谷歌相似，但比谷歌更详细，也更加准确，但是没有导航功能。在这个软件输入始发站以及到达站就会出来所有的乘坐信息，价格，速度，换乘。</p><p>因为日本的公共交通系统极为复杂，光东京一个地方就有 JR/ 都营 /Metro/ 京急 / 小田急等，类似于国内的 1 号线、2 号线，不同的线路分属于不同的铁道公司。例如 JR(Japan Railway) 线，就是其中最大规模的铁道路线。也是游客利用最多的线路之一。</p><p>在日本坐车需要注意以下几点：</p><ul><li>不同入口可能对应不同的线路，所以不要以为很近的两个入口都可以到达目的地，很有可能是不同线路的入口。</li><li>同一个站台，可能会有去往 <strong> 不同方向 </strong> 的电车，要注意看站台提示牌上显示的下一辆车的目的地。</li><li>同一个站台，同一个线路，会有 <strong> 特急 </strong>、<strong> 急行 </strong>、<strong> 快速 </strong>、<strong> 准急 </strong>、<strong> 普通 </strong> 等种类的电车，例如特急电车在很多站台就不会停靠，所有得严格按照软件的提示来乘坐。</li></ul><h3 id="大众点评"><a href="#大众点评" class="headerlink" title="大众点评"></a>大众点评</h3><p><strong> 大众点评 </strong> 这款软件即使在日本也可以用于搜索附近的美食、游玩地点！在成田车站附近时，我发现有比较多的拉面店、居酒屋，实在不知道该如何选择，就是通过大众点评来查看的评价和价钱，再做判断，比较实用。</p><h3 id="极简汇率"><a href="#极简汇率" class="headerlink" title="极简汇率"></a>极简汇率</h3><p>汇率换算软件。大多数情况下，记住汇率可以大致算出对应的人民币价钱，但在帮朋友代购或者比价时，就得精准地按汇率计算了，这款小巧的软件可以解决这个问题。</p><blockquote><p>小 tips：日本商品会直接包含 8% 的税率，有一部分商场面向外国游客，标记的是退税之后的价格，注意区分。</p></blockquote><h3 id="百度翻译"><a href="#百度翻译" class="headerlink" title="百度翻译"></a>百度翻译</h3><p><img src="http://kirito.iocoder.cn/image-20190918193218634.png?imageMogr2/thumbnail/640x640/format/webp/blur/1x0/quality/75|imageslim" alt="百度翻译"></p><p>虽然很多人说日本人英语不好，但东京作为一个国际大都市，给我的感觉是懂英语的人还是很多的，记得在秋叶原的电器小店中一位日本老爷爷，都可以跟我使用简单的英语词汇进行沟通。不过，也有秋叶原街头也有完全听不懂英语的女仆小姐姐，所以这个时候想要体验到日本的服务，一个翻译软件就显得非常重要了。</p><h2 id="东京购物"><a href="#东京购物" class="headerlink" title="东京购物"></a>东京购物</h2><p>东京有一些著名的商区，例如新宿、池袋、涩谷，也有二次元圣地秋叶原、世界三大奢侈品购物街银座。</p><blockquote><p>tips：购物时一定要随身携带护照，这是退税的证明，商品超过 500 元左右就可以使用护照来退税。</p></blockquote><h3 id="新宿"><a href="#新宿" class="headerlink" title="新宿"></a>新宿</h3><p><img src="http://kirito.iocoder.cn/image-20190919224026742.png?imageMogr2/thumbnail/640x640/format/webp/blur/1x0/quality/75|imageslim" alt="新宿站"></p><p><strong>LUMINE</strong>：属于日本年轻潮流百货，拥有许多日系少女风服装，日本的本土时尚品牌也非常齐全，并且价格比国内专柜要便宜。LUMINE 分 1、2 和 EST 三个馆。EST 偏平价一些，1 的品牌价格较 EST 来说贵一点，LUMINE 2 价格最高。</p><p><strong> 小田急百货 </strong>：是非常推荐购物的一家商场，貌似只有新宿 / 町田 / 藤泽有店。可以在大黑屋或者 Access Ticket 购买 300 日元一张的小田急 9 折折扣券，9 折＋免税几乎在这家百货店的所有柜台都可以使用。新宿因为位于热门商业区，因此可能会出现一些热门产品的断货可能，因此如果想要安静购物且货物相对比较全的可以选择町田或者藤泽的店，游客相对较少。</p><p><strong> 伊势丹百货 </strong>：日本的高档百货店，有众多品牌</p><p><strong> 京王百货店 </strong>：同样汇集了众多知名品牌，同样是购物的好去处</p><p><strong> 大黑屋 </strong>：日本中古店，可以去淘一些</p><p><strong>Big Camera</strong>：大型购物中心，以售卖电器为主，但是也有各类生活用品以及药妆（注意：这家店 93 折的券是购买除药妆以及部分电器产品以外的才可以使用，药妆折扣是 95 折，部分电器比如 switch 不参加折扣。</p><p><strong> 如果是准备在东京购物的话，个人还是十分推荐在新宿的 </strong>。新宿是各大百货店云集的地方，并且价格平价到高端的都有，适合各种人群，能够满足各种购物需求 ~ 基本你想要的在这里都能找到。因为每家百货店都有其特色，所以如果在新宿购物的话，还是可以考虑一下多分给新宿一些时间的，因为新宿一天真的逛不完。</p><h3 id="池袋"><a href="#池袋" class="headerlink" title="池袋"></a>池袋</h3><p>在池袋同样有几家百货店很推荐去，比如 <strong> 东武百货店，西武百货，LUMINE，还有就是 0101 丸井百货 </strong>，这是一家面向年轻人的综合百货店，也值得一逛。</p><p>另外池袋有一个叫 <strong>Sunshine City</strong>，这是一个大型综合商业设施，休闲购物观光餐饮都有。在这里可以俯瞰东京全景，如果大家想要去看整个东京的话这也是一个不错的选择 ~</p><p>池袋是除了秋叶原以外另一个动漫爱好者的圣地了，比较有名的有 <strong> 周刊 JUMP 主题乐园 </strong>，另一个则是神奇宝贝迷的天堂，<strong> 超级宝可梦中心 </strong>。如果是喜好二次元的小伙伴们可以做一下功课去池袋转一转哦</p><p>我们这一回在池袋的地铁站买到了超人气泡芙 <strong>CHOUXCREAM CHOUXCRI</strong>，在日本非常的有名，泡芙很好吃。喜欢甜食的小伙伴一定要去池袋打卡这家店哦 ~</p><h3 id="涩谷"><a href="#涩谷" class="headerlink" title="涩谷"></a>涩谷</h3><p>涩谷是日本众多潮流的发源地，有很多潮牌以及首饰专卖店，算是年轻的潮流街区。涩谷站周边有很多百货商场，以及著名的忠犬八公像。</p><p><strong> 涩谷 109</strong>：是涩谷的标志性建筑，巨大的 109 标志在街道上一目了然。里面有很多日系的少女品牌，非常推荐大家去这里购物，以销售少女平价潮流服饰而闻名。</p><p><strong> 西武百货 </strong>：大牌比较齐全，游客也相对较少，日本有连锁。</p><p><strong> 东急百货店 </strong>：涩谷店是日本的总店，品牌比较多，非常值得一逛。</p><p><strong>LOFT</strong>：日本是一个以文具著名的国家。LOFT 是文具控们必去的一家啦，其中最全的一家就位于涩谷，想要带些文具走的小伙伴们一定要去逛一逛啊。</p><h3 id="银座"><a href="#银座" class="headerlink" title="银座"></a>银座</h3><p><strong> 银座是世界三大繁华购物街之一 </strong>，很多高端品牌的旗舰店都坐落于银座，这里同样也是百货商场云集的地方，可以供大家选择的购物场所非常的多。同样的这次，虽然这次我们的行程里面没有安排银座，但是以下的商场都是来自于油皮朋友的推荐</p><p><strong> 三越百货：</strong> 日本一家老牌顶级百货商场了，历史非常悠久，这家商场品牌非常的全，购物服务非常的好。（如果来这家百货店，那么你名下有黑卡或者白金信用卡的话就可以去游客中心换一张 95 折的会员卡）</p><p><strong> 松屋银座百货：</strong> 算是银座的地标性建筑之一，LV 的店面引人注目</p><p><strong> 银座 SIX：</strong> 同样是一家购物环境非常不错的百货店，值得一提的是这家店有 1860 年创立的辻利茶铺。喜欢抹茶甜品的小伙伴可以在购物的间隙来这里歇歇脚，品尝下日本百年抹茶老店的味道</p><p><strong> 银座 DSM：</strong> 是川久保玲开的一家买手店，东京这家非常的大，一共有 7 层。是高端潮流品牌和奢侈品品牌并存的店。店铺的设计还有售卖的单品都有主理人川久保玲的色彩在里面。不过里面从平价到贵价的商品都有，喜欢潮流的小伙伴可以来这里看一看。</p><p><strong> 伊东屋：</strong> 这家店也是文具控必去的一家店铺 ~ 一共有 12 层，每层售卖的东西都不一样。</p><p>银座的旗舰店和百货商场非常多，但是总的来说是属于消费水平整体非常高的街区，所以大家可以根据自己的情况选择适合自己的商区 ~</p><h3 id="秋叶原"><a href="#秋叶原" class="headerlink" title="秋叶原"></a>秋叶原</h3><p><img src="http://kirito.iocoder.cn/image-20190918200501518.png?imageMogr2/thumbnail/640x640/format/webp/blur/1x0/quality/75|imageslim" alt="电器街"></p><p>秋叶原作为日本最出名的二次元朝圣地，同时还有一个电器街的身份，可以说技术宅的天堂了。</p><p>这次的行程中，花了一天半在秋叶原，可以说非常尽兴了。如果你乘坐大巴，不用问司机、不用看地图就可以清晰地辨认出你来到了秋叶原，整个街道的风格弥漫在二次元之中，在这里有鳞次栉比的手办店，日本特色的影像店，也有动次打次的电玩店，卡哇伊的女仆店。</p><h2 id="游玩攻略"><a href="#游玩攻略" class="headerlink" title="游玩攻略"></a>游玩攻略</h2><h3 id="镰仓"><a href="#镰仓" class="headerlink" title="镰仓"></a>镰仓</h3><p><img src="http://kirito.iocoder.cn/image-20190918204733386.png?imageMogr2/thumbnail/640x640/format/webp/blur/1x0/quality/75|imageslim" alt="镰仓车站"></p><p>神奈川县镰仓，小小的街道，没有太多人。战神源义经的子孙在这里创立了大名鼎鼎的镰仓幕府；几乎笼罩了所有 80 后童年的灌篮高手片头曲里，樱木花道对赤木晴子挥手的地方就取景于镰仓高校前站；倒数第二次恋爱中千明深夜从东京回来居住的小城也是这里。作为继京都、奈良后日本第三座知名的古都，这里的人流量比起其他两座城市要小很多。但就是因为这样，当你坐车江之电瞎转或是慢悠悠散布在海岸上的时候，能发现很多有爱的小细节，请用随意的慢节奏去体会这座海边的古都。</p><p>在镰仓不能错过的是乘坐著名的绿皮电车江之电电车，电车穿梭于一排排日本民宿之中，驰行一段时间后，还可以看到海边，迎着和煦并带着一丝湿意的海风，再过一段会经过镰仓高校前站，正好看到放学的高中生，一切都充满了青春的气息。遗憾的是中途路过著名的护栏景点，只可远观，没能下车打卡。</p><h3 id="江之岛"><a href="#江之岛" class="headerlink" title="江之岛"></a>江之岛</h3><p><img src="http://kirito.iocoder.cn/image-20190919224558339.png?imageMogr2/thumbnail/640x640/format/webp/blur/1x0/quality/75|imageslim" alt="江之岛"></p><p>从镰仓乘坐江之电到江之岛站便可以到达江之岛，江之电之所叫这个名字，最大的原因就是为了服务这里最著名的景点江之岛。 江之岛是湘南海岸的代表景点，也是神奈川县指定史迹名胜。江之岛是一个陆系岛，通过一道沙洲与大陆相连。岛上有几处观光景点。包括神社、公园、展望台和和岩洞。岛上有三处神社统称江之岛神社，可以参拜弁天，以求财富与好运。通往神社的一条商业街，街两旁都是各种小玩意和小吃，推荐一家当地的网红小吃：虾饼。</p><p>刚到达岛上就有一个中文非常棒的日本志愿者大妈在发放着岛上的地图，据说 2020 东京奥运会会有项目在此举办。</p><h3 id="秋叶原-1"><a href="#秋叶原-1" class="headerlink" title="秋叶原"></a>秋叶原</h3><p>在购物篇提到了秋叶原，但秋叶原游玩的地方肯定比购物的地方要多的多，并且还有很多日本“特色”的游玩场所。</p><p><img src="http://kirito.iocoder.cn/image-20190919224101473.png?imageMogr2/thumbnail/640x640/format/webp/blur/1x0/quality/75|imageslim" alt="秋叶原夜 - 街头拉客的女仆"></p><p>两次来日本都逛了秋叶原，但这次有一个独特的经历便是在深夜の巡礼。原本以为秋叶原街头只有 1~2 家女仆咖啡馆、女仆餐厅，夜晚来到里街才看到街边站着一排排女仆小姐姐，在招揽着 master。大多数店铺会派出 1 个女仆到街边拉客，在店里提供的大多数是爱心蛋包饭、咖啡等轻食，并且会有很多互动的小游戏，如果不会日语，就比较吃亏了，不过只要脸皮厚加上翻译软件的帮助，即使女仆小姐姐不会英语，也可以让你感受到这源自于大和民族独特的宅文化。</p><p><img src="http://kirito.iocoder.cn/image-20190918214547752.png?imageMogr2/thumbnail/640x640/format/webp/blur/1x0/quality/75|imageslim" alt="女仆店打卡"></p><p>除了声名远扬的女仆店，秋叶原还有遍地的各种类型的新奇店铺：</p><ul><li>电玩店，最出名的非 Sega 莫属了，里面充斥着各种年龄段的人群，跟国内大多数人童年印象中的游戏厅不同，这里的电玩店主要以 Galgame、小钢珠、音游为主（还有一些看都看不大懂的游戏），由于自己是个电玩小白，只能感受个氛围，凑个热闹。</li></ul><p><img src="http://kirito.iocoder.cn/image-20190919224248761.png?imageMogr2/thumbnail/640x640/format/webp/blur/1x0/quality/75|imageslim" alt="复古游戏"></p><ul><li>写真店，我也是来了日本才知道，竟然东京街头还有专门卖女子偶像写真营生的店铺，以 AKB48 为首。</li><li><p>AKB48 主题餐厅、高达主题餐厅，这两个餐厅可以说是秋叶原的地标了，第二次来日本，竟然店铺还换了个位置，不过牌子倒是还在。</p></li><li><p>手办店。关于日本的手办店，去逛的时候一定要做好心理预期，因为那些没有包装盒的手办基本都是二手的，所以看起来很精致，而且价格也不是很贵，普通的手办只需要 200-400 人民币就可以拿下；很多低于 1000 元的手办其实都有着 made in China 的说明，有人会觉得大老远跑到日本买个中国制造不是有猫病吗，其实不建议这么想，因为日本的人工费很高，所以大多数手办都是日本出图纸，转到中国制造，最后根据成品质量来决定价格。</p></li></ul><p><img src="http://kirito.iocoder.cn/image-20190918220151586.png?imageMogr2/thumbnail/640x640/format/webp/blur/1x0/quality/75|imageslim" alt="手办店"></p><h3 id="歌舞伎町"><a href="#歌舞伎町" class="headerlink" title="歌舞伎町"></a>歌舞伎町</h3><p><img src="http://kirito.iocoder.cn/image-20190919200318118.png" alt="歌舞伎町一番街"></p><p>歌舞伎町说白了就是中国的风月场所，位于新宿的歌舞伎町有两条街：一番街和二番街，仅仅走马观花地看了一遍街道布局，但并不推荐大家体验。由于笔者是一个非常纯洁的人，不太了解这里，所以选取了知乎的一些介绍：</p><p>「就在这个夜里各种外围女陪酒男出没的地区，拿到执照可以与从业人员发生关系的店面，其实仅有 5 家。而其他上千家的店面，客人任何试图发生性行为的举动，店家都会强制报警以猥亵罪起诉你，或者向你索取高额的封口费，这个数字从几千人民币到几万不等。</p><p>那些其他的店面，虽然也属于风月场所，但接客内容分为两类：一种是按摩、SPA 类型的内容，同样，一旦有猥亵店员的行为，请参照上面说明。</p><p>但话说回来，这些店里的最大问题是收费：一瓶市场价 1600 人民币左右的唐培里侬香槟，在店里至少会收 1 万人民币一瓶… 而如果想跟哪个姑娘熟络起来，至少得去个 3-4 次，每次不开个香槟、红酒什么的，基本别想了（看过日剧《黑色皮革手册》之类的朋友，肯定有心理准备）。</p><p>当然，借着酒劲占女孩子便宜的客人不是没有，但你得明白，这些店基本上跟当地的黑社会的关系是非常近的。我曾经亲眼见过被从店面后门拖出来，两眼像熊猫的客人。」</p><p>旨在打破那些去日本游玩的朋友在异国他乡发生一段奇妙旅程的幻想。</p><h3 id="新宿御苑"><a href="#新宿御苑" class="headerlink" title="新宿御苑"></a>新宿御苑</h3><p><img src="http://kirito.iocoder.cn/image-20190919224133917.png?imageMogr2/thumbnail/640x640/format/webp/blur/1x0/quality/75|imageslim" alt="言叶之庭"></p><p>新宿御苑是跨新宿与涩谷的一个庭园，也是新海诚的《言叶之庭》的灵感发源地。公园位于市中心，乘坐 JR 线在御苑前站下站，走两步就可以直接到达了，距离之前提到的购物圣地 <strong>LUMINE</strong> 也只有 10 分钟的步程。绿荫环绕的和式庭院与周围的摩天大楼形成绝妙的反差，非常适合高强度逛街过后来放松一下。</p><p><img src="http://kirito.iocoder.cn/image-20190919224152483.png?imageMogr2/thumbnail/640x640/format/webp/blur/1x0/quality/75|imageslim" alt="新宿御苑"></p><p>这里四季都有不一样的美，特别推荐在在樱花盛开的季节来赏樱。可惜的是，我冬天来了一次，夏天来了一次，都没能见到樱花盛开，</p><h3 id="须贺神社"><a href="#须贺神社" class="headerlink" title="须贺神社"></a>须贺神社</h3><p>日本人的宗教信仰主要以佛教和神道教为主，寺庙之于佛教相当于神社之于神道教。佛教自不必多介绍，神道教是什么来历呢？日本有八百万神明之说，上至神话传说中的神灵，中到历史上名人伟人，下至自然界的大小万物都会成为供奉的对象，每个神社主管的范围内都不一样。比如说稻荷神社是供奉主管农业和商业的稻荷诸神的（不是供奉狐狸的，狐狸是稻荷神的使者）；天满宫是供奉学问之神菅原道真的（这位是历史名人）；以神宫为名的通常都是供奉某位天皇或者皇室成员的；还有些比较有趣的，比如奈良的冰室神社，是管冷冻的，所以很多奉纳的都是制冷、冰库、冷藏物流的企业…</p><p>按照导游的介绍，区分神社和寺庙实际上非常简单，神社门口大多会有一个红色的鸟居，参拜的地方（拜殿）会有稻草编制的注连绳，进入神社前会有用于清洁的手水舍。</p><p><img src="http://kirito.iocoder.cn/image-20190919202846323.png?imageMogr2/thumbnail/640x640/format/webp/blur/1x0/quality/75|imageslim" alt="手水舍"></p><p>既然神社这么多，那么自然得推荐大家去看点有意义的神社，例如新海诚导演的《你的名字》就是以须贺神社作为的取经地。须贺神社可以乘坐 JR 线在六本木四丁目站下站之后步行不到 10 分钟就可到达，片中男主与女主最后见面的阶梯就位于须贺神社旁。</p><p><img src="http://kirito.iocoder.cn/image-20190919203443337.png" alt="你的名字取景地 - 阶梯"></p><p>当天玩的太晚，到达神社时已经是夜晚了，人烟也很稀少，相比繁华的东京，这里更加的幽静。喜欢动漫的读者可以将这里作为一个不错的打卡地点。片中还有不少景点，例如天桥取景自 JR 信浓町站旁边，港区的东京塔，涩谷区地标建筑 NTT DoCoMo 代代木大厦等等。</p><h3 id="国立新美术馆"><a href="#国立新美术馆" class="headerlink" title="国立新美术馆"></a>国立新美术馆</h3><p><img src="http://kirito.iocoder.cn/image-20190919204519056.png?imageMogr2/thumbnail/640x640/format/webp/blur/1x0/quality/75|imageslim" alt="你的名字取景地 - 美术馆"></p><p>同样是《你的名字》中的取景地，片中泷被三叶套路后，与奥寺前辈第一次约会时吃中餐时的咖啡店，位于六本木的国立新美术馆。这家美术馆是世界著名设计师同时也是日本建筑界三杰之一的黑川纪章所设计的最后一件作品，是现在日本楼板面积最大的美术馆，并且也拥有日本国内最大的展示空间。喜欢文艺范的游客可以考虑来此地观光。</p><p>一般参观美术馆以及很多的展览都是免费的，这次我们就参观了书法展以及画展。馆内除了艺术展览还有设餐厅、咖啡厅、以及博物馆商店。馆内的设计非常好看，两个倒锥体的设计很抢眼。</p><h3 id="温泉"><a href="#温泉" class="headerlink" title="温泉"></a>温泉</h3><p>这次跟团有一晚是在富士山脚下的温泉酒店住宿。说到富士山，这次实在是有点气，第一是因为这次的温泉酒店实在令人失望，其次是由于天气原因，没办法看到富士山的全貌，只能看到山脚。</p><p>泡温泉的最佳时间和地点我可以说是相当有感触，上次来日本最深刻的印象便是在冬天在北海道，那时候外面飘着鹅毛大雪，远处是高山，在一处露天温泉，头顶着一条毛巾，特别惬意。虽然是东京旅游攻略，但有了这次的对比，还是推荐大家有机会一定要在冬天去一次北海道，别有一番风味。</p><h2 id="日本见闻"><a href="#日本见闻" class="headerlink" title="日本见闻"></a>日本见闻</h2><h3 id="街道"><a href="#街道" class="headerlink" title="街道"></a>街道</h3><p>东京这个城市，抬头看到的是高楼大厦，低头看到的便是街道了，日本的街道很容易给来日本旅游的人以深刻的印象，因为太干净了。在街道上，很少看到垃圾桶，所以日本人会有随身携带垃圾袋的习惯。</p><p><img src="http://kirito.iocoder.cn/image-20190919224846451.png?imageMogr2/thumbnail/640x640/format/webp/blur/1x0/quality/75|imageslim" alt="池袋的街道"></p><p>除了干净还有一个印象便是安静，在车水马龙的街道上，几乎没有车辆会按喇叭，但我的旅途上发生了一个小插曲，导游刚介绍完日本的司机基本不会按喇叭，我们旅游大巴的喇叭就不争气的坏了，导致一路上总是会自己发出声响，打的一手好脸。</p><h3 id="楼梯"><a href="#楼梯" class="headerlink" title="楼梯"></a>楼梯</h3><p>在商场、地铁等会出现手扶梯的地方，可以看到一个独特的风景，虽然大多数楼梯都是双行道，但所有人都会靠左站立，把右侧留出来给急着赶路的人。</p><p>据导游介绍，关东的东京无论是楼梯、扶梯、街道通行都会习惯靠左，而关西的大阪则是与其相反 —— 靠右。</p><h3 id="吃喝"><a href="#吃喝" class="headerlink" title="吃喝"></a>吃喝</h3><p>日本的食物偏生冷，新鲜是新鲜，但是种类实在太少，相比之下，让我更加感慨中华美食的魅力。日本街头遍历都是拉面店、寿司店，当年看火影忍者时就对片中的一乐拉面饱含期待，在日本领略过当地的拉面后，并没有感到失望，日本拉面店会习惯配上冰水，这个让我感到一本满足。</p><p><img src="http://kirito.iocoder.cn/image-20190919213101731.png?imageMogr2/thumbnail/640x640/format/webp/blur/1x0/quality/75|imageslim" alt="胜牛"></p><p>要说日本远超预期的美食，非和牛饭莫属了，肉质非常鲜嫩，让人流连忘返。</p><p><img src="http://kirito.iocoder.cn/image-20190919223610888.png?imageMogr2/thumbnail/640x640/format/webp/blur/1x0/quality/75|imageslim" alt="居酒屋"></p><p>而傍晚直至深夜，居酒屋这样的场所会涌入一批批上班族，这是日本特有的文化，社长会带着社员一天会轮流去好几个居酒屋，含蓄的日本人只有借助酒意，才敢向领导吐露心声。</p><h3 id="穿着"><a href="#穿着" class="headerlink" title="穿着"></a>穿着</h3><p><img src="http://kirito.iocoder.cn/image-20190919214212949.png?imageMogr2/thumbnail/640x640/format/webp/blur/1x0/quality/75|imageslim" alt="浴衣"></p><p>在日本街头随处可见身着浴衣、脚蹬木屐的女子，日本人真的是把传统服饰融入到了生活之中。</p><p>除此之外，第一次来日本时同样是在东京街头，让我感到惊讶的是，日本的女孩子在寒冷的冬天依旧穿着短裙，上身则穿着毛衣。</p><h3 id="出行"><a href="#出行" class="headerlink" title="出行"></a>出行</h3><p>在之前 【APP 推荐】中介绍换乘案内时，就介绍了日本出行的主要方式了——电车。电车作为日本人最主要的出行方式，主要的原因是，打车实在是太贵了！比国内贵的多的多，所以国内能够随地打车真的是一件非常幸福的事情。日本的出租车司机很有范，个个西装笔挺的打扮，带着白手套；公交车司机给我留下的印象则是年纪偏大，日本是个老龄化严重的国家，所以这些老年人通常退休的时间也会比国内要晚。说道老龄化的对策，最近安倍政府刚推行了一项政策，在九年义务教育的基础上，推行了 3-5 岁幼儿教育费全免的政策，凡是日本国籍或者在日打工的外籍纳税人都可以享受这份政策，从而拯救佛系的日本青年们。</p><p><img src="http://kirito.iocoder.cn/image-20190919224617503.png?imageMogr2/thumbnail/640x640/format/webp/blur/1x0/quality/75|imageslim" alt="魅力的小姐姐"></p><p>乘坐电车时，除了之前提到的坐错车的问题，还需要有不少其他注意事项。日本人是一个秉承着尽量不去打扰别人理念的民族，所以在车厢内或者餐厅都尽量保持安静。在日本的地铁或者电车上有些会贴有将手机调成震动的提醒，大家可以注意一下。日本的电车设有女性车厢，以防止电车之狼，在限定时间段内男性最好还是不要去乘坐的好，要注意电车上贴的标志，不然一群女性投来的目光也会挺尴尬的。</p><h3 id="住宿"><a href="#住宿" class="headerlink" title="住宿"></a>住宿</h3><p>由于是旅行社负责了全部的住宿问题，所以没有太关注如何订房这件事。对于想要完全自由行的朋友，可以通过非常多的 app 来预定酒店以及机票，比如飞猪 / 携程 / 途牛等等。</p><p>日本的住宿费用相对是国内一线城市的水准，并不便宜。想要省钱的话，可以选择民宿，一些性价比高的酒店则需要提前很早预定。有一些住宿的地方会提供榻榻米，不过个人不太感冒，睡地板实在不太习惯。住宿 check out 的时候要注意退宿须知，有的地方会有叠好被单、整理褥子之类的要求，特别是民宿需要格外留意。</p><h2 id="尾记"><a href="#尾记" class="headerlink" title="尾记"></a>尾记</h2><p>以上就是本次东京游玩的全部攻略啦，其实自己对日本也不是特别了解，只能凭借零散的记忆组织起来这篇攻略，期间也参考了不少大牛的攻略文章，想要了解更多攻略的同学可以在 B 站搜搜看相关的视频，很多有用的建议，国庆也快到了，祝有个愉快的旅程 ~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于表弟是个狂热的二次元爱好者，受我小姨之托，带他去日本游玩了一趟。趁着这个机会，打算给大家分享一下日本旅游的一些攻略，以祭奠我逝去的年假。这是我第二次去日本了，上一次还是大二时跟我初中舍友一起去的，所以这次去已经有了一些经验了，很多朋友表示想去日本，期待我能写一篇攻略，所以这篇攻略将会偏小白向，如果你是第一次去日本，那这篇攻略想必不会让你失望。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://lexburner.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="日本旅游攻略" scheme="http://lexburner.github.io/tags/%E6%97%A5%E6%9C%AC%E6%97%85%E6%B8%B8%E6%94%BB%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo 中的 http 协议</title>
    <link href="http://lexburner.github.io/dubbo-http-protocol/"/>
    <id>http://lexburner.github.io/dubbo-http-protocol/</id>
    <published>2019-07-16T11:13:06.000Z</published>
    <updated>2019-09-26T09:45:30.214Z</updated>
    
    <content type="html"><![CDATA[<p>太阳红彤彤，花儿五颜六色，各位读者朋友好，又来到了分享 Dubbo 知识点的时候了。说到 Dubbo 框架支持的协议，你的第一反应是什么？大概会有 Dubbo 默认支持的 dubbo 协议，以及老生常谈的由当当贡献给 Dubbo 的     rest 协议，或者是今天的主角 http。截止到目前，Dubbo 最新版本演进到了 2.7.3，已经支持了：dubbo，hessain，http，injvm，jsonrpc，memcached，native-thrift，thrift，redis，rest，rmi，webservice，xml 等协议，有些协议的使用方式还没有补全到官方文档中。原来 Dubbo 支持这么多协议，是不是有点出乎你的意料呢？</p><p>这么多 RPC 协议，可能有人会产生如下的疑问：rest，jsonrpc，webservice 不都是依靠 http 通信吗？为什么还单独有一个 http 协议？先不急着回答这个问题，而是引出今天的话题，先来介绍下 Dubbo 框架中所谓的 http 协议。</p><a id="more"></a><h2 id="Dubbo-中的-http-协议"><a href="#Dubbo-中的-http-协议" class="headerlink" title="Dubbo 中的 http 协议"></a>Dubbo 中的 http 协议</h2><p>在 Dubbo 使用 http 协议和其他协议基本一样，只需要指定 protocol 即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"http"</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">server</span>=<span class="string">"jetty"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>server 属性可选值：jetty，tomcat，servlet。</p><p>配置过后，当服务消费者向服务提供者发起调用，底层便会使用标准的 http 协议进行通信。可以直接在 <a href="https://github.com/apache/dubbo-samples" target="_blank" rel="noopener">https://github.com/apache/dubbo-samples</a> 中找到官方示例，其中的子模块：dubbo-samples-http 构建了一个 http 协议调用的例子。</p><blockquote><p>为避免大家误解，特在此声明：本文中，所有的 http 协议特指的是 dubbo 中的 http 协议，并非那个大家耳熟能详的通用的 http 协议。</p></blockquote><h2 id="http-协议的底层原理"><a href="#http-协议的底层原理" class="headerlink" title="http 协议的底层原理"></a>http 协议的底层原理</h2><p>从默认的 dubbo 协议改为 http 协议是非常简单的一件事，上面便是使用者视角所看到的全部的内容了，接下来我们将会探讨其底层实现原理。</p><p>翻看 Dubbo 的源码，找到 HttpProtocol 的实现，你可能会吃惊，基本就依靠 HttpProtocol 一个类，就实现了 http 协议</p><p><img src="http://kirito.iocoder.cn/image-20190717185724385.png" alt="image-20190717185724385"></p><p>要知道实现自定义的 dubbo 协议，有近 30 个类！http 协议实现的如此简单，背后主要原因有两点：</p><ol><li>remoting 层使用 http 通信，不需要自定义编解码</li><li>借助了 Spring 提供的 HttpInvoker 封装了 refer 和 exporter 的逻辑</li></ol><p>Spring 提供的 HttpInvoker 是何方神圣呢？的确是一个比较生僻的概念，但并不复杂，简单来说，就是使用 Java 序列化将对象转换成字节，通过 http 发送出去，在 server 端，Spring 能根据 url 映射，找到容器中对应的 Bean 反射调用的过程，没见识过它也不要紧，可以通过下面的示例快速掌握这一概念。</p><h2 id="Spring-HttpInvoker"><a href="#Spring-HttpInvoker" class="headerlink" title="Spring HttpInvoker"></a>Spring HttpInvoker</h2><blockquote><p>本节内容可参见 Spring 文档：<a href="https://docs.spring.io/spring/docs/4.3.24.RELEASE/spring-framework-reference/htmlsingle/#remoting-httpinvoker-server" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/4.3.24.RELEASE/spring-framework-reference/htmlsingle/#remoting-httpinvoker-server</a></p></blockquote><p>下面的示例将会展示如何使用 Spring 原生的 HttpInvoker 实现远程调用。</p><h3 id="创建服务提供者"><a href="#创建服务提供者" class="headerlink" title="创建服务提供者"></a>创建服务提供者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">new</span> Account(id, <span class="keyword">new</span> Date().toString());</span><br><span class="line">        <span class="keyword">return</span> account;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">AccountService <span class="title">accountService</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AccountServiceImpl();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span>(<span class="string">"/AccountService"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpInvokerServiceExporter <span class="title">accountServiceExporter</span><span class="params">(AccountService accountService)</span></span>&#123;</span><br><span class="line">    HttpInvokerServiceExporter exporter = <span class="keyword">new</span> HttpInvokerServiceExporter();</span><br><span class="line">    exporter.setService(accountService);</span><br><span class="line">    exporter.setServiceInterface(AccountService.class);</span><br><span class="line">    <span class="keyword">return</span> exporter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暴露服务的代码相当简单，需要注意两点：</p><ol><li><code>org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter</code> 是 Spring 封装的一个服务暴露器，它会以 serviceInterface 为公共接口，以 service 为实现类向外提供服务。</li><li>@Bean(“/AccountService”) 不仅仅指定了 IOC 容器中 bean 的名字，还充当了路径映射的功能，如果本地服务器暴露在 8080 端口，则示例服务的访问路径为 <code>http://localhost:8080/AccountService</code></li></ol><h3 id="创建服务消费者"><a href="#创建服务消费者" class="headerlink" title="创建服务消费者"></a>创建服务消费者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpProxyConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"accountServiceProxy"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpInvokerProxyFactoryBean <span class="title">accountServiceProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HttpInvokerProxyFactoryBean accountService = <span class="keyword">new</span> HttpInvokerProxyFactoryBean();</span><br><span class="line">        accountService.setServiceInterface(AccountService.class);</span><br><span class="line">        accountService.setServiceUrl(<span class="string">"http://localhost:8080/AccountService"</span>);</span><br><span class="line">        <span class="keyword">return</span> accountService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClientApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext applicationContext = SpringApplication.run(HttpClientApp.class, args);</span><br><span class="line">        AccountService accountService = applicationContext.getBean(AccountService.class);</span><br><span class="line">        System.out.println(accountService.findById(<span class="number">10086</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者端引用服务同样有两个注意点：</p><ol><li><code>org.springframework.remoting.httpinvoker.HttpInvokerProxyFactoryBean</code>  是 Spring 封装的一个服务引用器，serviceInterface 指定了生成代理的接口，serviceUrl 指定了服务所在的地址，与之前配置的服务暴露者的路径需要对应。</li><li>HttpInvokerProxyFactoryBean 注册到容器之中时，会同时生成一个 AccountService 接口的代理类，由 Spring 封装远程调用的逻辑。</li></ol><h3 id="调用细节分析"><a href="#调用细节分析" class="headerlink" title="调用细节分析"></a>调用细节分析</h3><p>对于 Spring HttpInvoker 的底层实现，就没必要深究了，但大家肯定还是会好奇一些细节：dubbo 中的 http 报文体是怎么组织的？如何序列化对象的？</p><p>我们使用 wireshark 可以抓取到客户端发送的请求以及服务端响应的报文。</p><p><img src="http://kirito.iocoder.cn/image-20190717193241396.png" alt="image-20190717193241396"></p><p>追踪报文流，可以看到详细的请求和响应内容</p><p><img src="http://kirito.iocoder.cn/image-20190717193339739.png" alt="image-20190717193339739"></p><p>从 <code>ContentType: application/x-java-serialized-object</code> 和报文 Body 部分的 ASCII 码可以看出，使用的是 Java Serialize 序列化。我们将 Body 部分导出成文件，使用 Java Serialize 反序列化响应，来验证一下它的庐山真面目：</p><p><img src="http://kirito.iocoder.cn/image-20190717194908741.png" alt="image-20190717194908741"></p><p>使用 Java Serialize 可以正常反序列化报文，得到结果是 Spring 内置的包装类 RemoteInvocationResult，里面装饰着实际的业务返回结果。</p><h2 id="http-协议的意义"><a href="#http-协议的意义" class="headerlink" title="http 协议的意义"></a>http 协议的意义</h2><p>Dubbo 提供的众多协议有各自适用的场景，例如</p><ul><li>dubbo://，dubbo 协议是默认的协议，自定义二进制协议；单个长连接节省资源；基于 tcp，架构于 netty 之上，性能还算可以；协议设计上没有足够的前瞻性，不适合做 service-mesh 谈不上多么优雅，但是好歹风风雨雨用了这么多年，周边也有不少配套组件例如 dubbo2.js, dubbo-go, dubbo-cpp，一定程度解决了多语言的问题。</li><li>webservice://,hession://,thrift:// 等协议，基本是为了适配已有协议的服务端 / 客户端，借助于 dubbo 框架的 api，可以使用其功能特性，意义不是特别大。</li><li>redis://,memcached:// 等协议，并非是暴露给用户配置的协议，一般是 dubbo 自用，在注册中心模块中会使用到相应的扩展</li></ul><p>所有协议的具体使用场景和其特性，我可能会单独写文章来分析，而如今我们要思考的是 dubbo 提供 http 协议到底解决什么问题，什么场景下用户会考虑使用 dubbo 的 http 协议。</p><p>我个人认为 dubbo 现如今的 http 协议比较鸡肋，原生 http 通信的优势在于其通用性，基本所有语言都有配套的 http 客户端和服务端支持，但是 dubbo 的 http 协议却使用了 <code>application/x-java-serialized-object</code> 的格式来做为默认的 payload，使得其丧失了跨语言的优势。可能有读者会反驳：HttpInvoker 支持配置序列化格式，不能这么草率的诟病它。但其实我们所关注的恰恰是默认实现，正如 dubbo:// 协议也可以配置 fastjson 作为序列化方案，但是我们同样不认为 dubbo:// 协议是一个优秀的跨语言方案，理由是一样的。当然，评价一个应用层协议是否是优秀的，是否适合做 mesh 等等，需要多种方向去分析，这些我不在本文去分析。</p><p>说到底，本文花了一定的篇幅向大家介绍了 dubbo 的 http 协议，到头来却是想告诉你：这是一个比较鸡肋的协议，是不是有些失望呢？不要失望，dubbo 可能在 2.7.4 版本废弃现有的 http 协议，转而使用 jsonrpc 协议替代，其实也就是将 jsonrpc 协议换了个名字而已，而关于 jsonrpc 的细节，我将会在下一篇文章中介绍，届时，我也会分析，为什么 jsonrpc 比现有的 http 协议更适合戴上 http 协议的帽子，至于现有的 http 协议，我更倾向于称之为：spring-httpinvoker 协议。</p><p>总结，dubbo 现有 http 协议的意义是什么？如果你习惯于使用 Spring HttpInvoker，那或许现有的 http 协议还有一定的用处，但从 dubbo 交流群和 Spring 文档介绍其所花费的篇幅来看，它还是非常小众的。同时也可以让我们更好地认识协议发展的历史，知道一个协议为什么存在，为什么会被淘汰。</p><p>当然，我说了不算，最终还是要看 dubbo 社区的决策，如果你对这个迁移方案感兴趣，想要参与讨论，欢迎大家在 dubbo 社区的邮件列表中发表你的见解</p><p>Topic：[Proposal] replace the protocol=”http” with protocol=”jsonrpc”</p><p><strong> 欢迎关注我的微信公众号：「Kirito 的技术分享」，关于文章的任何疑问都会得到回复，带来更多 Java 相关的技术分享。</strong></p><p><img src="http://kirito.iocoder.cn/qrcode_for_gh_c06057be7960_258%20%281%29.jpg" alt="关注微信公众号"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;太阳红彤彤，花儿五颜六色，各位读者朋友好，又来到了分享 Dubbo 知识点的时候了。说到 Dubbo 框架支持的协议，你的第一反应是什么？大概会有 Dubbo 默认支持的 dubbo 协议，以及老生常谈的由当当贡献给 Dubbo 的     rest 协议，或者是今天的主角 http。截止到目前，Dubbo 最新版本演进到了 2.7.3，已经支持了：dubbo，hessain，http，injvm，jsonrpc，memcached，native-thrift，thrift，redis，rest，rmi，webservice，xml 等协议，有些协议的使用方式还没有补全到官方文档中。原来 Dubbo 支持这么多协议，是不是有点出乎你的意料呢？&lt;/p&gt;
&lt;p&gt;这么多 RPC 协议，可能有人会产生如下的疑问：rest，jsonrpc，webservice 不都是依靠 http 通信吗？为什么还单独有一个 http 协议？先不急着回答这个问题，而是引出今天的话题，先来介绍下 Dubbo 框架中所谓的 http 协议。&lt;/p&gt;
    
    </summary>
    
      <category term="RPC" scheme="http://lexburner.github.io/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="http://lexburner.github.io/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>IDEA 插件推荐：Cloud Toolkit 测评</title>
    <link href="http://lexburner.github.io/cloud-toolkit-benchmark/"/>
    <id>http://lexburner.github.io/cloud-toolkit-benchmark/</id>
    <published>2019-06-27T11:19:41.000Z</published>
    <updated>2019-09-26T09:45:31.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="产品介绍"><a href="#产品介绍" class="headerlink" title="产品介绍"></a>产品介绍</h2><p><a href="https://cn.aliyun.com/product/cloudtoolkit" target="_blank" rel="noopener">Cloud Toolkit</a> 是一款 IDE 插件，帮助开发者更高效地开发、测试、诊断并部署应用。开发者能够方便地将本地应用一键部署到任意机器，或 ECS、EDAS、Kubernetes；并内置 Arthas 诊断、高效执行终端命令和 SQL 等。</p><p>对这款产品最直观的感受：这是一款发布工具，帮助用户在 IDE 中直接打包应用并部署到各种终端。原本看到其产品介绍位于阿里云的页面中，以为是一款和阿里云服务强绑定的产品，但试用过后发现，即使对于普通的云主机，其也非常适用，可以解决很多开发运维的痛点，非阿里云用户可以放心使用。</p><a id="more"></a><h2 id="在-Cloud-Toolkit-出现之前"><a href="#在-Cloud-Toolkit-出现之前" class="headerlink" title="在 Cloud Toolkit 出现之前"></a>在 Cloud Toolkit 出现之前</h2><p>作为一个 Java 程序员，我们现在大多数都会在 Intellij IDEA 中基于 SpringBoot 来开发 WEB 应用，所以本文中的测评将会基于如下架构</p><ul><li>开发环境：IDEA</li><li>项目组织方式：Maven</li><li>开发框架：SpringBoot</li></ul><p>来构建。在接触 Cloud Toolkit 之前，可以怎么部署一个 SpringBoot 应用呢？作为一个偏正经的测评人员，我不会为了凸显出 Cloud Toolkit 的强大而去翻出一些上古的部署工具来做对比，而是直接使用 Intellij IDEA 的内置功能与之对比。</p><h3 id="第一步：配置服务器信息"><a href="#第一步：配置服务器信息" class="headerlink" title="第一步：配置服务器信息"></a>第一步：配置服务器信息</h3><p>在 <code>Tools -&gt; Deployment</code> 中可以找到 IDEA 对项目部署支持的内置插件</p><p><img src="http://kirito.iocoder.cn/image-20190602181059808.png" alt="Deployment 插件"></p><p>我们可以在其中进行服务器信息的配置，包括服务器地址和权限认证，并且在 Mapping 选项卡中完成本地工程与服务器路径的映射。</p><h3 id="第二步：配置-Maven-打包插件"><a href="#第二步：配置-Maven-打包插件" class="headerlink" title="第二步：配置 Maven 打包插件"></a>第二步：配置 Maven 打包插件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于是 SpringBoot 应用，配置专用的打包插件后，可以将整个工程打成一个 fatjar，示例工程非常简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello world~~~~~~~~~~~~~~~~"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后，只要执行 install，即可得到一个可运行的 jar 包：</p><p><img src="http://kirito.iocoder.cn/image-20190602181758619.png" alt="打包"></p><h3 id="第三步：部署-jar-包"><a href="#第三步：部署-jar-包" class="headerlink" title="第三步：部署 jar 包"></a>第三步：部署 jar 包</h3><p><img src="http://kirito.iocoder.cn/image-20190602181934176.png" alt="部署"></p><p>由于我们在第一步已经配置过项目路径与服务器路径的映射，可以选择直接对 fatjar 右键，upload 到远程服务器上。</p><h3 id="第四步：启动应用"><a href="#第四步：启动应用" class="headerlink" title="第四步：启动应用"></a>第四步：启动应用</h3><p><img src="http://kirito.iocoder.cn/image-20190602182411907.png" alt="启动"></p><p>上图中展示的是 IDEA 中两个非常棒的内置功能，可以在 <code>Tools -&gt; Start SSH session</code> 中开启远程服务器的终端，在 IDEA 下方可以执行远程指令；也可以在 <code>Tools -&gt; Deployment -&gt;Browse Remote Host</code> 中展开如图右侧的结构，可视化地浏览服务器上的文件列表，检查应用是否部署成功。</p><p>在远程终端中，找到对应的 fatjar，执行 <code>java -jar spring-demo-1.0-SNAPSHOT.jar</code> 便完成了整个部署流程。</p><h3 id="IDEA-内置插件总结"><a href="#IDEA-内置插件总结" class="headerlink" title="IDEA 内置插件总结"></a>IDEA 内置插件总结</h3><p>IDEA 内置插件已经提供了相当强大的能力，整个部署过程我们完全没有离开 IDEA！避免了频繁切换窗口，装各种部署工具，可以说已经很方便了，Cloud Toolkit 必须要比这个部署过程做的更加强大才行，那下面就让我们来体验下 Cloud Toolkit 是怎么优化的吧。</p><h2 id="Cloud-Toolkit-初体验"><a href="#Cloud-Toolkit-初体验" class="headerlink" title="Cloud Toolkit 初体验"></a>Cloud Toolkit 初体验</h2><p>我们不急着用 Cloud Toolkit 来部署应用。虽然笔者是一位开发，但还是从产品的角度来研究下它的菜单项，看看它的产品定位。IDEA 安装插件的过程省略，详情可以参考 <a href="https://yq.aliyun.com/articles/674021" target="_blank" rel="noopener">《Intellij IDEA 安装 Cloud Toolkit 教程》</a>。</p><p><img src="http://kirito.iocoder.cn/image-20190602183827891.png" alt="多种部署方式"></p><p>其他菜单项暂且抛到一边，这 5 个核心能力应该就是 Cloud Toolkit 的核心了。</p><p>即使作为一个插件小白，应该也能够望名知意，猜到这几个菜单对应的功能：</p><ul><li>Deploy to Host：部署到任意服务器。这一个功能决定了 Cloud Toolkit 强大的功能可以使得每个开发者受益，它其实并不是和阿里云厂商强绑定的。在下文也会重点测评下这个功能。</li><li>Deploy to ECS：这里的 ECS 指的阿里云的 ECS，如果你的服务部署在阿里云 ECS 上，可以选择使用这个功能，获得比 Deploy to Host 更加丰富的功能。在下文我也会简单测评下这个功能。</li><li>Deploy to EDAS，Deploy to EDAS Serverless：EDAS &amp; EDAS Serverless 是阿里云上提供的分布式服务治理服务，可以理解为商业版的 Dubbo，具有强大的服务治理、服务调度能力，Cloud Toolkit 对 EDAS 做了个性化的部署支持，使得使用者无需登录控制台，在 IDEA 中即可完成 EDAS 的部署。</li><li>Deploy to CS K8S：云原生时代很多应用使用容器化的方式进行部署，Cloud Toolkit 这一点做的还是不错的，已经具备了容器化部署的能力，具有一定的前瞻性。</li></ul><p>其实从简单的功能介绍就可以看出，Cloud Toolkit 相比 IDEA 内置的部署能力的确是高出一大截了，甚至可以说，Deploy to Host 这一能力完全就可以覆盖 IDEA 插件的所有能力，并且对流程还进行了一些简化。下面我重点测评下 Deploy to Host 这一能力，与之前的部署流程进行一个对比。</p><h2 id="使用-Cloud-Toolkit-部署应用到任意服务器"><a href="#使用-Cloud-Toolkit-部署应用到任意服务器" class="headerlink" title="使用 Cloud Toolkit 部署应用到任意服务器"></a>使用 Cloud Toolkit 部署应用到任意服务器</h2><p><img src="http://kirito.iocoder.cn/image-20190602185551351.png" alt="Deploy to Host"></p><p>上图展示的 Deploy to Host 功能的配置项，实际上涵盖了</p><ul><li>远程服务器配置</li><li>部署方式：Maven 构建，直接上传文件（目前还不支持 Gradle 构建，可能在后续的版本会支持）</li><li>本地文件与服务器路径的映射配置</li><li>启动脚本的集成</li></ul><h3 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h3><p>SSH 登录账户可以在 <code>Preferences -&gt; Alibaba Cloud Toolkit -&gt; SSH Profile</code> 中管理，找不到也没关系，需要设置的时候一般都会有超链接跳转，这点做得很人性化。</p><p><img src="http://kirito.iocoder.cn/image-20190602190651881.png" alt="SSH 账号管理"></p><h3 id="主机管理"><a href="#主机管理" class="headerlink" title="主机管理"></a>主机管理</h3><p>服务信息可以在 <code>Tools -&gt; Alibaba Cloud -&gt;Alibaba Cloud View</code> 中展开，如下图所示</p><p><img src="http://kirito.iocoder.cn/image-20190602191159882.png" alt="image-20190602191159882"></p><h3 id="Deploy-to-Host"><a href="#Deploy-to-Host" class="headerlink" title="Deploy to Host"></a>Deploy to Host</h3><p>配置完账号信息和主机信息，然后只需要右键项目选择 <code>Alibaba Cloud -&gt; Deploy to Host-&gt; Run</code>  ，一切就搞定了。这个过程相比之前变得非常简易</p><ul><li>不需要自己打包。Cloud Toolkit 集成了 Maven 插件。</li><li>不需要登录远程终端去执行脚本启动服务。Cloud Toolkit 提供了应用部署生命周期必要的钩子，只需要设置好启动脚本即可。</li><li>修改完本地代码，点击下 Deploy to Host，即可完成改动代码的部署。</li></ul><p>经过如上的测评过程，相信即使没有使用过 Cloud Toolkit 的用户，也可以直观体会到这是怎么样一款插件了，并且它的功能是多么的实用。</p><h2 id="使用-Cloud-Toolkit-部署应用到-ECS"><a href="#使用-Cloud-Toolkit-部署应用到-ECS" class="headerlink" title="使用 Cloud Toolkit 部署应用到 ECS"></a>使用 Cloud Toolkit 部署应用到 ECS</h2><p>从产品设计的角度来分析，Cloud Toolkit 提供如此众多的部署能力，可以想到是其直接预设了使用人群。例如一个阿里云的 ECS 用户，在选择部署方式时，既可以使用 Deploy to Host 也可以使用 Deploy to ECS；例如一个 EDAS 用户，在选择部署方式时，既可以使用 Deploy to Host、Deploy to ECS，也可以使用 Deploy to EDAS（EDAS 可以理解为一个定制化的 ECS）。从产品的角度，越定制化的功能服务的人群越少，同时功能更强大；从用户体验的角度，其实也透露了云服务的一个特点，云厂商正在为其所提供的云服务提供更好的用户体验，借助于此类插件，可以降低使用者的开发运维门槛。</p><p>可以预见的一件事是，对于非阿里云用户来说，Deploy to Host 是使用 Cloud Toolkit 最大的诱惑了。作为一个测评文章，除了 Deploy to Host 之外，我还选择了 Deploy to ECS 这一功能来进行测评。为此我购买了一台阿里云的 ECS 来部署与上文相同的应用。</p><p><img src="http://kirito.iocoder.cn/image-20190602194148035.png" alt="Accounts"></p><p>在阿里云控制台可以获取到账号的 Access Key/Access Key Secret，在 IDEA 中的 <code>Preferences -&gt; Alibaba Cloud Toolkit -&gt; Accounts</code> 中可以设置账号。</p><p>在账号设置完毕后，Cloud Toolkit 看起来是通过内置的 API 直接关联到了我的 ECS 实例，在选择部署时，可以直接根据 region 选择实例列表中的机器进行部署。</p><p><img src="http://kirito.iocoder.cn/image-20190602194439453.png" alt="实例列表"></p><p>其余的部署流程和 Deploy to Host 相差无几。也就是说，Deploy to ECS 更多的其实完成了权限管理和主机管理，ECS 用户使用这个功能就显得非常高效了。</p><h2 id="Cloud-Toolkit-的亮点功能"><a href="#Cloud-Toolkit-的亮点功能" class="headerlink" title="Cloud Toolkit 的亮点功能"></a>Cloud Toolkit 的亮点功能</h2><p>Cloud Toolkit 除了主打的部署能力，还提供了不少亮点功能，我选择了其中的 3 个功能：上传文件，远程 Terminal，内置应用诊断功能来进行评测。</p><h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><p><img src="http://kirito.iocoder.cn/image-20190604201842718.png" alt="upload"></p><p>有些脚本我们希望在本地编辑之后上传到服务器上，Cloud Toolkit 对每一个主机都提供了一个 Upload 操作，可以将本地的文件上传到远程主机上，并且还可以触发一个 commond，这个功能也是很人性化的，因为上传脚本后，往往需要运行一次，避免了我们再登录到远程主机上执行一次运行操作。</p><h3 id="远程-Terminal"><a href="#远程-Terminal" class="headerlink" title="远程 Terminal"></a>远程 Terminal</h3><p>特别是在 Mac 中，我一直苦恼的一件事便是如何管理众多的远程机器，我需要偶尔去搭建了博客的主机上查看下个人博客为什么挂了，偶尔又要去看看我的 VPN 主机排查下为什么无法转发流量了，在开发测试阶段，又要经常去测试主机上简单的执行一些命令。所有这一切通过 ssh 工具去完成都不麻烦，但所有的麻烦事集合到一起时往往会让我变得焦头烂额，这一点，Cloud Toolkit 简直是一个 Life Saver。</p><p><img src="http://kirito.iocoder.cn/image-20190604201228263.png" alt="image-20190604201228263"></p><p>事实上，在前面的测评中我们已经了解到 IDEA 内置了远程 Terminal 这个功能，Cloud Toolkit 是进一步优化了它的体验，用户可以直接在可视化的页面选择想要远程登录的主机，在对主机加了 Tag 之后，这个过程会更加直观。</p><h3 id="内置应用诊断功能"><a href="#内置应用诊断功能" class="headerlink" title="内置应用诊断功能"></a>内置应用诊断功能</h3><p>在测评体验过程中，意外地发现了 Cloud Toolkit 的一个功能支持，就是前面的截图有显示，但我未提到的 Diagnostic （诊断）功能。Cloud Toolkit 集成了阿里巴巴开源的一款应用诊断框架 – <a href="https://alibaba.github.io/arthas/" target="_blank" rel="noopener">Arthas</a>。</p><ul><li>对于本地主机，可以直接通过 <code>Tools -&gt; Alibaba Cloud -&gt; Diagnostic Tools</code> 开启诊断。</li><li>对于远程主机，可以通过主机管理中的 Diagnostic 选项卡，开启远程诊断。</li></ul><p><img src="http://kirito.iocoder.cn/image-20190602195455602.png" alt="远程诊断"></p><p>在过去，我们想要进行诊断，必须要手动在服务器上安装 Arthas，Cloud Toolkit 借助于 Remote Terminal 和 Arthas 的集成，让这一切都可以在 IDEA 中完成，似乎是想要贯彻：彻底杜绝第三方工具，一切都用插件完成。</p><p>当你遇到以下类似问题而束手无策时，<code>Arthas</code> 可以帮助你解决：</p><ol><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到 JVM 的实时运行状态？</li></ol><p>作为一个偏正经的评测，我们试用一下远程诊断的功能，选取比较直观的 trace 命令来进行评测</p><p><img src="http://kirito.iocoder.cn/image-20190604194749595.png" alt="慢应用"></p><p>如上图所示，我们构造了一个慢请求，其中 invokeServiceA_B() 相对于其他方法十分耗时，我们希望通过 Cloud Toolkit 定位到慢调用的源头，找出 invokeServiceA_B 这个罪魁祸首。</p><p><img src="http://kirito.iocoder.cn/image-20190602200009029.png" alt="arthas"></p><p>点击 IDEA 中对应部署服务器的 Diagnostic 菜单项，就会出现如上图所示的一个 Arthas 诊断页面，它会自动关联到用户的 Java 进程，用户只需要选择相应诊断的进程即可。</p><p><img src="http://kirito.iocoder.cn/image-20190604200009328.png" alt="image-20190604200009328"></p><p>在关联到相应的进程之后，我们执行 trace 指令 </p><p><code>trace moe.cnkirito.demo.Application * -j</code></p><p>这个指令的含义是当 <code>moe.cnkirito.demo.Application</code> 中的任意方法被触发调用后，会打印出相应的调用栈，并计算耗时，<code>-j</code> 的含义是过滤掉 JDK 内置的类，简化堆栈。正如上图所示，我们定位到是 invokeServiceA 的 invokeServiceA_B 最为耗时。用户可以自行监控对应的方法，把 * 替换为想要监控的方式即可。更多的监控指令可以参考：<a href="https://alibaba.github.io/arthas/" target="_blank" rel="noopener">Arthas 文档</a></p><h2 id="测评中发现的不足"><a href="#测评中发现的不足" class="headerlink" title="测评中发现的不足"></a>测评中发现的不足</h2><p>是软件就必然有 bug，或者是用户体验不好的地方，花费了一个下午进行测评，简单罗列下我认为的缺陷。</p><h3 id="远程连接容易出现异常"><a href="#远程连接容易出现异常" class="headerlink" title="远程连接容易出现异常"></a>远程连接容易出现异常</h3><p>这个问题不是特别容易复现，表现是长时间运行项目后，再部署，会提示远程连接失败，在重启 IDEA 之后可以解决这个问题，原因未知。在后面想要复现时一直无法复现，但的确耗费了我很长的时间，不知道有没有其他的用户遇到同样的问题。</p><h3 id="文件浏览器过于简陋"><a href="#文件浏览器过于简陋" class="headerlink" title="文件浏览器过于简陋"></a>文件浏览器过于简陋</h3><p><img src="http://kirito.iocoder.cn/image-20190602200447655.png" alt="ssh"></p><p>当尝试配置 SSH 公私钥以实现免密登录时，发现 Browse 打开的文件浏览器无法正常显示 Mac 中的 .ssh 隐藏文件夹，大多数情况下用户会将 SSH 公私钥存放在 ~/.ssh 中，这个用户体验不是很好，或许有办法在这个文件浏览器中访问到隐藏文件夹，但至少我还没找到方法。</p><h3 id="缺少远程主机的可视化功能"><a href="#缺少远程主机的可视化功能" class="headerlink" title="缺少远程主机的可视化功能"></a>缺少远程主机的可视化功能</h3><p>IDEA 的默认插件支持 Remote Host</p><p><img src="http://kirito.iocoder.cn/image-20190602200927981.png" alt="Remote Host"></p><p>这个可以提升用户体验，Cloud Toolkit 提供了远程主机的管理，额外实现一个 ftp 协议可能会更方便用户查看自己的部署结果。从连接协议的选择上也可以发现，Cloud Toolkit 目前只支持 sftp 协议，而 IDEA 内置的 Deployment 插件还支持 ftp、ftps 等方式。</p><h2 id="产品定位-amp-评价-amp-竞品"><a href="#产品定位-amp-评价-amp-竞品" class="headerlink" title="产品定位 &amp; 评价 &amp; 竞品"></a>产品定位 &amp; 评价 &amp; 竞品</h2><p>其实本文基本是围绕 IDEA 的内置 Deployment 顺带着 Cloud Toolkit 的测评一起进行的。实际上我并不觉得 Cloud Toolkit 存在什么竞品</p><p>xftp 或者 xshell 吗？它们只是一款 ssh 工具罢了，人家压根没想着跟你竞争。</p><p>jenkins 吗？jenkins 有自己的 devops 流程，侧重在持续集成，而 Cloud Toolkit 定位是在日常开发中完成部署验证等行为。</p><p>在我的测评过程中，能够感受到这款产品的匠心，几乎为所有用户可能遇到的问题都做配备了文档：不知道启动脚本怎么写？链接了常用的 Java 应用启动脚本；不清楚该使用哪种部署方式？每种方式都有完整的部署文档；多语言？同时提供了 Go、NodeJS 的部署案例…</p><p>同时还支持了一些赠品功能：查看实时日志，文件上传，SQL 执行等。</p><p>以个人愚见，聊聊这款产品的定位，一方面是云厂商无关的特性，Cloud Toolkit 提供了 Deploy to Host、内置 Arthas 诊断等功能，造福了广大的开发者，另一方面是阿里云服务绑定的一些功能，Cloud Toolkit 为 ECS、EDAS 用户带来了福音，可以享受比普通应用部署更加便捷的操作。前者为 Cloud Toolkit 积累了业界口碑，后者为阿里云付费用户增加了信心，同时也为潜在的阿里云用户埋下了种子。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;产品介绍&quot;&gt;&lt;a href=&quot;#产品介绍&quot; class=&quot;headerlink&quot; title=&quot;产品介绍&quot;&gt;&lt;/a&gt;产品介绍&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://cn.aliyun.com/product/cloudtoolkit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cloud Toolkit&lt;/a&gt; 是一款 IDE 插件，帮助开发者更高效地开发、测试、诊断并部署应用。开发者能够方便地将本地应用一键部署到任意机器，或 ECS、EDAS、Kubernetes；并内置 Arthas 诊断、高效执行终端命令和 SQL 等。&lt;/p&gt;
&lt;p&gt;对这款产品最直观的感受：这是一款发布工具，帮助用户在 IDE 中直接打包应用并部署到各种终端。原本看到其产品介绍位于阿里云的页面中，以为是一款和阿里云服务强绑定的产品，但试用过后发现，即使对于普通的云主机，其也非常适用，可以解决很多开发运维的痛点，非阿里云用户可以放心使用。&lt;/p&gt;
    
    </summary>
    
      <category term="技术杂谈" scheme="http://lexburner.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="Cloud Toolkit" scheme="http://lexburner.github.io/tags/Cloud-Toolkit/"/>
    
  </entry>
  
  <entry>
    <title>研究网卡地址注册时的一点思考</title>
    <link href="http://lexburner.github.io/network-interfaces/"/>
    <id>http://lexburner.github.io/network-interfaces/</id>
    <published>2019-04-29T11:09:53.000Z</published>
    <updated>2019-09-26T09:45:29.822Z</updated>
    
    <content type="html"><![CDATA[<p>我曾经写过一篇和本文标题类似的文章《研究优雅停机时的一点思考》，上文和本文都有一个共同点：网卡地址注册和优雅停机都是一个很小的知识点，但是背后牵扯到的知识点却是庞大的体系，我在写这类文章前基本也和大多数读者一样，处于“知道有这么个东西，但不了解细节”的阶段，但一旦深挖，会感受到其中的奇妙，并有机会接触到很多平时不太关注的知识点。</p><p>另外，我还想介绍一个叫做”元阅读“的技巧，可能这个词是我自己造的，也有人称之为”超视角阅读“。其内涵指的是，普通读者从我的文章中学到的是某个知识点，而元阅读者从我的文章中可能会额外关注，我是如何掌握某个知识点的，在一个知识点的学习过程中我关注了哪些相关的知识点，又是如何将它们联系在一起，最终形成一个体系的。这篇文章就是一个典型的例子，我会对一些点进行发散，大家可以尝试着跟我一起来思考”网卡地址注册“这个问题。</p><a id="more"></a><h2 id="1-如何选择合适的网卡地址"><a href="#1-如何选择合适的网卡地址" class="headerlink" title="1 如何选择合适的网卡地址"></a>1 如何选择合适的网卡地址</h2><p>可能相当一部分人还不知道我这篇文章到底要讲什么，我说个场景，大家应该就明晰了。在分布式服务调用过程中，以 Dubbo 为例，服务提供者往往需要将自身的 IP 地址上报给注册中心，供消费者去发现。在大多数情况下 Dubbo 都可以正常工作，但如果你留意过 Dubbo 的 github issue，其实有不少人反馈：Dubbo Provider 注册了错误的 IP。如果你能立刻联想到：多网卡、内外网地址共存、VPN、虚拟网卡等关键词，那我建议你一定要继续将本文看下去，因为我也想到了这些，它们都是本文所要探讨的东西！那么“如何选择合适的网卡地址”呢，Dubbo 现有的逻辑到底算不算完备？我们不急着回答它，而是带着这些问题一起进行研究，相信到文末，其中答案，各位看官自有评说。</p><h2 id="2-Dubbo-是怎么做的"><a href="#2-Dubbo-是怎么做的" class="headerlink" title="2 Dubbo 是怎么做的"></a>2 Dubbo 是怎么做的</h2><p>Dubbo 获取网卡地址的逻辑在各个版本中也是千回百转，走过弯路，也做过优化，我们用最新的 2.7.2-SNAPSHOT 版本来介绍，在看以下源码时，大家可以怀着质疑的心态去阅读，在 dubbo github 的 master 分支可以获取源码。获取 localhost 的逻辑位于 <code>org.apache.dubbo.common.utils.NetUtils#getLocalAddress0()</code> 之中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> InetAddress <span class="title">getLocalAddress0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    InetAddress localAddress = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 首先尝试获取 /etc/hosts 中 hostname 对应的 IP</span></span><br><span class="line">    localAddress = InetAddress.getLocalHost();</span><br><span class="line">    Optional&lt;InetAddress&gt; addressOp = toValidAddress(localAddress);</span><br><span class="line">    <span class="keyword">if</span> (addressOp.isPresent()) &#123;</span><br><span class="line">        <span class="keyword">return</span> addressOp.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有找到适合注册的 IP，则开始轮询网卡</span></span><br><span class="line">    Enumeration&lt;NetworkInterface&gt; interfaces = NetworkInterface.getNetworkInterfaces();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == interfaces) &#123;</span><br><span class="line">        <span class="keyword">return</span> localAddress;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (interfaces.hasMoreElements()) &#123;</span><br><span class="line">        NetworkInterface network = interfaces.nextElement();</span><br><span class="line">        Enumeration&lt;InetAddress&gt; addresses = network.getInetAddresses();</span><br><span class="line">        <span class="keyword">while</span> (addresses.hasMoreElements()) &#123;</span><br><span class="line">            <span class="comment">// 返回第一个匹配的适合注册的 IP</span></span><br><span class="line">            Optional&lt;InetAddress&gt; addressOp = toValidAddress(addresses.nextElement());</span><br><span class="line">            <span class="keyword">if</span> (addressOp.isPresent()) &#123;</span><br><span class="line">                <span class="keyword">return</span> addressOp.get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> localAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dubbo 这段选取本地地址的逻辑大致分成了两步</p><ol><li>先去 /etc/hosts 文件中找 hostname 对应的 IP 地址，找到则返回；找不到则转 2</li><li>轮询网卡，寻找合适的 IP 地址，找到则返回；找不到返回 null，再 getLocalAddress0 外侧还有一段逻辑，如果返回 null，则注册 127.0.0.1 这个本地回环地址</li></ol><p>首先强调下，这段逻辑并没有太大的问题，先别急着挑刺，让我们来分析下其中的一些细节，并进行验证。</p><h3 id="2-1-尝试获取-hostname-映射-IP"><a href="#2-1-尝试获取-hostname-映射-IP" class="headerlink" title="2.1 尝试获取 hostname 映射 IP"></a>2.1 尝试获取 hostname 映射 IP</h3><p>Dubbo 首先选取的是 hostname 对应的 IP，在源码中对应的 <code>InetAddress.getLocalHost();</code>  在 <code>*nix</code> 系统实际部署 Dubbo 应用时，可以首先使用 <code>hostname</code> 命令获取主机名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xujingfengdeMacBook-Pro:~ xujingfeng$ hostname</span><br><span class="line">xujingfengdeMacBook-Pro.local</span><br></pre></td></tr></table></figure><p>紧接着在 <code>/etc/hosts</code> 配置 IP 映射，为了验证 Dubbo 的机制，我们随意为 hostname 配置一个 IP 地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1localhost</span><br><span class="line">1.2.3.4 xujingfengdeMacBook-Pro.local</span><br></pre></td></tr></table></figure><p>接着调用 <code>NetUtils.getLocalAddress0()</code> 进行验证，控制台打印如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xujingfengdeMacBook-Pro.local/1.2.3.4</span><br></pre></td></tr></table></figure><h3 id="2-2-判定有效的-IP-地址"><a href="#2-2-判定有效的-IP-地址" class="headerlink" title="2.2 判定有效的 IP 地址"></a>2.2 判定有效的 IP 地址</h3><p>在 toValidAddress 逻辑中，Dubbo 存在以下逻辑判定一个 IP 地址是否有效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Optional&lt;InetAddress&gt; <span class="title">toValidAddress</span><span class="params">(InetAddress address)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (address <span class="keyword">instanceof</span> Inet6Address) &#123;</span><br><span class="line">        Inet6Address v6Address = (Inet6Address) address;</span><br><span class="line">        <span class="keyword">if</span> (isValidV6Address(v6Address)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Optional.ofNullable(normalizeV6Address(v6Address));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isValidV4Address(address)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.of(address);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Optional.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依次校验其符合 Ipv6 或者 Ipv4 的 IP 规范，对于 Ipv6 的地址，见如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValidV6Address</span><span class="params">(Inet6Address address)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> preferIpv6 = Boolean.getBoolean(<span class="string">"java.net.preferIPv6Addresses"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!preferIpv6) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address.isReachable(<span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取 <code>java.net.preferIPv6Addresses</code> 参数，其默认值为 false，鉴于大多数应用并没有使用 Ipv6 地址作为理想的注册 IP，这问题不大，紧接着通过 isReachable 判断网卡的连通性。例如一些网卡可能是 VPN/ 虚拟网卡的地址，如果没有配置路由表，往往无法连通，可以将之过滤。</p><p>对于 Ipv4 的地址，见如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValidV4Address</span><span class="params">(InetAddress address)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (address == <span class="keyword">null</span> || address.isLoopbackAddress()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String name = address.getHostAddress();</span><br><span class="line">    <span class="keyword">boolean</span> result = (name != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; IP_PATTERN.matcher(name).matches()</span><br><span class="line">            &amp;&amp; !Constants.ANYHOST_VALUE.equals(name)</span><br><span class="line">            &amp;&amp; !Constants.LOCALHOST_VALUE.equals(name));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比 Ipv6 的判断，这里我们已经发现前后不对称的情况了</p><ul><li>Ipv4 相比 Ipv6 的逻辑多了 Ipv4 格式的正则校验、本地回环地址校验、ANYHOST 校验</li><li>Ipv4 相比 Ipv6 的逻辑少了网卡连通性的校验</li></ul><p>大家都知道，Ipv4 将 127.0.0.1 定为本地回环地址， Ipv6 也存在回环地址：0:0:0:0:0:0:0:1 或者表示为 ::1。改进建议也很明显，我们放到文末统一总结。</p><h3 id="2-3-轮询网卡"><a href="#2-3-轮询网卡" class="headerlink" title="2.3 轮询网卡"></a>2.3 轮询网卡</h3><p>如果上述地址获取为 null 则进入轮询网卡的逻辑（例如 hosts 未指定 hostname 的映射或者 hostname 配置成了 127.0.0.1 之类的地址便会导致获取到空的网卡地址），轮询网卡对应的源码是 <code>NetworkInterface.getNetworkInterfaces()</code> ，这里面涉及的知识点就比较多了，支撑起了我写这篇文章的素材，Dubbo 的逻辑并不复杂，进行简单的校验，返回第一个可用的 IP 即可。</p><p>性子急的读者可能忍不住了，多网卡！合适的网卡可能不止一个，Dubbo 怎么应对呢？按道理说，我们也替 Dubbo 说句公道话，客官要不你自己指定下？我们首先得对多网卡的场景达成一致看法，才能继续把这篇文章完成下去：我们只能 <strong> 尽可能 </strong> 过滤那些“<strong> 不对 </strong>”的网卡。Dubbo 看样子对所有网卡是一视同仁了，那么是不是可以尝试优化一下其中的逻辑呢？</p><p>许多开源的服务治理框架在 stackoverflow 或者其 issue 中，注册错 IP 相关的问题都十分高频，大多数都是轮询网卡出了问题。既然事情发展到这儿，势必需要了解一些网络、网卡的知识，我们才能过滤掉那些明显不适合 RPC 服务注册的 IP 地址了。</p><h2 id="3-Ifconfig-介绍"><a href="#3-Ifconfig-介绍" class="headerlink" title="3 Ifconfig 介绍"></a>3 Ifconfig 介绍</h2><p>我并没有想要让大家对后续的内容望而却步，特地选择了这个大家最熟悉的 Linux 命令！对于那些吐槽：“天呐，都 2019 年了，你怎么还在用 net-tools/ifconfig，iproute2/ip 了解一下”的言论，请大家视而不见。无论你使用的是 mac，还是 linux，都可以使用它去 CRUD 你的网卡配置。</p><h3 id="3-1-常用指令"><a href="#3-1-常用指令" class="headerlink" title="3.1 常用指令"></a>3.1 常用指令</h3><p><strong> 启动关闭指定网卡：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 up</span><br><span class="line">ifconfig eth0 down</span><br></pre></td></tr></table></figure><p><code>ifconfig eth0 up</code> 为启动网卡 eth0，<code>ifconfig eth0 down</code> 为关闭网卡 eth0。ssh 登陆 linux 服务器操作的用户要小心执行这个操作了，千万不要蠢哭自己。不然你下一步就需要去 google：“禁用 eth0 网卡后如何远程连接 Linux 服务器” 了。</p><p><strong> 为网卡配置和删除 IPv6 地址：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 add 33ffe:3240:800:1005::2/64    #为网卡 eth0 配置 IPv6 地址</span><br><span class="line">ifconfig eth0 del 33ffe:3240:800:1005::2/64    #为网卡 eth0 删除 IPv6 地址</span><br></pre></td></tr></table></figure><p><strong> 用 ifconfig 修改 MAC 地址：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 hw ether 00:AA:BB:CC:dd:EE</span><br></pre></td></tr></table></figure><p><strong> 配置 IP 地址：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ifconfig eth0 192.168.2.10</span><br><span class="line">[root@localhost ~]# ifconfig eth0 192.168.2.10 netmask 255.255.255.0</span><br><span class="line">[root@localhost ~]# ifconfig eth0 192.168.2.10 netmask 255.255.255.0 broadcast 192.168.2.255</span><br></pre></td></tr></table></figure><p><strong> 启用和关闭 arp 协议：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 arp    #开启网卡 eth0 的 arp 协议</span><br><span class="line">ifconfig eth0 -arp   #关闭网卡 eth0 的 arp 协议</span><br></pre></td></tr></table></figure><p><strong> 设置最大传输单元：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 mtu 1500    #设置能通过的最大数据包大小为 1500 bytes</span><br></pre></td></tr></table></figure><h3 id="3-2-查看网卡信息"><a href="#3-2-查看网卡信息" class="headerlink" title="3.2 查看网卡信息"></a>3.2 查看网卡信息</h3><p>在一台 ubuntu 上执行 <code>ifconfig -a</code> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-30-130-ubuntu:~$ ifconfig -a</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 52:54:00:a9:5f:ae</span><br><span class="line">          inet addr:10.154.30.130  Bcast:10.154.63.255  Mask:255.255.192.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:149673 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:152271 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:15205083 (15.2 MB)  TX bytes:21386362 (21.3 MB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback</span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1</span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line">          </span><br><span class="line">docker0   Link encap:Ethernet  HWaddr 02:42:58:45:c1:15</span><br><span class="line">          inet addr:172.17.0.1  Bcast:172.17.255.255  Mask:255.255.0.0</span><br><span class="line">          UP BROADCAST MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line"></span><br><span class="line">tun0      Link encap:UNSPEC  HWaddr 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00</span><br><span class="line">          UP POINTOPOINT NOARP MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:100</span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br></pre></td></tr></table></figure><p>为了防止黑客对我的 Linux 发起攻击，我还是偷偷对 IP 做了一点“改造”，请不要为难一个趁着打折 + 组团购买廉价云服务器的小伙子。对于部门网卡的详细解读:</p><p>eth0 表示第一块网卡， 其中 HWaddr 表示网卡的物理地址，可以看到目前这个网卡的物理地址 (MAC 地址）是 02:42:38:52:70:54</p><p>inet addr 用来表示网卡的 IP 地址，此网卡的 IP 地址是 10.154.30.130，广播地址， Bcast: 172.18.255.255，掩码地址 Mask:255.255.0.0 </p><p>lo 是表示主机的回环地址，这个一般是用来测试一个网络程序，但又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口。比如把 HTTPD 服务器的指定到回坏地址，在浏览器输入 127.0.0.1 就能看到你所架 WEB 网站了。但只是你能看得到，局域网的其它主机或用户无从知晓。</p><p>第一行：连接类型：Ethernet（以太网）HWaddr（硬件 mac 地址）</p><p>第二行：网卡的 IP 地址、子网、掩码</p><p>第三行：UP（代表网卡开启状态）RUNNING（代表网卡的网线被接上）MULTICAST（支持组播）MTU:1500（最大传输单元）：1500 字节（ipconfig 不加 -a 则无法看到 DOWN 的网卡）</p><p>第四、五行：接收、发送数据包情况统计</p><p>第七行：接收、发送数据字节数统计信息。</p><p>紧接着的两个网卡 docker0，tun0 是怎么出来的呢？我在我的 ubuntu 上装了 docker 和 openvpn。这两个东西应该是日常干扰我们做服务注册时的罪魁祸首了，当然，也有可能存在 eth1 这样的第二块网卡。ifconfig -a 看到的东西就对应了 JDK 的 api ：<code>NetworkInterface.getNetworkInterfaces()</code> 。我们简单做个总结，大致有三个干扰因素</p><ul><li>以 docker 网桥为首的虚拟网卡地址，毕竟这东西这么火，怎么也得单独列出来吧？</li><li>以 TUN/TAP 为代表的虚拟网卡地址，多为 VPN 场景</li><li>以 eth1 为代表的多网卡场景，有钱就可以装多网卡了！</li></ul><p>我们后续的篇幅将针对这些场景做分别的介绍，力求让大家没吃过猪肉，起码看下猪怎么跑的。</p><h2 id="4-干扰因素一：Docker-网桥"><a href="#4-干扰因素一：Docker-网桥" class="headerlink" title="4 干扰因素一：Docker 网桥"></a>4 干扰因素一：Docker 网桥</h2><p>熟悉 docker 的朋友应该知道 docker 会默认创建一个 docker0 的网桥，供容器实例连接。如果嫌默认的网桥不够直观，我们可以使用 bridge 模式自定义创建一个新的网桥：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-30-130-ubuntu:~$ docker network create kirito-bridge</span><br><span class="line">a38696dbbe58aa916894c674052c4aa6ab32266dcf6d8111fb794b8a344aa0d9</span><br><span class="line">ubuntu@VM-30-130-ubuntu:~$ ifconfig -a</span><br><span class="line">br-a38696dbbe58 Link encap:Ethernet  HWaddr 02:42:6e:aa:fd:0c</span><br><span class="line">          inet addr:172.19.0.1  Bcast:172.19.255.255  Mask:255.255.0.0</span><br><span class="line">          UP BROADCAST MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br></pre></td></tr></table></figure><p>使用 docker network 指令创建网桥之后，自动创建了对应的网卡，我只给出了 <code>ifconfig -a</code> 的增量返回部分，可以看出多了一个 br-a38696dbbe58 的网卡。</p><p>我有意区分了“网桥”和“网卡”，可以使用 bridge-utils/brctl 来查看网桥信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-30-130-ubuntu:~$ sudo brctl show</span><br><span class="line">bridge namebridge idSTP enabledinterfaces</span><br><span class="line">br-a38696dbbe588000.02426eaafd0cno</span><br><span class="line">docker08000.02425845c215no</span><br></pre></td></tr></table></figure><p>网桥是一个虚拟设备，这个设备只有 brctl show 能看到，网桥创建之后，会自动创建一个同名的网卡，并将这个网卡加入网桥。</p><h2 id="5-干扰因素二：TUN-TAP-虚拟网络设备"><a href="#5-干扰因素二：TUN-TAP-虚拟网络设备" class="headerlink" title="5 干扰因素二：TUN/TAP 虚拟网络设备"></a>5 干扰因素二：TUN/TAP 虚拟网络设备</h2><p>平时我们所说的虚拟网卡、虚拟机，大致都跟 TUN/TAP 有关。我的读者大多数是 Java 从业者，相信我下面的内容并没有太超纲，不要被陌生的名词唬住。对于被唬住的读者，也可以直接跳过 5.1~5.3，直接看 5.4 的实战。</p><h3 id="5-1-真实网卡工作原理"><a href="#5-1-真实网卡工作原理" class="headerlink" title="5.1 真实网卡工作原理"></a>5.1 真实网卡工作原理</h3><p><img src="http://kirito.iocoder.cn/1918847-496d0e96c237f25a.png" alt="1918847-496d0e96c237f25a"></p><p>上图中的 <strong>eth0</strong> 表示我们主机已有的真实的网卡接口 (<strong>interface</strong>)。</p><p>网卡接口 <strong>eth0</strong> 所代表的真实网卡通过网线 (<strong>wire</strong>) 和外部网络相连，该物理网卡收到的数据包会经由接口 <strong>eth0</strong> 传递给内核的网络协议栈(<strong>Network Stack</strong>)。然后协议栈对这些数据包进行进一步的处理。</p><p>对于一些错误的数据包, 协议栈可以选择丢弃；对于不属于本机的数据包，协议栈可以选择转发；而对于确实是传递给本机的数据包, 而且该数据包确实被上层的应用所需要，协议栈会通过 <strong>Socket API</strong> 告知上层正在等待的应用程序。</p><h3 id="5-2-TUN-工作原理"><a href="#5-2-TUN-工作原理" class="headerlink" title="5.2 TUN 工作原理"></a>5.2 TUN 工作原理</h3><p><img src="http://kirito.iocoder.cn/1918847-85ea08bc89d9427e.png" alt="1918847-85ea08bc89d9427e"></p><p>我们知道，普通的网卡是通过网线来收发数据包的话，而 <strong>TUN</strong> 设备比较特殊，它通过一个文件收发数据包。</p><p>如上图所示，<strong>tunX</strong> 和上面的 <strong>eth0</strong> 在逻辑上面是等价的， <strong>tunX</strong> 也代表了一个网络接口, 虽然这个接口是系统通过软件所模拟出来的.</p><p>网卡接口 <strong>tunX 所代表的虚拟网卡通过文件 /dev/tunX 与我们的应用程序 (App</strong>) 相连，应用程序每次使用 <strong>write</strong> 之类的系统调用将数据写入该文件，这些数据会以网络层数据包的形式，通过该虚拟网卡，经由网络接口 <strong>tunX</strong> 传递给网络协议栈，同时该应用程序也可以通过 <strong>read</strong> 之类的系统调用，经由文件 <strong>/dev/tunX</strong> 读取到协议栈向 <strong>tunX</strong> 传递的 <strong> 所有 </strong> 数据包。</p><p>此外，协议栈可以像操纵普通网卡一样来操纵 <strong>tunX</strong> 所代表的虚拟网卡。比如说，给 <strong>tunX</strong> 设定 <strong>IP</strong> 地址，设置路由，总之，在协议栈看来，<strong>tunX</strong> 所代表的网卡和其他普通的网卡区别不大，当然，硬要说区别，那还是有的, 那就是 <strong>tunX</strong> 设备不存在 <strong>MAC</strong> 地址，这个很好理解，<strong>tunX</strong> 只模拟到了网络层，要 <strong>MAC </strong> 地址没有任何意义。当然，如果是 <strong>tapX</strong> 的话，在协议栈的眼中，<strong>tapX</strong> 和真实网卡没有任何区别。</p><p>是不是有些懵了？我是谁，为什么我要在这篇文章里面学习 TUN！因为我们常用的 VPN 基本就是基于 TUN/TAP 搭建的，如果我们使用 <strong>TUN</strong> 设备搭建一个基于 <strong>UDP</strong> 的 <strong>VPN</strong> ，那么整个处理过程可能是这幅样子：</p><p><img src="http://kirito.iocoder.cn/1918847-ac4155ec7e9489b2.png" alt="1918847-ac4155ec7e9489b2"></p><h3 id="5-3-TAP-工作原理"><a href="#5-3-TAP-工作原理" class="headerlink" title="5.3 TAP 工作原理"></a>5.3 TAP 工作原理</h3><p><strong>TAP</strong> 设备与 <strong>TUN</strong> 设备工作方式完全相同，区别在于：</p><ol><li><strong>TUN</strong> 设备是一个三层设备，它只模拟到了 <strong>IP</strong> 层，即网络层 我们可以通过 <strong>/dev/tunX</strong> 文件收发 <strong>IP</strong> 层数据包，它无法与物理网卡做 <strong>bridge</strong>，但是可以通过三层交换（如  <strong>ip_forward</strong>）与物理网卡连通。可以使用 <code>ifconfig</code> 之类的命令给该设备设定 <strong>IP</strong> 地址。</li><li><strong>TAP</strong> 设备是一个二层设备，它比 <strong>TUN</strong> 更加深入，通过 <strong>/dev/tapX</strong> 文件可以收发 <strong>MAC</strong> 层数据包，即数据链路层，拥有 <strong>MAC</strong> 层功能，可以与物理网卡做 <strong>bridge</strong>，支持 <strong>MAC</strong> 层广播。同样的，我们也可以通过 <code>ifconfig</code> 之类的命令给该设备设定 <strong>IP</strong> 地址，你如果愿意，我们可以给它设定 <strong>MAC</strong> 地址。</li></ol><p>关于文章中出现的二层，三层，我这里说明一下，第一层是物理层，第二层是数据链路层，第三层是网络层，第四层是传输层。</p><h3 id="5-4-openvpn-实战"><a href="#5-4-openvpn-实战" class="headerlink" title="5.4 openvpn 实战"></a>5.4 openvpn 实战</h3><p>openvpn 是 Linux 上一款开源的 vpn 工具，我们通过它来复现出影响我们做网卡选择的场景。</p><p>安装 openvpn</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openvpn</span><br></pre></td></tr></table></figure><p>安装一个 TUN 设备：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-30-130-ubuntu:~$ sudo openvpn --mktun --dev tun0</span><br><span class="line">Mon Apr 29 22:23:31 2019 TUN/TAP device tun0 opened</span><br><span class="line">Mon Apr 29 22:23:31 2019 Persist state set to: ON</span><br></pre></td></tr></table></figure><p>安装一个 TAP 设备：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-30-130-ubuntu:~$ sudo openvpn --mktun --dev tap0</span><br><span class="line">Mon Apr 29 22:24:36 2019 TUN/TAP device tap0 opened</span><br><span class="line">Mon Apr 29 22:24:36 2019 Persist state set to: ON</span><br></pre></td></tr></table></figure><p>执行 <code>ifconfig -a</code> 查看网卡，只给出增量的部分：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tap0      Link encap:Ethernet  HWaddr 7a:a2:a8:f1:6b:df</span><br><span class="line">          BROADCAST MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:100</span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line"></span><br><span class="line">tun0      Link encap:UNSPEC  HWaddr 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00</span><br><span class="line">          inet addr:10.154.30.131  P-t-P:10.154.30.131  Mask:255.255.255.255</span><br><span class="line">          UP POINTOPOINT NOARP MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:100</span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br></pre></td></tr></table></figure><p>这样就解释了文章一开始为什么会有 tun0 这样的网卡了。这里读者可能会有疑惑，使用 ifconfig 不是也可以创建 tap 和 tun 网卡吗？当然啦，openvpn 是一个 vpn 工具，只能创建名为 tunX/tapX 的网卡，其遵守着一定的规范，ifconfig 可以随意创建，但没人认那些随意创建的网卡。</p><h2 id="6-干扰因素三：多网卡"><a href="#6-干扰因素三：多网卡" class="headerlink" title="6 干扰因素三：多网卡"></a>6 干扰因素三：多网卡</h2><p><img src="http://kirito.iocoder.cn/image-20190429223515625.png" alt="image-20190429223515625"></p><p>这个没有太多好说的，有多张真实的网卡，从普哥那儿搞到如上的 IP 信息。</p><h2 id="7-MAC-下的差异"><a href="#7-MAC-下的差异" class="headerlink" title="7 MAC 下的差异"></a>7 MAC 下的差异</h2><p>虽然 ifconfig 等指令是 <code>*nux</code> 通用的，但是其展示信息，网卡相关的属性和命名都有较大的差异。例如这是我 MAC 下执行 <code>ifconfig -a</code> 的返回：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">xujingfengdeMacBook-Pro:dubbo-in-action xujingfeng$ ifconfig -a</span><br><span class="line">lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384</span><br><span class="line">options=1203&lt;RXCSUM,TXCSUM,TXSTATUS,SW_TIMESTAMP&gt;</span><br><span class="line">inet 127.0.0.1 netmask 0xff000000</span><br><span class="line">inet6 ::1 prefixlen 128</span><br><span class="line">inet6 fe80::1%lo0 prefixlen 64 scopeid 0x1</span><br><span class="line">nd6 options=201&lt;PERFORMNUD,DAD&gt;</span><br><span class="line">gif0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280</span><br><span class="line">stf0: flags=0&lt;&gt; mtu 1280</span><br><span class="line">XHC0: flags=0&lt;&gt; mtu 0</span><br><span class="line">XHC20: flags=0&lt;&gt; mtu 0</span><br><span class="line">en0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500</span><br><span class="line">ether 88:e9:fe:88:a0:76</span><br><span class="line">inet6 fe80::1cab:f689:60d1:bacb%en0 prefixlen 64 secured scopeid 0x6</span><br><span class="line">inet 30.130.11.242 netmask 0xffffff80 broadcast 30.130.11.255</span><br><span class="line">nd6 options=201&lt;PERFORMNUD,DAD&gt;</span><br><span class="line">media: autoselect</span><br><span class="line">status: active</span><br><span class="line">p2p0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 2304</span><br><span class="line">ether 0a:e9:fe:88:a0:76</span><br><span class="line">media: autoselect</span><br><span class="line">status: inactive</span><br><span class="line">awdl0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1484</span><br><span class="line">ether 66:d2:8c:8c:dd:85</span><br><span class="line">inet6 fe80::64d2:8cff:fe8c:dd85%awdl0 prefixlen 64 scopeid 0x8</span><br><span class="line">nd6 options=201&lt;PERFORMNUD,DAD&gt;</span><br><span class="line">media: autoselect</span><br><span class="line">status: active</span><br><span class="line">en1: flags=8963&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500</span><br><span class="line">options=60&lt;TSO4,TSO6&gt;</span><br><span class="line">ether aa:00:d0:13:0e:01</span><br><span class="line">media: autoselect &lt;full-duplex&gt;</span><br><span class="line">status: inactive</span><br><span class="line">en2: flags=8963&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500</span><br><span class="line">options=60&lt;TSO4,TSO6&gt;</span><br><span class="line">ether aa:00:d0:13:0e:00</span><br><span class="line">media: autoselect &lt;full-duplex&gt;</span><br><span class="line">status: inactive</span><br><span class="line">bridge0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500</span><br><span class="line">options=63&lt;RXCSUM,TXCSUM,TSO4,TSO6&gt;</span><br><span class="line">ether aa:00:d0:13:0e:01</span><br><span class="line">Configuration:</span><br><span class="line">id 0:0:0:0:0:0 priority 0 hellotime 0 fwddelay 0</span><br><span class="line">maxage 0 holdcnt 0 proto stp maxaddr 100 timeout 1200</span><br><span class="line">root id 0:0:0:0:0:0 priority 0 ifcost 0 port 0</span><br><span class="line">ipfilter disabled flags 0x2</span><br><span class="line">member: en1 flags=3&lt;LEARNING,DISCOVER&gt;</span><br><span class="line">        ifmaxaddr 0 port 9 priority 0 path cost 0</span><br><span class="line">member: en2 flags=3&lt;LEARNING,DISCOVER&gt;</span><br><span class="line">        ifmaxaddr 0 port 10 priority 0 path cost 0</span><br><span class="line">nd6 options=201&lt;PERFORMNUD,DAD&gt;</span><br><span class="line">media: &lt;unknown type&gt;</span><br><span class="line">status: inactive</span><br><span class="line">utun0: flags=8051&lt;UP,POINTOPOINT,RUNNING,MULTICAST&gt; mtu 2000</span><br><span class="line">inet6 fe80::3fe0:3e8b:384:9968%utun0 prefixlen 64 scopeid 0xc</span><br><span class="line">nd6 options=201&lt;PERFORMNUD,DAD&gt;</span><br><span class="line">utun1: flags=8051&lt;UP,POINTOPOINT,RUNNING,MULTICAST&gt; mtu 1380</span><br><span class="line">inet6 fe80::7894:3abc:5abd:457d%utun1 prefixlen 64 scopeid 0xd</span><br><span class="line">nd6 options=201&lt;PERFORMNUD,DAD&gt;</span><br></pre></td></tr></table></figure><p>内容很多，我挑几点差异简述下：</p><ul><li><p>内容展示形式不一样，没有 Linux 下的接收、发送数据字节数等统计信息</p></li><li><p>真实网卡的命名不一样：eth0 -&gt; en0</p></li><li>虚拟网卡的命名格式不一样：tun/tap -&gt; utun</li></ul><p>对于这些常见网卡命名的解读，我摘抄一部分来自 stackoverflow 的回答：</p><blockquote><p>In arbitrary order of my familarity / widespread relevance:</p><p><code>lo0</code> is loopback.</p><p><code>en0</code> at one point “ethernet”, now is WiFi (and I have no idea what extra <code>en1</code> or <code>en2</code> are used for).</p><p><code>fw0</code> is the FireWire network interface.</p><p><code>stf0</code> is an <a href="https://www.freebsd.org/cgi/man.cgi?gif(4" target="_blank" rel="noopener">IPv6 to IPv4 tunnel interface</a>) to support <a href="http://en.wikipedia.org/wiki/6to4" target="_blank" rel="noopener">the transition</a> from IPv4 to the IPv6 standard.</p><p><code>gif0</code> is a more <a href="https://www.freebsd.org/cgi/man.cgi?gif(4" target="_blank" rel="noopener">generic tunneling interface</a>) [46]-to-[46].</p><p><code>awdl0</code> is <a href="https://stackoverflow.com/questions/19587701/what-is-awdl-apple-wireless-direct-link-and-how-does-it-work" target="_blank" rel="noopener">Apple Wireless Direct Link</a></p><p><code>p2p0</code> is related to AWDL features. Either as an old version, or virtual interface with different semantics than <code>awdl</code>.</p><p>the “Network” panel in System Preferences to see what network devices “exist” or “can exist” with current configuration.</p><p>many VPNs will add additional devices, often “utun#” or “utap#” following <a href="https://en.wikipedia.org/wiki/TUN/TAP" target="_blank" rel="noopener">TUN/TAP (L3/L2)</a>virtual networking devices.</p><p>use <code>netstat -nr</code> to see how traffic is currently routed via network devices according to destination.</p><p>interface naming conventions started in BSD were retained in OS X / macOS, and now there also additions.</p></blockquote><h2 id="8-Dubbo-改进建议"><a href="#8-Dubbo-改进建议" class="headerlink" title="8 Dubbo 改进建议"></a>8 Dubbo 改进建议</h2><p>我们进行了以上探索，算是对网卡有一点了解了。回过头来看看 Dubbo 获取网卡的逻辑，是否可以做出改进呢？</p><p><strong>Dubbo Action 1:</strong> </p><p>保持 Ipv4 和 Ipv6 的一致性校验。为 Ipv4 增加连通性校验；为 Ipv6 增加 LoopBack 和 ANYHOST 等校验。</p><p><strong>Dubbo Action 2:</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NetworkInterface network = interfaces.nextElement();</span><br><span class="line"><span class="keyword">if</span> (network.isLoopback() || network.isVirtual()|| !network.isUp()) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK 提供了以上的 API，我们可以利用起来，过滤一部分一定不正确的网卡。</p><p><strong>Dubbo Action 3:</strong> </p><p>我们本文花了较多的篇幅介绍了 docker 和 TUN/TAP 两种场景导致的虚拟网卡的问题，算是较为常见的一个影响因素，虽然他们的命名具有固定性，如 docker0、tunX、tapX，但我觉得通过网卡名称的判断方式去过滤注册 IP 有一些 hack，所以不建议 dubbo contributor 提出相应的 pr 去增加这些 hack 判断，尽管可能会对判断有所帮助。</p><p>对于真实多网卡、内外网 IP 共存的场景，不能仅仅是框架侧在做努力，用户也需要做一些事，就像爱情一样，我可以主动一点，但你也得反馈，才能发展出故事。</p><p><strong>Dubbo User Action 1:</strong></p><p>可以配置 <code>/etc/hosts</code> 文件，将 hostname 对应的 IP 显示配置进去。</p><p><strong>Dubbo User Action 2:</strong></p><p>可以使用启动参数去显示指定注册的 IP：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-DDUBBO_IP_TO_REGISTRY=<span class="number">1.2</span>.3.4</span><br></pre></td></tr></table></figure><p>也可以指定 Dubbo 服务绑定在哪块网卡上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-DDUBBO_IP_TO_BIND=<span class="number">1.2</span>.3.4</span><br></pre></td></tr></table></figure><h2 id="9-参考文章"><a href="#9-参考文章" class="headerlink" title="9 参考文章"></a>9 参考文章</h2><p><a href="https://www.jianshu.com/p/09f9375b7fa7" target="_blank" rel="noopener">TUN/TAP 设备浅析</a></p><p><a href="https://stackoverflow.com/questions/29958143/what-are-en0-en1-p2p-and-so-on-that-are-displayed-after-executing-ifconfig" target="_blank" rel="noopener">what-are-en0-en1-p2p-and-so-on-that-are-displayed-after-executing-ifconfig</a></p><p><strong> 欢迎关注我的微信公众号：「Kirito 的技术分享」，关于文章的任何疑问都会得到回复，带来更多 Java 相关的技术分享。</strong></p><p><img src="http://kirito.iocoder.cn/qrcode_for_gh_c06057be7960_258%20%281%29.jpg" alt="关注微信公众号"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我曾经写过一篇和本文标题类似的文章《研究优雅停机时的一点思考》，上文和本文都有一个共同点：网卡地址注册和优雅停机都是一个很小的知识点，但是背后牵扯到的知识点却是庞大的体系，我在写这类文章前基本也和大多数读者一样，处于“知道有这么个东西，但不了解细节”的阶段，但一旦深挖，会感受到其中的奇妙，并有机会接触到很多平时不太关注的知识点。&lt;/p&gt;
&lt;p&gt;另外，我还想介绍一个叫做”元阅读“的技巧，可能这个词是我自己造的，也有人称之为”超视角阅读“。其内涵指的是，普通读者从我的文章中学到的是某个知识点，而元阅读者从我的文章中可能会额外关注，我是如何掌握某个知识点的，在一个知识点的学习过程中我关注了哪些相关的知识点，又是如何将它们联系在一起，最终形成一个体系的。这篇文章就是一个典型的例子，我会对一些点进行发散，大家可以尝试着跟我一起来思考”网卡地址注册“这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="RPC" scheme="http://lexburner.github.io/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="http://lexburner.github.io/tags/Dubbo/"/>
    
      <category term="RPC" scheme="http://lexburner.github.io/tags/RPC/"/>
    
      <category term="网卡" scheme="http://lexburner.github.io/tags/%E7%BD%91%E5%8D%A1/"/>
    
  </entry>
  
  <entry>
    <title>【Dubbo3.0 新特性】集成 RSocket, 新增响应式支持</title>
    <link href="http://lexburner.github.io/dubbo-rsocket/"/>
    <id>http://lexburner.github.io/dubbo-rsocket/</id>
    <published>2019-04-11T11:19:41.000Z</published>
    <updated>2019-09-26T09:45:31.122Z</updated>
    
    <content type="html"><![CDATA[<h2 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h2><p>响应式编程现在是现在一个很热的话题。响应式编程让开发者更方便地编写高性能的异步代码，关于响应式编程更详细的信息可以参考 <a href="http://reactivex.io/" target="_blank" rel="noopener">http://reactivex.io/</a> 。很可惜，在之前很长一段时间里，Dubbo 并不支持响应式编程，简单来说，Dubbo 不支持在 rpc 调用时，使用 Mono/Flux 这种流对象（reactive-stream 中流的概念 )，给用户使用带来了不便。</p><p>RSocket 是一个支持 reactive-stream 语义的开源网络通信协议，它将 reactive 语义的复杂逻辑封装了起来，使得上层可以方便实现网络程序。RSocket 详细资料：<a href="http://rsocket.io/。" target="_blank" rel="noopener">http://rsocket.io/。</a></p><p>Dubbo 在 <a href="https://github.com/apache/incubator-Dubbo/tree/3.x-dev" target="_blank" rel="noopener">3.0.0-SNAPSHOT</a> 版本里基于 RSocket 对响应式编程提供了支持，用户可以在请求参数和返回值里使用 Mono 和 Flux 类型的对象。下面我们给出使用范例，源码可以在文末获取。</p><a id="more"></a><h2 id="Dubbo-RSocket-初体验"><a href="#Dubbo-RSocket-初体验" class="headerlink" title="Dubbo RSocket 初体验"></a>Dubbo RSocket 初体验</h2><h3 id="服务接口"><a href="#服务接口" class="headerlink" title="服务接口"></a>服务接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">    <span class="function">Mono&lt;String&gt; <span class="title">requestMonoWithMonoArg</span><span class="params">(Mono&lt;String&gt; m1, Mono&lt;String&gt; m2)</span></span>;</span><br><span class="line">    <span class="function">Flux&lt;String&gt; <span class="title">requestFluxWithFluxArg</span><span class="params">(Flux&lt;String&gt; f1, Flux&lt;String&gt; f2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.projectreactor<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>reactor-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.3-RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在服务定义层，引入了 Mono，Flux 等 reactor 的概念，所以需要添加 reactor-core 的依赖。</p><h3 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServiceImpl</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;String&gt; <span class="title">requestMonoWithMonoArg</span><span class="params">(Mono&lt;String&gt; m1, Mono&lt;String&gt; m2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m1.zipWith(m2, <span class="keyword">new</span> BiFunction&lt;String, String, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String s, String s2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> s+<span class="string">" "</span>+s2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flux&lt;String&gt; <span class="title">requestFluxWithFluxArg</span><span class="params">(Flux&lt;String&gt; f1, Flux&lt;String&gt; f2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f1.zipWith(f2, <span class="keyword">new</span> BiFunction&lt;String, String, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String s, String s2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> s+<span class="string">" "</span>+s2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了常规的 Dubbo 必须依赖之外，还需要添加 dubbo-rsocket 的扩展</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//... other dubbo moudle</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-rpc-rsocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置并启动服务端，注意协议名字填写 rsocket：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://dubbo.apache.org/schema/Dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- provider's application name, used for tracing dependency relationship --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"demo-provider"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- use registry center to export service --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- use Dubbo protocol to export service on port 20890 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"rsocket"</span> <span class="attr">port</span>=<span class="string">"20890"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- service implementation, as same as regular local bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">class</span>=<span class="string">"org.apache.dubbo.samples.basic.impl.DemoServiceImpl"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- declare the service interface to be exported --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"org.apache.dubbo.samples.basic.api.DemoService"</span> <span class="attr">ref</span>=<span class="string">"demoService"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>服务提供者的 bootstrap：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RsocketProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[]&#123;<span class="string">"spring/rsocket-provider.xml"</span>&#125;);</span><br><span class="line">        context.start();</span><br><span class="line">        System.in.read(); <span class="comment">// press any key to exit</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h3><p>然后配置并启动消费者消费者如下, 注意协议名填写 rsocket：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/Dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- consumer's application name, used for tracing dependency relationship (not a matching criterion),</span></span><br><span class="line"><span class="comment">    don't set it same as provider --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"demo-consumer"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- use registry center to discover service --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- generate proxy for the remote service, then demoService can be used in the same way as the</span></span><br><span class="line"><span class="comment">    local regular interface --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">check</span>=<span class="string">"true"</span> <span class="attr">interface</span>=<span class="string">"org.apache.dubbo.samples.basic.api.DemoService"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RsocketConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[]&#123;<span class="string">"spring/rsocket-consumer.xml"</span>&#125;);</span><br><span class="line">        context.start();</span><br><span class="line">        DemoService demoService = (DemoService) context.getBean(<span class="string">"demoService"</span>); <span class="comment">// get remote service proxy</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Mono&lt;String&gt; monoResult = demoService.requestMonoWithMonoArg(Mono.just(<span class="string">"A"</span>), Mono.just(<span class="string">"B"</span>));</span><br><span class="line">                monoResult.doOnNext(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                        System.out.println(s);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).block();</span><br><span class="line"></span><br><span class="line">                Flux&lt;String&gt; fluxResult = demoService.requestFluxWithFluxArg(Flux.just(<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>), Flux.just(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>));</span><br><span class="line">                fluxResult.doOnNext(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                        System.out.println(s);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).blockLast();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">                throwable.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到配置上除了协议名使用 rsocket 以外其他并没有特殊之处。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>以前用户并不能在参数或者返回值里使用 Mono/Flux 这种流对象（reactive-stream 里的流的概念）。因为流对象自带异步属性，当业务把流对象作为参数或者返回值传递给框架之后，框架并不能将流对象正确的进行序列化。</p><p>Dubbo 基于 RSocket 提供了 reactive 支持。RSocket 将 reactive 语义的复杂逻辑封装起来了，给上层提供了简洁的抽象如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Mono&lt;Void&gt; <span class="title">fireAndForget</span><span class="params">(Payload payload)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Mono&lt;Payload&gt; <span class="title">requestResponse</span><span class="params">(Payload payload)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Flux&lt;Payload&gt; <span class="title">requestStream</span><span class="params">(Payload payload)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Flux&lt;Payload&gt; <span class="title">requestChannel</span><span class="params">(Publisher&lt;Payload&gt; payloads)</span></span>;</span><br></pre></td></tr></table></figure></p><ul><li>从客户端视角看，框架建立连接之后，只需要将请求信息编码到 Payload 里，然后通过 requestStream 方法即可向服务端发起请求。</li><li>从服务端视角看，RSocket 收到请求之后，会调用我们实现的 requestStream 方法，我们从 Payload 里解码得到请求信息之后，调用业务方法，然后拿到 Flux 类型的返回值即可。</li></ul><p>需要注意的是业务返回值一般是 <code>Flux&lt;BizDO&gt;</code>，而 RSocket 要求的是 <code>Flux&lt;Payload&gt;</code>，所以我们需要通过 map operator 拦截业务数据，将 BizDO 编码为 Payload 才可以递交给 RSocket。而 RSocket 会负责数据的传输和 reactive 语义的实现。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Dubbo 2.7 相比 Dubbo 2.6 提供了 CompletableFuture 的异步化支持，在 Dubbo 3.0 又继续拥抱了 Reactive，不断对新特性的探索，无疑是增加了使用者的信心。RSocket 这一框架 / 协议，如今在国内外也是比较火的一个概念，它提供了丰富的 Reactive 语义以及多语言的支持，使得服务治理框架可以很快地借助它实现 Reactive 语义。有了响应式编程支持，业务可以更加方便的实现异步逻辑。</p><p>本篇文章对 Dubbo RSocket 进行了一个简单的介绍，对 Reactive、RSocket 感兴趣的同学也可以浏览下 Dubbo 3.0 源码对 RSocket 的封装。</p><p>相关链接：</p><p>[1] 文中源码：<a href="https://github.com/apache/incubator-dubbo-samples/tree/3.x/dubbo-samples-rsocket" target="_blank" rel="noopener">https://github.com/apache/incubator-dubbo-samples/tree/3.x/dubbo-samples-rsocket</a></p><p>[2] Dubbo 3.x 开发分支：<a href="https://github.com/apache/incubator-Dubbo/tree/3.x-dev" target="_blank" rel="noopener">https://github.com/apache/incubator-Dubbo/tree/3.x-dev</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;响应式编程&quot;&gt;&lt;a href=&quot;#响应式编程&quot; class=&quot;headerlink&quot; title=&quot;响应式编程&quot;&gt;&lt;/a&gt;响应式编程&lt;/h2&gt;&lt;p&gt;响应式编程现在是现在一个很热的话题。响应式编程让开发者更方便地编写高性能的异步代码，关于响应式编程更详细的信息可以参考 &lt;a href=&quot;http://reactivex.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://reactivex.io/&lt;/a&gt; 。很可惜，在之前很长一段时间里，Dubbo 并不支持响应式编程，简单来说，Dubbo 不支持在 rpc 调用时，使用 Mono/Flux 这种流对象（reactive-stream 中流的概念 )，给用户使用带来了不便。&lt;/p&gt;
&lt;p&gt;RSocket 是一个支持 reactive-stream 语义的开源网络通信协议，它将 reactive 语义的复杂逻辑封装了起来，使得上层可以方便实现网络程序。RSocket 详细资料：&lt;a href=&quot;http://rsocket.io/。&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://rsocket.io/。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Dubbo 在 &lt;a href=&quot;https://github.com/apache/incubator-Dubbo/tree/3.x-dev&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;3.0.0-SNAPSHOT&lt;/a&gt; 版本里基于 RSocket 对响应式编程提供了支持，用户可以在请求参数和返回值里使用 Mono 和 Flux 类型的对象。下面我们给出使用范例，源码可以在文末获取。&lt;/p&gt;
    
    </summary>
    
      <category term="RPC" scheme="http://lexburner.github.io/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="http://lexburner.github.io/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo2.7 三大新特性详解</title>
    <link href="http://lexburner.github.io/dubbo27-features/"/>
    <id>http://lexburner.github.io/dubbo27-features/</id>
    <published>2019-03-21T06:12:40.000Z</published>
    <updated>2019-09-26T09:45:30.083Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1 背景介绍"></a>1 背景介绍</h2><p>自 2017 年 7 月阿里重启 Dubbo 开源，到目前为止 github star 数，contributor 数都有了非常大的提升。2018 年 2 月 9 日阿里决定将 Dubbo 项目贡献给 Apache，经过一周的投票，顺利成为了 Apache 的孵化项目，也就是大家现在看到的 <strong>Incubator Dubbo</strong>。预计在 2019 年 4 月，Dubbo 可以达成毕业，成为 Apache 的顶级项目。</p><a id="more"></a><h2 id="2-分支介绍"><a href="#2-分支介绍" class="headerlink" title="2 分支介绍"></a>2 分支介绍</h2><p><img src="http://kirito.iocoder.cn/image-20190321153455566.png" alt="分支"></p><p>Dubbo 目前有如图所示的 5 个分支，其中 2.7.1-release 只是一个临时分支，忽略不计，对其他 4 个分支进行介绍。</p><ul><li>2.5.x 近期已经通过投票，Dubbo 社区即将停止对其的维护。</li><li>2.6.x 为长期支持的版本，也是 Dubbo 贡献给 Apache 之前的版本，其包名前缀为：com.alibaba，JDK 版本对应 1.6。</li><li>3.x-dev 是前瞻性的版本，对 Dubbo 进行一些高级特性的补充，如支持 rx 特性。</li><li>master 为长期支持的版本，版本号为 2.7.x，也是 Dubbo 贡献给 Apache 的开发版本，其包名前缀为：org.apache，JDK 版本对应 1.8。</li></ul><blockquote><p>如果想要研究 Dubbo 的源码，建议直接浏览 master 分支。</p></blockquote><h2 id="3-Dubbo-2-7-新特性"><a href="#3-Dubbo-2-7-新特性" class="headerlink" title="3 Dubbo 2.7 新特性"></a>3 Dubbo 2.7 新特性</h2><p>Dubbo 2.7.x 作为 Apache 的孵化版本，除了代码优化之外，还新增了许多重磅的新特性，本文将会介绍其中最典型的三个新特性：</p><ul><li>异步化改造</li><li>三大中心改造</li><li>服务治理增强</li></ul><h2 id="4-异步化改造"><a href="#4-异步化改造" class="headerlink" title="4 异步化改造"></a>4 异步化改造</h2><h3 id="4-1-几种调用方式"><a href="#4-1-几种调用方式" class="headerlink" title="4.1 几种调用方式"></a>4.1 几种调用方式</h3><p><img src="http://kirito.iocoder.cn/image-20190321160844133.png" alt="调用方式"></p><p>在远程方法调用中，大致可以分为这 4 种调用方式。oneway 指的是客户端发送消息后，不需要接受响应。对于那些不关心服务端响应的请求，比较适合使用 oneway 通信。</p><blockquote><p>注意，void hello() 方法在远程方法调用中，不属于 oneway 调用，虽然 void 方法表达了不关心返回值的语义，但在 RPC 层面，仍然需要做通信层的响应。</p></blockquote><p>sync 是最常用的通信方式，也是默认的通信方法。</p><p>future 和 callback 都属于异步调用的范畴，他们的区别是：在接收响应时，future.get() 会导致线程的阻塞;callback 通常会设置一个回调线程，当接收到响应时，自动执行，不会对当前线程造成阻塞。</p><h3 id="4-2-Dubbo-2-6-异步化"><a href="#4-2-Dubbo-2-6-异步化" class="headerlink" title="4.2 Dubbo 2.6 异步化"></a>4.2 Dubbo 2.6 异步化</h3><p>异步化的优势在于客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小。介绍 2.7 中的异步化改造之前，先回顾一下如何在 2.6 中使用 Dubbo 异步化的能力。</p><ol><li><p>将同步接口声明成 <code>async=true</code></p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"asyncService"</span> <span class="attr">interface</span>=<span class="string">"org.apache.dubbo.demo.api.AsyncService"</span> <span class="attr">async</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AsyncService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过上下文类获取 future</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AsyncService.sayHello(<span class="string">"Han Meimei"</span>);</span><br><span class="line">Future&lt;String&gt; fooFuture = RpcContext.getContext().getFuture();</span><br><span class="line">fooFuture.get();</span><br></pre></td></tr></table></figure></li></ol><p>可以看出，这样的使用方式，不太符合异步编程的习惯，竟然需要从一个上下文类中获取到 Future。如果同时进行多个异步调用，使用不当很容易造成上下文污染。而且，Future 并不支持 callback 的调用方式。这些弊端在 Dubbo 2.7 中得到了改进。</p><h3 id="4-3-Dubbo-2-7-异步化"><a href="#4-3-Dubbo-2-7-异步化" class="headerlink" title="4.3 Dubbo 2.7 异步化"></a>4.3 Dubbo 2.7 异步化</h3><ol><li><p>无需配置中特殊声明，显示声明异步接口即可</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AsyncService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> CompletableFuture&lt;String&gt; <span class="title">sayHiAsync</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(sayHello(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 callback 方式处理返回值</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = asyncService.sayHiAsync(<span class="string">"Han MeiMei"</span>);</span><br><span class="line">future.whenComplete((retValue, exception) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (exception == <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(retValue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        exception.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>Dubbo 2.7 中使用了 JDK1.8 提供的 <code>CompletableFuture</code> 原生接口对自身的异步化做了改进。<code>CompletableFuture</code> 可以支持 future 和 callback 两种调用方式，用户可以根据自己的喜好和场景选择使用，非常灵活。</p><h3 id="4-4-异步化设计-FAQ"><a href="#4-4-异步化设计-FAQ" class="headerlink" title="4.4 异步化设计 FAQ"></a>4.4 异步化设计 FAQ</h3><p>Q：如果 RPC 接口只定义了同步接口，有办法使用异步调用吗？</p><p>A：2.6 中的异步调用唯一的优势在于，不需要在接口层面做改造，又可以进行异步调用，这种方式仍然在 2.7 中保留；使用 Dubbo 官方提供的 compiler hacker，编译期自动重写同步方法，请 <a href="https://github.com/dubbo/dubbo-async-processor#compiler-hacker-processer" target="_blank" rel="noopener">在此</a> 讨论和跟进具体进展。</p><hr><p>Q：关于异步接口的设计问题，为何不提供编译插件，根据原接口，自动编译出一个 XxxAsync 接口？</p><p>A：Dubbo 2.7 采用采用过这种设计，但接口的膨胀会导致服务类的增量发布，而且接口名的变化会影响服务治理的一些相关逻辑，改为方法添加 Async 后缀相对影响范围较小。</p><hr><p>Q：Dubbo 分为了客户端异步和服务端异步，刚刚你介绍的是客户端异步，为什么不提服务端异步呢？</p><p>A：Dubbo 2.7 新增了服务端异步的支持，但实际上，Dubbo 的业务线程池模型，本身就可以理解为异步调用，个人认为服务端异步的特性较为鸡肋。</p><h2 id="5-三大中心改造"><a href="#5-三大中心改造" class="headerlink" title="5 三大中心改造"></a>5 三大中心改造</h2><p>三大中心指的：注册中心，元数据中心，配置中心。</p><p>在 2.7 之前的版本，Dubbo 只配备了注册中心，主流使用的注册中心为 zookeeper。新增加了元数据中心和配置中心，自然是为了解决对应的痛点，下面我们来详细阐释三大中心改造的原因。</p><h3 id="5-1-元数据改造"><a href="#5-1-元数据改造" class="headerlink" title="5.1 元数据改造"></a>5.1 元数据改造</h3><p>元数据是什么？元数据定义为描述数据的数据，在服务治理中，例如服务接口名，重试次数，版本号等等都可以理解为元数据。在 2.7 之前，元数据一股脑丢在了注册中心之中，这造成了一系列的问题：</p><p><strong> 推送量大 -&gt; 存储数据量大 -&gt; 网络传输量大 -&gt; 延迟严重 </strong></p><p>生产者端注册 30+ 参数，有接近一半是不需要作为注册中心进行传递；消费者端注册 25+ 参数，只有个别需要传递给注册中心。有了以上的理论分析，Dubbo 2.7 进行了大刀阔斧的改动，只将真正属于服务治理的数据发布到注册中心之中，大大降低了注册中心的负荷。</p><p>同时，将全量的元数据发布到另外的组件中：元数据中心。元数据中心目前支持 redis（推荐），zookeeper。这也为 Dubbo 2.7 全新的 Dubbo Admin 做了准备，关于新版的 Dubbo Admin，我将会后续准备一篇独立的文章进行介绍。</p><p>示例：使用 zookeeper 作为元数据中心</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:metadata-report</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-2-Dubbo-2-6-元数据"><a href="#5-2-Dubbo-2-6-元数据" class="headerlink" title="5.2 Dubbo 2.6 元数据"></a>5.2 Dubbo 2.6 元数据</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dubbo://30.5.120.185:20880/com.alibaba.dubbo.demo.DemoService?</span><br><span class="line">anyhost=true&amp;</span><br><span class="line">application=demo-provider&amp;</span><br><span class="line">interface=com.alibaba.dubbo.demo.DemoService&amp;</span><br><span class="line">methods=sayHello&amp;</span><br><span class="line">bean.name=com.alibaba.dubbo.demo.DemoService&amp;</span><br><span class="line">dubbo=2.0.2&amp;</span><br><span class="line">executes=4500&amp;</span><br><span class="line">generic=false&amp;</span><br><span class="line">owner=kirito&amp;</span><br><span class="line">pid=84228&amp;</span><br><span class="line">retries=7&amp;</span><br><span class="line">side=provider&amp;</span><br><span class="line">timestamp=1552965771067</span><br></pre></td></tr></table></figure><p>从本地的 zookeeper 中取出一条服务数据，通过解码之后，可以看出，的确有很多参数是不必要。</p><h3 id="5-3-Dubbo-2-7-元数据"><a href="#5-3-Dubbo-2-7-元数据" class="headerlink" title="5.3 Dubbo 2.7 元数据"></a>5.3 Dubbo 2.7 元数据</h3><p>在 2.7 中，如果不进行额外的配置，zookeeper 中的数据格式仍然会和 Dubbo 2.6 保持一致，这主要是为了保证兼容性，让 Dubbo 2.6 的客户端可以调用 Dubbo 2.7 的服务端。如果整体迁移到 2.7，则可以为注册中心开启简化配置的参数：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">“zookeeper://127.0.0.1:2181”</span> <span class="attr">simplified</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>Dubbo 将会只上传那些必要的服务治理数据，一个简化过后的数据如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dubbo://30.5.120.185:20880/org.apache.dubbo.demo.api.DemoService?</span><br><span class="line">application=demo-provider&amp;</span><br><span class="line">dubbo=2.0.2&amp;</span><br><span class="line">release=2.7.0&amp;</span><br><span class="line">timestamp=1552975501873</span><br></pre></td></tr></table></figure><p>对于那些非必要的服务信息，仍然全量存储在元数据中心之中：</p><p><img src="http://kirito.iocoder.cn/image-20190321175852034.png" alt="元数据"></p><blockquote><p>元数据中心的数据可以被用于服务测试，服务 MOCK 等功能。目前注册中心配置中 simplified 的默认值为 false，因为考虑到了迁移的兼容问题，在后续迭代中，默认值将会改为 true。</p></blockquote><h3 id="5-4-配置中心支持"><a href="#5-4-配置中心支持" class="headerlink" title="5.4 配置中心支持"></a>5.4 配置中心支持</h3><p>衡量配置中心的必要性往往从三个角度出发：</p><ol><li><p>分布式配置统一管理</p></li><li><p>动态变更推送</p></li><li><p>安全性</p></li></ol><p>Spring Cloud Config, Apollo, Nacos 等分布式配置中心组件都对上述功能有不同程度的支持。在 2.7 之前的版本中，在 zookeeper 中设置了部分节点：configurators，routers，用于管理部分配置和路由信息，它们可以理解为 Dubbo 配置中心的雏形。在 2.7 中，Dubbo 正式支持了配置中心，目前支持的几种注册中心 Zookeeper，Apollo，Nacos（2.7.1-release 支持）。</p><p>在 Dubbo 中，配置中心主要承担了两个作用</p><ul><li><p>外部化配置。启动配置的集中式存储</p></li><li><p>服务治理。服务治理规则的存储与通知</p></li></ul><p>示例：使用 Zookeeper 作为配置中心</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:config-center</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>引入配置中心后，需要注意配置项的覆盖问题，优先级如图所示</p><p><img src="http://kirito.iocoder.cn/configuration.jpg" alt="配置覆盖优先级"></p><h2 id="6-服务治理增强"><a href="#6-服务治理增强" class="headerlink" title="6 服务治理增强"></a>6 服务治理增强</h2><p>我更倾向于将 Dubbo 当做一个服务治理框架，而不仅仅是一个 RPC 框架。在 2.7 中，Dubbo 对其服务治理能力进行了增强，增加了标签路由的能力，并抽象出了应用路由和服务路由的概念。在最后一个特性介绍中，着重对标签路由 TagRouter 进行探讨。</p><blockquote><p> 在服务治理中，路由层和负载均衡层的对比。区别 1，Router：m 选 n，LoadBalance：n 选 1；区别 2，路由往往是叠加使用的，负载均衡只能配置一种。</p></blockquote><p>在很长的一段时间内，Dubbo 社区经常有人提的一个问题是：Dubbo 如何实现流量隔离和灰度发布，直到 2.7 提供了标签路由，用户可以使用这个功能，来实现上述的需求。</p><p><img src="http://kirito.iocoder.cn/image-20190321191620078.png" alt="标签路由"></p><p>标签路由提供了这样一个能力，当调用链路为 A -&gt; B -&gt; C -&gt; D 时，用户给请求打标，最典型的打标方式可以借助 attachment（他可以在分布式调用中传递下去），调用会优先请求那些匹配的服务端，如 A -&gt; B，C -&gt; D，由于集群中未部署 C 节点，则会降级到普通节点。</p><p>打标方式会收到集成系统差异的影响，从而导致很大的差异，所以 Dubbo 只提供了 <code>RpcContext.getContext().setAttachment()</code> 这样的基础接口，用户可以使用 SPI 扩展，或者 server filter 的扩展，对测试流量进行打标，引导进入隔离环境 / 灰度环境。</p><p>新版的 Dubbo Admin 提供了标签路由的配置项：</p><p><img src="http://kirito.iocoder.cn/image-20190321192540774.png" alt="标签路由配置"></p><p>Dubbo 用户可以在自己系统的基础上对标签路由进行二次扩展，或者借鉴标签路由的设计，实现自己系统的流量隔离，灰度发布。</p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h2><p>本文介绍了 Dubbo 2.7 比较重要的三大新特性：异步化改造，三大中心改造，服务治理增强。Dubbo 2.7 还包含了很多功能优化、特性升级，可以在项目源码的 <a href="https://github.com/apache/incubator-dubbo/blob/master/CHANGES.md" target="_blank" rel="noopener">CHANGES.md</a> 中浏览全部的改动点。最后提供一份 Dubbo 2.7 的升级文档：<a href="http://dubbo.incubator.apache.org/zh-cn/docs/user/versions/version-270.html" target="_blank" rel="noopener">2.7 迁移文档</a>，欢迎体验。</p><p><strong> 欢迎关注我的微信公众号：「Kirito 的技术分享」，关于文章的任何疑问都会得到回复，带来更多 Java 相关的技术分享。</strong></p><p><img src="http://kirito.iocoder.cn/qrcode_for_gh_c06057be7960_258%20%281%29.jpg" alt="关注微信公众号"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-背景介绍&quot;&gt;&lt;a href=&quot;#1-背景介绍&quot; class=&quot;headerlink&quot; title=&quot;1 背景介绍&quot;&gt;&lt;/a&gt;1 背景介绍&lt;/h2&gt;&lt;p&gt;自 2017 年 7 月阿里重启 Dubbo 开源，到目前为止 github star 数，contributor 数都有了非常大的提升。2018 年 2 月 9 日阿里决定将 Dubbo 项目贡献给 Apache，经过一周的投票，顺利成为了 Apache 的孵化项目，也就是大家现在看到的 &lt;strong&gt;Incubator Dubbo&lt;/strong&gt;。预计在 2019 年 4 月，Dubbo 可以达成毕业，成为 Apache 的顶级项目。&lt;/p&gt;
    
    </summary>
    
      <category term="RPC" scheme="http://lexburner.github.io/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="http://lexburner.github.io/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>一文探讨堆外内存的监控与回收</title>
    <link href="http://lexburner.github.io/nio-buffer-recycle/"/>
    <id>http://lexburner.github.io/nio-buffer-recycle/</id>
    <published>2019-03-17T06:12:40.000Z</published>
    <updated>2019-09-26T09:45:30.702Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>记得那是一个风和日丽的周末，太阳红彤彤，花儿五颜六色，96 年的普哥微信找到我，描述了一个诡异的线上问题：线上程序使用了 NIO FileChannel 的 堆内内存（HeapByteBuffer）作为缓冲区，读写文件，逻辑可以说相当简单，但根据监控，却发现堆外内存（DirectByteBuffer）飙升，导致了 OutOfMemeory 的异常。</p><p>由这个线上问题，引出了这篇文章的主题，主要包括：FileChannel 源码分析，堆外内存监控，堆外内存回收。</p><a id="more"></a><h2 id="问题分析-amp-源码分析"><a href="#问题分析-amp-源码分析" class="headerlink" title="问题分析 &amp; 源码分析"></a>问题分析 &amp; 源码分析</h2><p>根据异常日志的定位，发现的确使用的是 HeapByteBuffer 来进行读写，但却导致堆外内存飙升，随即翻了 FileChannel 的源码，来一探究竟。</p><p>FileChannel 使用的是 IOUtil 进行读写操作（本文只分析读的逻辑，写和读的代码逻辑一致，不做重复分析）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.nio.ch.IOUtil#read</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(FileDescriptor var0, ByteBuffer var1, <span class="keyword">long</span> var2, NativeDispatcher var4)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (var1.isReadOnly()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Read-only buffer"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> DirectBuffer) &#123;</span><br><span class="line">        <span class="keyword">return</span> readIntoNativeBuffer(var0, var1, var2, var4);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ByteBuffer var5 = Util.getTemporaryDirectBuffer(var1.remaining());</span><br><span class="line">        <span class="keyword">int</span> var7;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> var6 = readIntoNativeBuffer(var0, var5, var2, var4);</span><br><span class="line">            var5.flip();</span><br><span class="line">            <span class="keyword">if</span> (var6 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                var1.put(var5);</span><br><span class="line">            &#125;</span><br><span class="line">            var7 = var6;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Util.offerFirstTemporaryDirectBuffer(var5);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> var7;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现当使用 HeapByteBuffer 时，会走到下面这行看似有点疑问的代码分支：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Util.getTemporaryDirectBuffer(var1.remaining());</span><br></pre></td></tr></table></figure><p>这个 Util 封装了更为底层的一些 IO 逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sun.nio.ch;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Util</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Util.BufferCache&gt; bufferCache;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">getTemporaryDirectBuffer</span><span class="params">(<span class="keyword">int</span> var0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isBufferTooLarge(var0)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ByteBuffer.allocateDirect(var0);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// FOUCS ON THIS LINE</span></span><br><span class="line">            Util.BufferCache var1 = (Util.BufferCache)bufferCache.get();</span><br><span class="line">            ByteBuffer var2 = var1.get(var0);</span><br><span class="line">            <span class="keyword">if</span> (var2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> var2;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!var1.isEmpty()) &#123;</span><br><span class="line">                    var2 = var1.removeFirst();</span><br><span class="line">                    free(var2);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> ByteBuffer.allocateDirect(var0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>isBufferTooLarge 这个方法会根据传入 Buffer 的大小决定如何分配堆外内存，如果过大，直接分配大缓冲区；如果不是太大，会使用 bufferCache 这个 ThreadLocal 变量来进行缓存，从而复用（实际上这个数值非常大，几乎不会走进直接分配堆外内存这个分支）。这么看来似乎发现了两个不得了的结论：</p><ol><li>使用 HeapByteBuffer 读写都会经过 DirectByteBuffer，写入数据的流转方式其实是：HeapByteBuffer -&gt; DirectByteBuffer -&gt; PageCache -&gt; Disk，读取数据的流转方式正好相反。</li><li>使用 HeapByteBuffer 读写会申请一块跟线程绑定的 DirectByteBuffer。这意味着，线程越多，临时 DirectByteBuffer 就越会占用越多的空间。</li></ol><p>看到这儿，线上的问题似乎有了一点眉目：很有可能是多线程使用 HeapByteBuffer 写入文件，而额外分配的这块 DirectByteBuffer 导致了内存溢出。在验证这个猜测之前，我们最好能直观地监控到堆外内存的使用量，这才能增加我们定位问题的信心。</p><h2 id="实现堆外内存的监控"><a href="#实现堆外内存的监控" class="headerlink" title="实现堆外内存的监控"></a>实现堆外内存的监控</h2><p>JDK 提供了一个非常好用的监控工具 —— Java VisualVM。我们只需要为它安装一个插件，即可很方便地实现堆外内存的监控。</p><p>进入本地 JDK 的可执行目录（在我本地是：/Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/bin），找到 jvisualvm 命令，双击打开一个可视化的界面</p><p><img src="http://kirito.iocoder.cn/image-20190315193955214.png" alt="jvisualVM 主界面"></p><p>左侧树状目录可以选择需要监控的 Java 进程，右侧是监控的维度信息，除了 CPU、线程、堆、类等信息，还可以通过上方的【工具 (T)】 安装插件，增加 MBeans、Buffer Pools 等维度的监控。</p><p><img src="http://kirito.iocoder.cn/image-20190315194046726.png" alt="jvisualVM 插件"></p><p>Buffer Pools 插件可以监控堆外内存（包含 DirectByteBuffer 和 MappedByteBuffer），如下图所示：</p><p><img src="http://kirito.iocoder.cn/image-20190315194327416.png" alt="image-20190315194327416"></p><p>左侧对应 DirectByteBuffer，右侧对应 MappedByteBuffer。</p><h2 id="复现问题"><a href="#复现问题" class="headerlink" title="复现问题"></a>复现问题</h2><p>为了复现线上的问题，我们使用一个程序，不断开启线程使用堆内内存作为缓冲区进行文件的读取操作，并监控该进程的堆外内存使用情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadByHeapByteBufferTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        File data = <span class="keyword">new</span> File(<span class="string">"/tmp/data.txt"</span>);</span><br><span class="line">        FileChannel fileChannel = <span class="keyword">new</span> RandomAccessFile(data, <span class="string">"rw"</span>).getChannel();</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        fileChannel.read(buffer);</span><br><span class="line">                        buffer.clear();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行一段时间后，我们观察下堆外内存的使用情况</p><p><img src="http://kirito.iocoder.cn/image-20190315194712532.png" alt="image-20190315194712532"></p><p>如上图左所示，堆外内存的确开始疯涨了，的确符合我们的预期，堆外缓存和线程绑定，当线程非常多时，即使只使用了 4M 的堆内内存，也可能会造成极大的堆外内存膨胀，在中间发生了一次断崖，推测是线程执行完毕 or GC，导致了内存的释放。</p><p>知晓了这一点，相信大家今后使用堆内内存时可能就会更加注意了，我总结了两个注意点：</p><ol><li>使用 HeapByteBuffer 还需要经过一次 DirectByteBuffer 的拷贝，在追求极致性能的场景下是可以通过直接复用堆外内存来避免的。</li><li>多线程下使用 HeapByteBuffer 进行文件读写，要注意 <code>ThreadLocal&lt;Util.BufferCache&gt; bufferCache</code> 导致的堆外内存膨胀的问题。</li></ol><h2 id="问题深究"><a href="#问题深究" class="headerlink" title="问题深究"></a>问题深究</h2><p>那大家有没有想过，为什么 JDK 要如此设计？为什么不直接使用堆内内存写入 PageCache 进而落盘呢？为什么一定要经过 DirectByteBuffer 的拷贝呢？</p><p>在知乎的相关问题中，R 大和 <a href="https://www.zhihu.com/people/zeng-ze-tang" target="_blank" rel="noopener">曾泽堂</a> 两位同学进行了解答，是我比较认同的解释：</p><blockquote><p>作者：RednaxelaFX</p><p>链接：<a href="https://www.zhihu.com/question/57374068/answer/152691891" target="_blank" rel="noopener">https://www.zhihu.com/question/57374068/answer/152691891</a></p><p>来源：知乎</p><p>这里其实是在迁就 OpenJDK 里的 HotSpot VM 的一点实现细节。</p><p>HotSpot VM 里的 GC 除了 CMS 之外都是要移动对象的，是所谓“compacting GC”。</p><p>如果要把一个 Java 里的 byte[] 对象的引用传给 native 代码，让 native 代码直接访问数组的内容的话，就必须要保证 native 代码在访问的时候这个 byte[] 对象不能被移动，也就是要被“pin”（钉）住。</p><p>可惜 HotSpot VM 出于一些取舍而决定不实现单个对象层面的 object pinning，要 pin 的话就得暂时禁用 GC——也就等于把整个 Java 堆都给 pin 住。</p><p>所以 Oracle/Sun JDK / OpenJDK 的这个地方就用了点绕弯的做法。它假设把 HeapByteBuffer 背后的 byte[] 里的内容拷贝一次是一个时间开销可以接受的操作，同时假设真正的 I/O 可能是一个很慢的操作。</p><p>于是它就先把 HeapByteBuffer 背后的 byte[] 的内容拷贝到一个 DirectByteBuffer 背后的 native memory 去，这个拷贝会涉及 sun.misc.Unsafe.copyMemory() 的调用，背后是类似 memcpy() 的实现。这个操作本质上是会在整个拷贝过程中暂时不允许发生 GC 的。</p><p>然后数据被拷贝到 native memory 之后就好办了，就去做真正的 I/O，把 DirectByteBuffer 背后的 native memory 地址传给真正做 I/O 的函数。这边就不需要再去访问 Java 对象去读写要做 I/O 的数据了。</p></blockquote><p>总结一下就是：</p><ul><li>为了方便 GC 的实现，DirectByteBuffer 指向的 native memory 是不受 GC 管辖的</li><li>HeapByteBuffer 背后使用的是 byte 数组，其占用的内存不一定是连续的，不太方便 JNI 方法的调用</li><li>数组实现在不同 JVM 中可能会不同</li></ul><h2 id="堆外内存的回收"><a href="#堆外内存的回收" class="headerlink" title="堆外内存的回收"></a>堆外内存的回收</h2><p>继续深究下一个话题，也是我的微信交流群中曾经有人提出过的一个疑问，到底该如何回收 DirectByteBuffer？既然可以监控堆外内存，那验证堆外内存的回收就变得很容易实现了。</p><p><strong>CASE 1</strong>：分配 1G 的 DirectByteBuffer，等待用户输入后，复制为 null，之后阻塞持续观察堆外内存变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteByDirectByteBufferTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">        buffer = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>).await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://kirito.iocoder.cn/image-20190315201608522.png" alt="image-20190315201608522"></p><p>结论：变量虽然置为了 null，但内存依旧持续占用。</p><p><strong>CASE 2</strong>：分配 1G DirectByteBuffer，等待用户输入后，复制为 null，手动触发 GC，之后阻塞持续观察堆外内存变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteByDirectByteBufferTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">        buffer = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>).await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://kirito.iocoder.cn/image-20190315201756266.png" alt="GC"></p><p>结论：GC 时会触发堆外空闲内存的回收。</p><p><strong>CASE 3</strong>：分配 1G DirectByteBuffer，等待用户输入后，手动回收堆外内存，之后阻塞持续观察堆外内存变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteByDirectByteBufferTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">        ((DirectBuffer) buffer).cleaner().clean();</span><br><span class="line">        <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>).await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://kirito.iocoder.cn/image-20190315201756266.png" alt="手动回收"></p><p>结论：手动回收可以立刻释放堆外内存，不需要等待到 GC 的发生。</p><blockquote><p>对于 MappedByteBuffer 这个有点神秘的类，它的回收机制大概和 DirectByteBuffer 类似，体现在右边的 Mapped 之中，我们就不重复 CASE1 和 CASE2 的测试了，直接给出结论，在 GC 发生或者操作系统主动清理时 MappedByteBuffer 会被回收。但也不是不进行测试，我们会对 MappedByteBuffer 进行更有意思的研究。</p></blockquote><p><strong>CASE 4</strong>：手动回收 MappedByteBuffer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MmapUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">(MappedByteBuffer mappedByteBuffer)</span> </span>&#123;</span><br><span class="line">        ByteBuffer buffer = mappedByteBuffer;</span><br><span class="line">        <span class="keyword">if</span> (buffer == <span class="keyword">null</span> || !buffer.isDirect() || buffer.capacity()== <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        invoke(invoke(viewed(buffer), <span class="string">"cleaner"</span>), <span class="string">"clean"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> Object target, <span class="keyword">final</span> String methodName, <span class="keyword">final</span> Class&lt;?&gt;... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Method method = method(target, methodName, args);</span><br><span class="line">                    method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> method.invoke(target);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Method <span class="title">method</span><span class="params">(Object target, String methodName, Class&lt;?&gt;[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> target.getClass().getMethod(methodName, args);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> target.getClass().getDeclaredMethod(methodName, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ByteBuffer <span class="title">viewed</span><span class="params">(ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">        String methodName = <span class="string">"viewedBuffer"</span>;</span><br><span class="line">        Method[] methods = buffer.getClass().getMethods();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (methods[i].getName().equals(<span class="string">"attachment"</span>)) &#123;</span><br><span class="line">                methodName = <span class="string">"attachment"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ByteBuffer viewedBuffer = (ByteBuffer) invoke(buffer, methodName);</span><br><span class="line">        <span class="keyword">if</span> (viewedBuffer == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> buffer;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> viewed(viewedBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类曾经在我的《文件 IO 的一些最佳实践》中有所介绍，在这里我们将验证它的作用。编写测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteByMappedByteBufferTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        File data = <span class="keyword">new</span> File(<span class="string">"/tmp/data.txt"</span>);</span><br><span class="line">        data.createNewFile();</span><br><span class="line">        FileChannel fileChannel = <span class="keyword">new</span> RandomAccessFile(data, <span class="string">"rw"</span>).getChannel();</span><br><span class="line">        MappedByteBuffer map = fileChannel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">1024L</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">        MmapUtil.clean(map);</span><br><span class="line">        <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>).await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://kirito.iocoder.cn/image-20190315203424823.png" alt="mmap 手动回收"></p><p>结论：通过一顿复杂的反射操作，成功地手动回收了 Mmap 的内存映射。</p><p><strong>CASE 5</strong>：测试 Mmap 的内存占用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteByMappedByteBufferTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        File data = <span class="keyword">new</span> File(<span class="string">"/tmp/data.txt"</span>);</span><br><span class="line">        data.createNewFile();</span><br><span class="line">        FileChannel fileChannel = <span class="keyword">new</span> RandomAccessFile(data, <span class="string">"rw"</span>).getChannel();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            fileChannel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">1024L</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"map finish"</span>);</span><br><span class="line">        <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>).await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我尝试映射了 1000G 的内存，我的电脑显然没有 1000G 这么大内存，那么监控是如何反馈的呢？</p><p><img src="http://kirito.iocoder.cn/image-20190315203835758.png" alt="mmap 映射 1000G"></p><p>几乎在瞬间，控制台打印出了 map finish 的日志，也意味着 1000G 的内存映射几乎是不耗费时间的，为什么要做这个测试？就是为了解释内存映射并不等于内存占用，很多文章认为内存映射这种方式可以大幅度提升文件的读写速度，并宣称“写 MappedByteBuffer 就等于写内存”，实际是非常错误的认知。通过控制面板可以查看到该 Java 进程（pid 39040）实际占用的内存，仅仅不到 100M。(关于 Mmap 的使用场景和方式可以参考我之前的文章)</p><p><img src="http://kirito.iocoder.cn/image-20190315204304382.png" alt="实际消耗内存"></p><p>结论：MappedByteBuffer 映射出一片文件内容之后，不会全部加载到内存中，而是会进行一部分的预读（体现在占用的那 100M 上），MappedByteBuffer 不是文件读写的银弹，它仍然依赖于 PageCache 异步刷盘的机制。<strong> 通过 Java VisualVM 可以监控到 mmap 总映射的大小，但并不是实际占用的内存量 </strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文借助一个线上问题，分析了使用堆内内存仍然会导致堆外内存分析的现象以及背后 JDK 如此设计的原因，并借助安装了插件之后的 Java VisualVM 工具进行了堆外内存的监控，进而讨论了如何正确的回收堆外内存，以及纠正了一个关于 MappedByteBuffer 的错误认知。</p><p><strong> 欢迎关注我的微信公众号：「Kirito 的技术分享」，关于文章的任何疑问都会得到回复，带来更多 Java 相关的技术分享。</strong></p><p><img src="http://kirito.iocoder.cn/qrcode_for_gh_c06057be7960_258%20%281%29.jpg" alt="关注微信公众号"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;记得那是一个风和日丽的周末，太阳红彤彤，花儿五颜六色，96 年的普哥微信找到我，描述了一个诡异的线上问题：线上程序使用了 NIO FileChannel 的 堆内内存（HeapByteBuffer）作为缓冲区，读写文件，逻辑可以说相当简单，但根据监控，却发现堆外内存（DirectByteBuffer）飙升，导致了 OutOfMemeory 的异常。&lt;/p&gt;
&lt;p&gt;由这个线上问题，引出了这篇文章的主题，主要包括：FileChannel 源码分析，堆外内存监控，堆外内存回收。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://lexburner.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="文件 IO" scheme="http://lexburner.github.io/tags/%E6%96%87%E4%BB%B6-IO/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo 的前世今生 &amp; Dubbo Meetup 南京</title>
    <link href="http://lexburner.github.io/dubbo-meetup-nj/"/>
    <id>http://lexburner.github.io/dubbo-meetup-nj/</id>
    <published>2019-03-08T06:12:40.000Z</published>
    <updated>2019-09-26T09:45:30.305Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Dubbo-的前世今生"><a href="#Dubbo-的前世今生" class="headerlink" title="Dubbo 的前世今生"></a>Dubbo 的前世今生</h3><p>2011 年 10 月 27 日，阿里巴巴开源了自己的 SOA 服务化治理方案的核心框架 Dubbo，服务治理和 SOA 的设计理念开始逐渐在国内软件行业中落地，并被广泛应用。自开源后，许多非阿里系公司选择使用 Dubbo，其中既有当当网、网易考拉等互联网公司，也有中国人寿、青岛海尔等传统企业。</p><a id="more"></a><p>2012 年 10 月 23 日 Dubbo 2.5.3 发布后，在 Dubbo 开源将满一周年之际，阿里基本停止了对 Dubbo 的主要升级。</p><p>2013 年，2014 年，更新了 2 次 Dubbo 2.4 的维护版本，然后停止了所有维护工作。至此，Dubbo 对 Srping 的支持也停留在了 Spring 2.5.6 版本上。</p><p>阿里停止维护和升级 Dubbo 期间，当当网开始维护自己的 Dubbo 分支版本 Dubbox，新增支持了新版本的 Spring，支持了 Rest 协议等，并对外开源了 Dubbox。同时，网易考拉也维护了自己的独立分支 Dubbok，可惜并未对外开源。</p><p>2017 年 9 月 7 日，Dubbo 悄悄在 GitHub 发布了 2.5.4 版本。随后，又迅速发布了 2.5.5、2.5.6、2.5.7 等版本。在 10 月举行的云栖大会上，阿里宣布 Dubbo 被列入集团重点维护开源项目，这也就意味着 Dubbo 起死回生，开始重新进入快车道。</p><p>2018 年 1 月 8 日，Dubbo 2.6.0 版本发布，新版本将之前当当网开源的 Dubbox 进行了合并，实现了 Dubbo 版本的统一整合。</p><p>2018 年 2 月 9 日，Apache 基金会的邮件列表上发起了讨论是否接纳阿里的 Dubbo 项目进入 Apache 孵化器的投票。经过一周的投票，邮件列表显示，Dubbo 获得了 14 张赞成票，在无弃权和反对票的情况下，正式通过投票，顺利成为 Apache 基金会孵化项目。</p><p>自此，Dubbo 开始了两个长期维护的版本，Dubbo 2.6.x （包名：com.alibaba）稳定维护版本和 Dubbo 2.7.x （包名：org.apache）apache 孵化版本。</p><p>2018 ~ 2019 年，在此期间，Dubbo 发布了 4、5 个版本，并发布了 nodejs，python，go 等多语言的客户端。在此期间，Dubbo 社区相继在北京、上海、深圳、成都、杭州等地举办了开发者沙龙。</p><p>2019 年 1 月，2.7.0 release 版本发布，这个即将毕业的 apache 版本支持了丰富的新特性，全新的 Dubbo Ops 控制台。</p><h3 id="报名-Dubbo-Meetup-南京"><a href="#报名-Dubbo-Meetup-南京" class="headerlink" title="报名 | Dubbo Meetup 南京"></a>报名 | Dubbo Meetup 南京</h3><p><img src="http://kirito.iocoder.cn/640.jpeg" alt="meetup"></p><p><strong> 欢迎关注我的微信公众号：「Kirito 的技术分享」，关于文章的任何疑问都会得到回复，带来更多 Java 相关的技术分享。</strong></p><p><img src="http://kirito.iocoder.cn/qrcode_for_gh_c06057be7960_258%20%281%29.jpg" alt="关注微信公众号"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Dubbo-的前世今生&quot;&gt;&lt;a href=&quot;#Dubbo-的前世今生&quot; class=&quot;headerlink&quot; title=&quot;Dubbo 的前世今生&quot;&gt;&lt;/a&gt;Dubbo 的前世今生&lt;/h3&gt;&lt;p&gt;2011 年 10 月 27 日，阿里巴巴开源了自己的 SOA 服务化治理方案的核心框架 Dubbo，服务治理和 SOA 的设计理念开始逐渐在国内软件行业中落地，并被广泛应用。自开源后，许多非阿里系公司选择使用 Dubbo，其中既有当当网、网易考拉等互联网公司，也有中国人寿、青岛海尔等传统企业。&lt;/p&gt;
    
    </summary>
    
      <category term="技术杂谈" scheme="http://lexburner.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="Dubbo" scheme="http://lexburner.github.io/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Java 文件 IO 操作之 DirectIO</title>
    <link href="http://lexburner.github.io/direct-io/"/>
    <id>http://lexburner.github.io/direct-io/</id>
    <published>2019-03-02T07:45:13.000Z</published>
    <updated>2019-09-26T09:46:40.510Z</updated>
    
    <content type="html"><![CDATA[<p>在前文《文件 IO 操作的一些最佳实践》中，我介绍了一些 Java 中常见的文件操作的接口，并且就 PageCache 和 DIrect IO 进行了探讨，最近我自己封装了一个 Direct IO 的库，趁着这个机会，本文重点谈谈 Java 中 Direct IO 的意义，以及简单介绍下我自己的轮子。</p><a id="more"></a><h3 id="Java-中的-Direct-IO"><a href="#Java-中的-Direct-IO" class="headerlink" title="Java 中的 Direct IO"></a>Java 中的 Direct IO</h3><p>如果你阅读过我之前的文章，应该已经了解 Java 中常用的文件操作接口为：FileChannel，并且没有直接操作 Direct IO 的接口。这也就意味着 Java 无法绕开 PageCache 直接对存储设备进行读写，但对于使用 Java 语言来编写的数据库，消息队列等产品而言，的确存在绕开 PageCache 的需求：</p><ul><li>PageCache 属于操作系统层面的概念，用户层面很难干预，User BufferCache 显然比 Kernel PageCache 要可控</li><li>现代操作系统会使用尽可能多的空闲内存来充当 PageCache，当操作系统回收 PageCache 内存的速度低于应用写缓存的速度时，会影响磁盘写入的速率，直接表现为写入 RT 增大，这被称之为“毛刺现象”</li></ul><p>PageCache 可能会好心办坏事，采用 Direct IO + 自定义内存管理机制会使得产品更加的可控，高性能。</p><h3 id="Direct-IO-的限制"><a href="#Direct-IO-的限制" class="headerlink" title="Direct IO 的限制"></a>Direct IO 的限制</h3><p>在 Java 中使用 Direct IO 最终需要调用到 c 语言的 pwrite 接口，并设置 O_DIRECT flag，使用 O_DIRECT 存在不少限制</p><ul><li>操作系统限制：Linux 操作系统在 2.4.10 及以后的版本中支持 O_DIRECT flag，老版本会忽略该 Flag；Mac OS 也有类似于 O_DIRECT 的机制</li><li>用于传递数据的缓冲区，其内存边界必须对齐为 blockSize 的整数倍</li><li>用于传递数据的缓冲区，其传递数据的大小必须是 blockSize 的整数倍。</li><li>数据传输的开始点，即文件和设备的偏移量，必须是 blockSize 的整数倍</li></ul><blockquote><p>查看系统 blockSize 大小的方式：stat /boot/|grep “IO Block”</p><p>ubuntu@VM-30-130-ubuntu:~$ stat /boot/|grep “IO Block”<br>  Size: 4096            Blocks: 8          IO Block: 4096   directory</p><p>通常为 4kb</p></blockquote><h3 id="Java-使用-Direct-IO"><a href="#Java-使用-Direct-IO" class="headerlink" title="Java 使用 Direct IO"></a>Java 使用 Direct IO</h3><h4 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h4><p><a href="https://github.com/lexburner/kdio" target="_blank" rel="noopener">https://github.com/lexburner/kdio</a></p><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>moe.cnkirito.kdio<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kdio-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file path should be specific since the different file path determine whether your system support direct io</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> DirectIOLib directIOLib = DirectIOLib.getLibForPath(<span class="string">"/"</span>);</span><br><span class="line"><span class="comment">// you should always write into your disk the Integer-Multiple of block size through direct io.</span></span><br><span class="line"><span class="comment">// in most system, the block size is 4kb</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BLOCK_SIZE = <span class="number">4</span> * <span class="number">1024</span>;</span><br></pre></td></tr></table></figure><h4 id="Direct-IO-写"><a href="#Direct-IO-写" class="headerlink" title="Direct IO 写"></a>Direct IO 写</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DirectIOLib.binit) &#123;</span><br><span class="line">        ByteBuffer byteBuffer = DirectIOUtils.allocateForDirectIO(directIOLib, <span class="number">4</span> * BLOCK_SIZE);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BLOCK_SIZE; i++) &#123;</span><br><span class="line">            byteBuffer.putInt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        DirectRandomAccessFile directRandomAccessFile = <span class="keyword">new</span> DirectRandomAccessFile(<span class="keyword">new</span> File(<span class="string">"./database.data"</span>), <span class="string">"rw"</span>);</span><br><span class="line">        directRandomAccessFile.write(byteBuffer, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"your system do not support direct io"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Direct-IO-读"><a href="#Direct-IO-读" class="headerlink" title="Direct IO 读"></a>Direct IO 读</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DirectIOLib.binit) &#123;</span><br><span class="line">        ByteBuffer byteBuffer = DirectIOUtils.allocateForDirectIO(directIOLib, <span class="number">4</span> * BLOCK_SIZE);</span><br><span class="line">        DirectRandomAccessFile directRandomAccessFile = <span class="keyword">new</span> DirectRandomAccessFile(<span class="keyword">new</span> File(<span class="string">"./database.data"</span>), <span class="string">"rw"</span>);</span><br><span class="line">        directRandomAccessFile.read(byteBuffer, <span class="number">0</span>);</span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BLOCK_SIZE; i++) &#123;</span><br><span class="line">            System.out.print(byteBuffer.getInt() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"your system do not support direct io"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="主要-API"><a href="#主要-API" class="headerlink" title="主要 API"></a>主要 API</h4><ol><li><code>DirectIOLib.java</code> 提供 Native 的 pwrite 和 pread</li><li><code>DirectIOUtils.java</code> 提供工具类方法，比如分配 Block 对齐的 ByteBuffer</li><li><code>DirectChannel/DirectChannelImpl.java</code> 提供对 fd 的 Direct 包装，提供类似 <code>FileChannel</code> 的读写 API。</li><li><code>DirectRandomAccessFile.java</code> 通过 DIO 的方式打开文件，并暴露 IO 接口。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个简单的 Direct IO 框架参考了 <a href="https://github.com/smacke/jaydio" target="_blank" rel="noopener">smacke/jaydio</a>，这个库自己搞了一套 Buffer 接口跟 JDK 的类库不兼容，且读写实现里面加了一块 Buffer 用于缓存内容至 Block 对齐有点破坏 Direct IO 的语义。同时，感谢尘央同学的指导，这个小轮子的代码量并不多，初始代码引用自他的一个小 demo（已获得本人授权）。为什么需要这么一个库？主要是考虑后续会出现像「中间件性能挑战赛」和「PolarDB 性能挑战赛」这样的比赛，Java 本身的 API 可能不足以发挥其优势，如果有一个库可以屏蔽掉 Java 和 CPP 选手的差距，岂不是美哉？我也将这个库发到了中央仓库，方便大家在自己的代码中引用。</p><p>后续会视需求，会这个小小的轮子增加注入 fadvise，mmap 等系统调用的映射，也欢迎对文件操作感兴趣的同学一起参与进来，pull request &amp; issue are welcome！</p><h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><p><a href="https://www.cnkirito.moe/file-io-best-practise/" target="_blank" rel="noopener">《文件 IO 操作的一些最佳实践》</a></p><p><a href="https://www.cnkirito.moe/polardb-race/" target="_blank" rel="noopener">《PolarDB 数据库性能大赛 Java 选手分享》</a></p><p><strong>欢迎关注我的微信公众号：「Kirito 的技术分享」，关于文章的任何疑问都会得到回复，带来更多 Java 相关的技术分享。</strong></p><p><img src="http://kirito.iocoder.cn/qrcode_for_gh_c06057be7960_258%20%281%29.jpg" alt="关注微信公众号"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前文《文件 IO 操作的一些最佳实践》中，我介绍了一些 Java 中常见的文件操作的接口，并且就 PageCache 和 DIrect IO 进行了探讨，最近我自己封装了一个 Direct IO 的库，趁着这个机会，本文重点谈谈 Java 中 Direct IO 的意义，以及简单介绍下我自己的轮子。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://lexburner.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="DirectIO" scheme="http://lexburner.github.io/tags/DirectIO/"/>
    
      <category term="JNA" scheme="http://lexburner.github.io/tags/JNA/"/>
    
  </entry>
  
  <entry>
    <title>一致性哈希负载均衡算法的探讨</title>
    <link href="http://lexburner.github.io/consistent-hash-lb/"/>
    <id>http://lexburner.github.io/consistent-hash-lb/</id>
    <published>2019-02-15T07:45:13.000Z</published>
    <updated>2019-09-26T09:45:30.947Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一致性哈希算法在很多领域有应用，例如分布式缓存领域的 MemCache，Redis，负载均衡领域的 Nginx，各类 RPC 框架。不同领域场景不同，需要顾及的因素也有所差异，本文主要讨论在 <strong> 负载均衡 </strong> 中一致性哈希算法的设计。</p><p>在介绍一致性哈希算法之前，我将会介绍一些哈希算法，讨论它们的区别和使用场景。也会给出一致性哈希算法的 Java 通用实现，可以直接引用，文末会给出 github 地址。</p><blockquote><p>友情提示：阅读本文前，最好对一致性哈希算法有所了解，例如你最好听过一致性哈希环这个概念，我会在基本概念上缩短篇幅。</p></blockquote><a id="more"></a><h3 id="一致性哈希负载均衡介绍"><a href="#一致性哈希负载均衡介绍" class="headerlink" title="一致性哈希负载均衡介绍"></a>一致性哈希负载均衡介绍</h3><p>负载均衡这个概念可以抽象为：从 n 个候选服务器中选择一个进行通信的过程。负载均衡算法有多种多样的实现方式：随机、轮询、最小负载优先等，其中也包括了今天的主角：一致性哈希负载均衡。一致性哈希负载均衡需要保证的是“相同的请求尽可能落到同一个服务器上”，注意这短短的一句描述，却包含了相当大的信息量。“相同的请求” — 什么是相同的请求？一般在使用一致性哈希负载均衡时，需要指定一个 key 用于 hash 计算，可能是：</p><ol><li>请求方 IP</li><li>请求服务名称，参数列表构成的串</li><li>用户 ID</li></ol><p>“尽可能” —为什么不是一定？因为服务器可能发生上下线，所以少数服务器的变化不应该影响大多数的请求。这也呼应了算法名称中的“一致性”。</p><p>同时，一个优秀的负载均衡算法还有一个隐性要求：流量尽可能均匀分布。</p><p>综上所述，我们可以概括出一致性哈希负载均衡算法的设计思路。</p><ul><li>尽可能保证每个服务器节点均匀的分摊流量</li><li>尽可能保证服务器节点的上下线不影响流量的变更</li></ul><h3 id="哈希算法介绍"><a href="#哈希算法介绍" class="headerlink" title="哈希算法介绍"></a>哈希算法介绍</h3><p>哈希算法是一致性哈希算法中重要的一个组成部分，你可以借助 Java 中的 <code>int hashCode()</code> 去理解它。 说到哈希算法，你想到了什么？Jdk 中的 hashCode、SHA-1、MD5，除了这些耳熟能详的哈希算法，还存在很多其他实现，详见 <a href="https://www.oschina.net/translate/state-of-hash-functions" target="_blank" rel="noopener">HASH 算法一览</a>。可以将他们分成三代：</p><ul><li>第一代：SHA-1（1993），MD5（1992），CRC（1975），Lookup3（2006）</li><li>第二代：MurmurHash（2008）</li><li>第三代：CityHash， SpookyHash（2011）</li></ul><p>这些都可以认为是广义上的哈希算法，你可以在 <a href="https://en.wikipedia.org/wiki/List_of_hash_functions" target="_blank" rel="noopener">wiki 百科</a> 中查看所有的哈希算法。当然还有一些哈希算法如：Ketama，专门为一致性哈希算法而设计。</p><p>既然有这么多哈希算法，那必然会有人问：当我们在讨论哈希算法时，我们再考虑哪些东西？我大概总结下有以下四点：</p><ol><li>实现复杂程度</li><li>分布均匀程度</li><li>哈希碰撞概率</li><li>性能</li></ol><p>先聊聊性能，是不是性能越高就越好呢？你如果有看过我曾经的文章 <a href="https://www.cnkirito.moe/spring-security-6/" target="_blank" rel="noopener">《该如何设计你的 PasswordEncoder?》</a> ，应该能了解到，在设计加密器这个场景下，慢 hash 算法反而有优势；而在负载均衡这个场景下，安全性不是需要考虑的因素，所以性能自然是越高越好。</p><p>优秀的算法通常比较复杂，但不足以构成评价标准，有点黑猫白猫论，所以 2，3 两点：分布均匀程度，哈希碰撞概率成了主要考虑的因素。</p><p>我挑选了几个值得介绍的哈希算法，重点介绍下。</p><ol><li><p>MurmurHash 算法：高运算性能，低碰撞率，由 Austin Appleby 创建于 2008 年，现已应用到 Hadoop、libstdc++、nginx、libmemcached 等开源系统。2011 年 Appleby 被 Google 雇佣，随后 Google 推出其变种的 CityHash 算法。官方只提供了 C 语言的实现版本。 </p><p>Java 界中 Redis，Memcached，Cassandra，HBase，Lucene 都在使用它。</p><p>在 Java 的实现，Guava 的 Hashing 类里有，上面提到的 Jedis，Cassandra 里都有相关的 Util 类。</p></li><li><p>FNV 算法：全名为 Fowler-Noll-Vo 算法，是以三位发明人 Glenn Fowler，Landon Curt Noll，Phong Vo 的名字来命名的，最早在 1991 年提出。</p><p>特点和用途：FNV 能快速 hash 大量数据并保持较小的冲突率，它的高度分散使它适用于 hash 一些非常相近的字符串，比如 URL，hostname，文件名，text，IP 地址等。</p></li><li><p>Ketama 算法：将它称之为哈希算法其实不太准确，称之为一致性哈希算法可能更为合适，其他的哈希算法有通用的一致性哈希算法实现，只不过是替换了哈希方式而已，但 Ketama 是一整套的流程，我们将在后面介绍。</p></li></ol><p>以上三者都是最合适的一致性哈希算法的强力争夺者。</p><h3 id="一致性哈希算法实现"><a href="#一致性哈希算法实现" class="headerlink" title="一致性哈希算法实现"></a>一致性哈希算法实现</h3><p><img src="https://user-gold-cdn.xitu.io/2019/2/16/168f69205ef99590?w=861&amp;h=635&amp;f=png&amp;s=59703" alt="一致性 hash"></p><p>一致性哈希的概念我不做赘述，简单介绍下这个负载均衡中的一致性哈希环。首先将服务器（ip+ 端口号）进行哈希，映射成环上的一个节点，在请求到来时，根据指定的 hash key 同样映射到环上，并顺时针选取最近的一个服务器节点进行请求（在本图中，使用的是 userId 作为 hash key）。</p><p>当环上的服务器较少时，即使哈希算法选择得当，依旧会遇到大量请求落到同一个节点的问题，为避免这样的问题，大多数一致性哈希算法的实现度引入了虚拟节点的概念。</p><p><img src="https://user-gold-cdn.xitu.io/2019/2/16/168f6921775875f4?w=934&amp;h=639&amp;f=png&amp;s=67921" alt="一致性 hash 虚拟节点"></p><p>在上图中，只有两台物理服务器节点：11.1.121.1 和 11.1.121.2，我们通过添加后缀的方式，克隆出了另外三份节点，使得环上的节点分布的均匀。一般来说，物理节点越多，所需的虚拟节点就越少。</p><p>介绍完了一致性哈希换，我们便可以对负载均衡进行建模了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line">    <span class="function">Server <span class="title">select</span><span class="params">(List&lt;Server&gt; servers, Invocation invocation)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面直接给出通用的算法实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsistentHashLoadBalancer</span> <span class="keyword">implements</span> <span class="title">LoadBalancer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HashStrategy hashStrategy = <span class="keyword">new</span> JdkHashCodeStrategy();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> VIRTUAL_NODE_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String VIRTUAL_NODE_SUFFIX = <span class="string">"&amp;&amp;"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">select</span><span class="params">(List&lt;Server&gt; servers, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> invocationHashCode = hashStrategy.getHashCode(invocation.getHashKey());</span><br><span class="line">        TreeMap&lt;Integer, Server&gt; ring = buildConsistentHashRing(servers);</span><br><span class="line">        Server server = locate(ring, invocationHashCode);</span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Server <span class="title">locate</span><span class="params">(TreeMap&lt;Integer, Server&gt; ring, <span class="keyword">int</span> invocationHashCode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 向右找到第一个 key</span></span><br><span class="line">        Map.Entry&lt;Integer, Server&gt; locateEntry = ring.ceilingEntry(invocationHashCode);</span><br><span class="line">        <span class="keyword">if</span> (locateEntry == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 想象成一个环，超过尾部则取第一个 key</span></span><br><span class="line">            locateEntry = ring.firstEntry();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> locateEntry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeMap&lt;Integer, Server&gt; <span class="title">buildConsistentHashRing</span><span class="params">(List&lt;Server&gt; servers)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;Integer, Server&gt; virtualNodeRing = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Server server : servers) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VIRTUAL_NODE_SIZE; i++) &#123;</span><br><span class="line">                <span class="comment">// 新增虚拟节点的方式如果有影响，也可以抽象出一个由物理节点扩展虚拟节点的类</span></span><br><span class="line">                virtualNodeRing.put(hashStrategy.getHashCode(server.getUrl() + VIRTUAL_NODE_SUFFIX + i), server);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> virtualNodeRing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对上述的程序做简单的解读：</p><p>Server 是对服务器的抽象，一般是 ip+port 的形式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Invocation 是对请求的抽象，包含一个用于 hash 的 key。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invocation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String hashKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 TreeMap 作为一致性哈希环的数据结构，<code>ring.ceilingEntry</code> 可以获取环上最近的一个节点。在 <code>buildConsistentHashRing</code> 之中包含了构建一致性哈希环的过程，默认加入了 10 个虚拟节点。</p><p>计算方差，标准差的公式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatisticsUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方差 s^2=[(x1-x)^2 +...(xn-x)^2]/n</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">variance</span><span class="params">(Long[] x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = x.length;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;<span class="comment">// 求和</span></span><br><span class="line">            sum += x[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> dAve = sum / m;<span class="comment">// 求平均值</span></span><br><span class="line">        <span class="keyword">double</span> dVar = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;<span class="comment">// 求方差</span></span><br><span class="line">            dVar += (x[i] - dAve)* (x[i] - dAve);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dVar / m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标准差σ=sqrt(s^2)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">standardDeviation</span><span class="params">(Long[] x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = x.length;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;<span class="comment">// 求和</span></span><br><span class="line">            sum += x[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> dAve = sum / m;<span class="comment">// 求平均值</span></span><br><span class="line">        <span class="keyword">double</span> dVar = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;<span class="comment">// 求方差</span></span><br><span class="line">            dVar += (x[i] - dAve)* (x[i] - dAve);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(dVar / m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>HashStrategy</code> 是下文中重点讨论的一个内容，他是对 hash 算法的抽象，我们将会着重对比各种 hash 算法给测评结果带来的差异性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HashStrategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHashCode</span><span class="params">(String origin)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测评程序"><a href="#测评程序" class="headerlink" title="测评程序"></a>测评程序</h3><p>前面我们已经明确了一个优秀的一致性哈希算法的设计思路。这一节我们给出实际的量化指标：假设 m 次请求打到 n 个候选服务器上</p><ul><li>统计每个服务节点收到的流量，计算方差、标准差。测量流量分布均匀情况，我们可以模拟 10000 个随机请求，打到 100 个指定服务器，测试最后个节点的方差，标准差。</li><li>记录 m 次请求落到的服务器节点，下线 20% 的服务器，重放流量，统计 m 次请求中落到跟原先相同服务器的概率。测量节点上下线的情况，我们可以模拟 10000 个随机请求，打到 100 个指定服务器，之后下线 20 个服务器并重放流量，统计请求到相同服务器的比例。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalanceTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> String[] ips = &#123;...&#125;; <span class="comment">// 100 台随机 ip</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试分布的离散情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDistribution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Server&gt; servers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String ip : ips) &#123;</span><br><span class="line">            servers.add(<span class="keyword">new</span> Server(ip+<span class="string">":8080"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        LoadBalancer chloadBalance = <span class="keyword">new</span> ConsistentHashLoadBalancer();</span><br><span class="line">        <span class="comment">// 构造 10000 随机请求</span></span><br><span class="line">        List&lt;Invocation&gt; invocations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            invocations.add(<span class="keyword">new</span> Invocation(UUID.randomUUID().toString()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 统计分布</span></span><br><span class="line">        AtomicLongMap&lt;Server&gt; atomicLongMap = AtomicLongMap.create();</span><br><span class="line">        <span class="keyword">for</span> (Server server : servers) &#123;</span><br><span class="line">            atomicLongMap.put(server, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Invocation invocation : invocations) &#123;</span><br><span class="line">            Server selectedServer = chloadBalance.select(servers, invocation);</span><br><span class="line">            atomicLongMap.getAndIncrement(selectedServer);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(StatisticsUtil.variance(atomicLongMap.asMap().values().toArray(<span class="keyword">new</span> Long[]&#123;&#125;)));</span><br><span class="line">        System.out.println(StatisticsUtil.standardDeviation(atomicLongMap.asMap().values().toArray(<span class="keyword">new</span> Long[]&#123;&#125;)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试节点新增删除后的变化程度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNodeAddAndRemove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Server&gt; servers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String ip : ips) &#123;</span><br><span class="line">            servers.add(<span class="keyword">new</span> Server(ip));</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Server&gt; serverChanged = servers.subList(<span class="number">0</span>, <span class="number">80</span>);</span><br><span class="line">        ConsistentHashLoadBalancer chloadBalance = <span class="keyword">new</span> ConsistentHashLoadBalancer();</span><br><span class="line">        <span class="comment">// 构造 10000 随机请求</span></span><br><span class="line">        List&lt;Invocation&gt; invocations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            invocations.add(<span class="keyword">new</span> Invocation(UUID.randomUUID().toString()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Invocation invocation : invocations) &#123;</span><br><span class="line">            Server origin = chloadBalance.select(servers, invocation);</span><br><span class="line">            Server changed = chloadBalance.select(serverChanged, invocation);</span><br><span class="line">            <span class="keyword">if</span> (origin.getUrl().equals(changed.getUrl())) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(count / <span class="number">10000</span>D);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="不同哈希算法的实现及测评"><a href="#不同哈希算法的实现及测评" class="headerlink" title="不同哈希算法的实现及测评"></a>不同哈希算法的实现及测评</h3><p>最简单、经典的 hashCode 实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkHashCodeStrategy</span> <span class="keyword">implements</span> <span class="title">HashStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHashCode</span><span class="params">(String origin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> origin.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FNV1_32_HASH 算法实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FnvHashStrategy</span> <span class="keyword">implements</span> <span class="title">HashStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> FNV_32_INIT = <span class="number">2166136261L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FNV_32_PRIME = <span class="number">16777619</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHashCode</span><span class="params">(String origin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> p = FNV_32_PRIME;</span><br><span class="line">        <span class="keyword">int</span> hash = (<span class="keyword">int</span>) FNV_32_INIT;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; origin.length(); i++)</span><br><span class="line">            hash = (hash ^ origin.charAt(i)) * p;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">13</span>;</span><br><span class="line">        hash ^= hash &gt;&gt; <span class="number">7</span>;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">3</span>;</span><br><span class="line">        hash ^= hash &gt;&gt; <span class="number">17</span>;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">5</span>;</span><br><span class="line">        hash = Math.abs(hash);</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CRC 算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CRCHashStrategy</span> <span class="keyword">implements</span> <span class="title">HashStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LOOKUP_TABLE[] = &#123;<span class="number">0x0000</span>, <span class="number">0x1021</span>, <span class="number">0x2042</span>, <span class="number">0x3063</span>,</span><br><span class="line">            <span class="number">0x4084</span>, <span class="number">0x50A5</span>, <span class="number">0x60C6</span>, <span class="number">0x70E7</span>, <span class="number">0x8108</span>, <span class="number">0x9129</span>, <span class="number">0xA14A</span>, <span class="number">0xB16B</span>,</span><br><span class="line">            <span class="number">0xC18C</span>, <span class="number">0xD1AD</span>, <span class="number">0xE1CE</span>, <span class="number">0xF1EF</span>, <span class="number">0x1231</span>, <span class="number">0x0210</span>, <span class="number">0x3273</span>, <span class="number">0x2252</span>,</span><br><span class="line">            <span class="number">0x52B5</span>, <span class="number">0x4294</span>, <span class="number">0x72F7</span>, <span class="number">0x62D6</span>, <span class="number">0x9339</span>, <span class="number">0x8318</span>, <span class="number">0xB37B</span>, <span class="number">0xA35A</span>,</span><br><span class="line">            <span class="number">0xD3BD</span>, <span class="number">0xC39C</span>, <span class="number">0xF3FF</span>, <span class="number">0xE3DE</span>, <span class="number">0x2462</span>, <span class="number">0x3443</span>, <span class="number">0x0420</span>, <span class="number">0x1401</span>,</span><br><span class="line">            <span class="number">0x64E6</span>, <span class="number">0x74C7</span>, <span class="number">0x44A4</span>, <span class="number">0x5485</span>, <span class="number">0xA56A</span>, <span class="number">0xB54B</span>, <span class="number">0x8528</span>, <span class="number">0x9509</span>,</span><br><span class="line">            <span class="number">0xE5EE</span>, <span class="number">0xF5CF</span>, <span class="number">0xC5AC</span>, <span class="number">0xD58D</span>, <span class="number">0x3653</span>, <span class="number">0x2672</span>, <span class="number">0x1611</span>, <span class="number">0x0630</span>,</span><br><span class="line">            <span class="number">0x76D7</span>, <span class="number">0x66F6</span>, <span class="number">0x5695</span>, <span class="number">0x46B4</span>, <span class="number">0xB75B</span>, <span class="number">0xA77A</span>, <span class="number">0x9719</span>, <span class="number">0x8738</span>,</span><br><span class="line">            <span class="number">0xF7DF</span>, <span class="number">0xE7FE</span>, <span class="number">0xD79D</span>, <span class="number">0xC7BC</span>, <span class="number">0x48C4</span>, <span class="number">0x58E5</span>, <span class="number">0x6886</span>, <span class="number">0x78A7</span>,</span><br><span class="line">            <span class="number">0x0840</span>, <span class="number">0x1861</span>, <span class="number">0x2802</span>, <span class="number">0x3823</span>, <span class="number">0xC9CC</span>, <span class="number">0xD9ED</span>, <span class="number">0xE98E</span>, <span class="number">0xF9AF</span>,</span><br><span class="line">            <span class="number">0x8948</span>, <span class="number">0x9969</span>, <span class="number">0xA90A</span>, <span class="number">0xB92B</span>, <span class="number">0x5AF5</span>, <span class="number">0x4AD4</span>, <span class="number">0x7AB7</span>, <span class="number">0x6A96</span>,</span><br><span class="line">            <span class="number">0x1A71</span>, <span class="number">0x0A50</span>, <span class="number">0x3A33</span>, <span class="number">0x2A12</span>, <span class="number">0xDBFD</span>, <span class="number">0xCBDC</span>, <span class="number">0xFBBF</span>, <span class="number">0xEB9E</span>,</span><br><span class="line">            <span class="number">0x9B79</span>, <span class="number">0x8B58</span>, <span class="number">0xBB3B</span>, <span class="number">0xAB1A</span>, <span class="number">0x6CA6</span>, <span class="number">0x7C87</span>, <span class="number">0x4CE4</span>, <span class="number">0x5CC5</span>,</span><br><span class="line">            <span class="number">0x2C22</span>, <span class="number">0x3C03</span>, <span class="number">0x0C60</span>, <span class="number">0x1C41</span>, <span class="number">0xEDAE</span>, <span class="number">0xFD8F</span>, <span class="number">0xCDEC</span>, <span class="number">0xDDCD</span>,</span><br><span class="line">            <span class="number">0xAD2A</span>, <span class="number">0xBD0B</span>, <span class="number">0x8D68</span>, <span class="number">0x9D49</span>, <span class="number">0x7E97</span>, <span class="number">0x6EB6</span>, <span class="number">0x5ED5</span>, <span class="number">0x4EF4</span>,</span><br><span class="line">            <span class="number">0x3E13</span>, <span class="number">0x2E32</span>, <span class="number">0x1E51</span>, <span class="number">0x0E70</span>, <span class="number">0xFF9F</span>, <span class="number">0xEFBE</span>, <span class="number">0xDFDD</span>, <span class="number">0xCFFC</span>,</span><br><span class="line">            <span class="number">0xBF1B</span>, <span class="number">0xAF3A</span>, <span class="number">0x9F59</span>, <span class="number">0x8F78</span>, <span class="number">0x9188</span>, <span class="number">0x81A9</span>, <span class="number">0xB1CA</span>, <span class="number">0xA1EB</span>,</span><br><span class="line">            <span class="number">0xD10C</span>, <span class="number">0xC12D</span>, <span class="number">0xF14E</span>, <span class="number">0xE16F</span>, <span class="number">0x1080</span>, <span class="number">0x00A1</span>, <span class="number">0x30C2</span>, <span class="number">0x20E3</span>,</span><br><span class="line">            <span class="number">0x5004</span>, <span class="number">0x4025</span>, <span class="number">0x7046</span>, <span class="number">0x6067</span>, <span class="number">0x83B9</span>, <span class="number">0x9398</span>, <span class="number">0xA3FB</span>, <span class="number">0xB3DA</span>,</span><br><span class="line">            <span class="number">0xC33D</span>, <span class="number">0xD31C</span>, <span class="number">0xE37F</span>, <span class="number">0xF35E</span>, <span class="number">0x02B1</span>, <span class="number">0x1290</span>, <span class="number">0x22F3</span>, <span class="number">0x32D2</span>,</span><br><span class="line">            <span class="number">0x4235</span>, <span class="number">0x5214</span>, <span class="number">0x6277</span>, <span class="number">0x7256</span>, <span class="number">0xB5EA</span>, <span class="number">0xA5CB</span>, <span class="number">0x95A8</span>, <span class="number">0x8589</span>,</span><br><span class="line">            <span class="number">0xF56E</span>, <span class="number">0xE54F</span>, <span class="number">0xD52C</span>, <span class="number">0xC50D</span>, <span class="number">0x34E2</span>, <span class="number">0x24C3</span>, <span class="number">0x14A0</span>, <span class="number">0x0481</span>,</span><br><span class="line">            <span class="number">0x7466</span>, <span class="number">0x6447</span>, <span class="number">0x5424</span>, <span class="number">0x4405</span>, <span class="number">0xA7DB</span>, <span class="number">0xB7FA</span>, <span class="number">0x8799</span>, <span class="number">0x97B8</span>,</span><br><span class="line">            <span class="number">0xE75F</span>, <span class="number">0xF77E</span>, <span class="number">0xC71D</span>, <span class="number">0xD73C</span>, <span class="number">0x26D3</span>, <span class="number">0x36F2</span>, <span class="number">0x0691</span>, <span class="number">0x16B0</span>,</span><br><span class="line">            <span class="number">0x6657</span>, <span class="number">0x7676</span>, <span class="number">0x4615</span>, <span class="number">0x5634</span>, <span class="number">0xD94C</span>, <span class="number">0xC96D</span>, <span class="number">0xF90E</span>, <span class="number">0xE92F</span>,</span><br><span class="line">            <span class="number">0x99C8</span>, <span class="number">0x89E9</span>, <span class="number">0xB98A</span>, <span class="number">0xA9AB</span>, <span class="number">0x5844</span>, <span class="number">0x4865</span>, <span class="number">0x7806</span>, <span class="number">0x6827</span>,</span><br><span class="line">            <span class="number">0x18C0</span>, <span class="number">0x08E1</span>, <span class="number">0x3882</span>, <span class="number">0x28A3</span>, <span class="number">0xCB7D</span>, <span class="number">0xDB5C</span>, <span class="number">0xEB3F</span>, <span class="number">0xFB1E</span>,</span><br><span class="line">            <span class="number">0x8BF9</span>, <span class="number">0x9BD8</span>, <span class="number">0xABBB</span>, <span class="number">0xBB9A</span>, <span class="number">0x4A75</span>, <span class="number">0x5A54</span>, <span class="number">0x6A37</span>, <span class="number">0x7A16</span>,</span><br><span class="line">            <span class="number">0x0AF1</span>, <span class="number">0x1AD0</span>, <span class="number">0x2AB3</span>, <span class="number">0x3A92</span>, <span class="number">0xFD2E</span>, <span class="number">0xED0F</span>, <span class="number">0xDD6C</span>, <span class="number">0xCD4D</span>,</span><br><span class="line">            <span class="number">0xBDAA</span>, <span class="number">0xAD8B</span>, <span class="number">0x9DE8</span>, <span class="number">0x8DC9</span>, <span class="number">0x7C26</span>, <span class="number">0x6C07</span>, <span class="number">0x5C64</span>, <span class="number">0x4C45</span>,</span><br><span class="line">            <span class="number">0x3CA2</span>, <span class="number">0x2C83</span>, <span class="number">0x1CE0</span>, <span class="number">0x0CC1</span>, <span class="number">0xEF1F</span>, <span class="number">0xFF3E</span>, <span class="number">0xCF5D</span>, <span class="number">0xDF7C</span>,</span><br><span class="line">            <span class="number">0xAF9B</span>, <span class="number">0xBFBA</span>, <span class="number">0x8FD9</span>, <span class="number">0x9FF8</span>, <span class="number">0x6E17</span>, <span class="number">0x7E36</span>, <span class="number">0x4E55</span>, <span class="number">0x5E74</span>,</span><br><span class="line">            <span class="number">0x2E93</span>, <span class="number">0x3EB2</span>, <span class="number">0x0ED1</span>, <span class="number">0x1EF0</span>,&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a CRC16 checksum from the bytes. implementation is from</span></span><br><span class="line"><span class="comment">     * mp911de/lettuce, modified with some more optimizations</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> CRC16 as integer value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCRC16</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> crc = <span class="number">0x0000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : bytes) &#123;</span><br><span class="line">            crc = ((crc &lt;&lt; <span class="number">8</span>) ^ LOOKUP_TABLE[((crc &gt;&gt;&gt; <span class="number">8</span>) ^ (b &amp; <span class="number">0xFF</span>)) &amp; <span class="number">0xFF</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> crc &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCRC16</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getCRC16(key.getBytes(Charset.forName(<span class="string">"UTF-8"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHashCode</span><span class="params">(String origin)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// optimization with modulo operator with power of 2</span></span><br><span class="line">        <span class="comment">// equivalent to getCRC16(key) % 16384</span></span><br><span class="line">        <span class="keyword">return</span> getCRC16(origin) &amp; (<span class="number">16384</span> - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ketama 算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KetamaHashStrategy</span> <span class="keyword">implements</span> <span class="title">HashStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MessageDigest md5Digest;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            md5Digest = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"MD5 not supported"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHashCode</span><span class="params">(String origin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bKey = computeMd5(origin);</span><br><span class="line">        <span class="keyword">long</span> rv = ((<span class="keyword">long</span>) (bKey[<span class="number">3</span>] &amp; <span class="number">0xFF</span>)&lt;&lt; <span class="number">24</span>)</span><br><span class="line">                | ((<span class="keyword">long</span>) (bKey[<span class="number">2</span>] &amp; <span class="number">0xFF</span>)&lt;&lt; <span class="number">16</span>)</span><br><span class="line">                | ((<span class="keyword">long</span>) (bKey[<span class="number">1</span>] &amp; <span class="number">0xFF</span>)&lt;&lt; <span class="number">8</span>)</span><br><span class="line">                | (bKey[<span class="number">0</span>] &amp; <span class="number">0xFF</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (rv &amp; <span class="number">0xffffffffL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the md5 of the given key.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] computeMd5(String k) &#123;</span><br><span class="line">        MessageDigest md5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            md5 = (MessageDigest) md5Digest.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"clone of MD5 not supported"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        md5.update(k.getBytes());</span><br><span class="line">        <span class="keyword">return</span> md5.digest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MurmurHash 算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MurmurHashStrategy</span> <span class="keyword">implements</span> <span class="title">HashStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHashCode</span><span class="params">(String origin)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ByteBuffer buf = ByteBuffer.wrap(origin.getBytes());</span><br><span class="line">        <span class="keyword">int</span> seed = <span class="number">0x1234ABCD</span>;</span><br><span class="line"></span><br><span class="line">        ByteOrder byteOrder = buf.order();</span><br><span class="line">        buf.order(ByteOrder.LITTLE_ENDIAN);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> m = <span class="number">0xc6a4a7935bd1e995L</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">47</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> h = seed ^ (buf.remaining() * m);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> k;</span><br><span class="line">        <span class="keyword">while</span> (buf.remaining() &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">            k = buf.getLong();</span><br><span class="line"></span><br><span class="line">            k *= m;</span><br><span class="line">            k ^= k &gt;&gt;&gt; r;</span><br><span class="line">            k *= m;</span><br><span class="line"></span><br><span class="line">            h ^= k;</span><br><span class="line">            h *= m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (buf.remaining() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ByteBuffer finish = ByteBuffer.allocate(<span class="number">8</span>).order(</span><br><span class="line">                    ByteOrder.LITTLE_ENDIAN);</span><br><span class="line">            <span class="comment">// for big-endian version, do this first:</span></span><br><span class="line">            <span class="comment">// finish.position(8-buf.remaining());</span></span><br><span class="line">            finish.put(buf).rewind();</span><br><span class="line">            h ^= finish.getLong();</span><br><span class="line">            h *= m;</span><br><span class="line">        &#125;</span><br><span class="line">        h ^= h &gt;&gt;&gt; r;</span><br><span class="line">        h *= m;</span><br><span class="line">        h ^= h &gt;&gt;&gt; r;</span><br><span class="line"></span><br><span class="line">        buf.order(byteOrder);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (h &amp; <span class="number">0xffffffffL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测评结果：</p><table><thead><tr><th></th><th>方差</th><th>标准差</th><th>不变流量比例</th></tr></thead><tbody><tr><td><strong>JdkHashCodeStrategy</strong></td><td>29574.08</td><td>171.97</td><td>0.6784</td></tr><tr><td><strong>CRCHashStrategy</strong></td><td>3013.02</td><td>54.89</td><td>0.7604</td></tr><tr><td><strong>FnvHashStrategy</strong></td><td>961.64</td><td>31.01</td><td>0.7892</td></tr><tr><td><strong>KetamaHashStrategy</strong></td><td>1254.64</td><td>35.42</td><td>0.7986</td></tr><tr><td><strong>MurmurHashStrategy</strong></td><td>815.72</td><td>28.56</td><td>0.7971</td></tr></tbody></table><p>其中方差和标准差反映了均匀情况，越低越好，可以发现 MurmurHashStrategy，KetamaHashStrategy，FnvHashStrategy 都表现的不错。</p><p>不变流量比例体现了服务器上下线对原有请求的影响程度，不变流量比例越高越高，可以发现 KetamaHashStrategy 和 MurmurHashStrategy 表现最为优秀。</p><p>我并没有对小集群，小流量进行测试，样本偏差性较大，仅从这个常见场景来看，MurmurHashStrategy 是一个不错的选择，多次测试后发现 <strong>FnvHashStrategy</strong>，<strong>KetamaHashStrategy</strong>，<strong>MurmurHashStrategy</strong> 差距不是很大。</p><p>至于性能测试，MurmurHash 也十分的高性能，我并没有做测试（感兴趣的同学可以对几种 strategy 用 JMH 测评一下）, 这里我贴一下 MurmurHash 官方的测评数据：</p><pre><code>OneAtATime - 354.163715 mb/secFNV - 443.668038 mb/secSuperFastHash - 985.335173 mb/seclookup3 - 988.080652 mb/secMurmurHash 1.0 - 1363.293480 mb/secMurmurHash 2.0 - 2056.885653 mb/sec</code></pre><blockquote><p>扩大虚拟节点可以明显降低方差和标准差，但虚拟节点的增加会加大内存占用量以及计算量</p></blockquote><h3 id="Ketama-一致性哈希算法实现"><a href="#Ketama-一致性哈希算法实现" class="headerlink" title="Ketama 一致性哈希算法实现"></a>Ketama 一致性哈希算法实现</h3><p>Ketama 算法有其专门的配套实现方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KetamaConsistentHashLoadBalancer</span> <span class="keyword">implements</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MessageDigest md5Digest;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            md5Digest = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"MD5 not supported"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> VIRTUAL_NODE_SIZE = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String VIRTUAL_NODE_SUFFIX = <span class="string">"-"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">select</span><span class="params">(List&lt;Server&gt; servers, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> invocationHashCode = getHashCode(invocation.getHashKey());</span><br><span class="line">        TreeMap&lt;Long, Server&gt; ring = buildConsistentHashRing(servers);</span><br><span class="line">        Server server = locate(ring, invocationHashCode);</span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Server <span class="title">locate</span><span class="params">(TreeMap&lt;Long, Server&gt; ring, Long invocationHashCode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 向右找到第一个 key</span></span><br><span class="line">        Map.Entry&lt;Long, Server&gt; locateEntry = ring.ceilingEntry(invocationHashCode);</span><br><span class="line">        <span class="keyword">if</span> (locateEntry == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 想象成一个环，超过尾部则取第一个 key</span></span><br><span class="line">            locateEntry = ring.firstEntry();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> locateEntry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeMap&lt;Long, Server&gt; <span class="title">buildConsistentHashRing</span><span class="params">(List&lt;Server&gt; servers)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;Long, Server&gt; virtualNodeRing = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Server server : servers) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VIRTUAL_NODE_SIZE / <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] digest = computeMd5(server.getUrl() + VIRTUAL_NODE_SUFFIX + i);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; <span class="number">4</span>; h++) &#123;</span><br><span class="line">                    Long k = ((<span class="keyword">long</span>) (digest[<span class="number">3</span> + h * <span class="number">4</span>] &amp; <span class="number">0xFF</span>)&lt;&lt; <span class="number">24</span>)</span><br><span class="line">                            | ((<span class="keyword">long</span>) (digest[<span class="number">2</span> + h * <span class="number">4</span>] &amp; <span class="number">0xFF</span>)&lt;&lt; <span class="number">16</span>)</span><br><span class="line">                            | ((<span class="keyword">long</span>) (digest[<span class="number">1</span> + h * <span class="number">4</span>] &amp; <span class="number">0xFF</span>)&lt;&lt; <span class="number">8</span>)</span><br><span class="line">                            | (digest[h * <span class="number">4</span>] &amp; <span class="number">0xFF</span>);</span><br><span class="line">                    virtualNodeRing.put(k, server);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> virtualNodeRing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getHashCode</span><span class="params">(String origin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bKey = computeMd5(origin);</span><br><span class="line">        <span class="keyword">long</span> rv = ((<span class="keyword">long</span>) (bKey[<span class="number">3</span>] &amp; <span class="number">0xFF</span>)&lt;&lt; <span class="number">24</span>)</span><br><span class="line">                | ((<span class="keyword">long</span>) (bKey[<span class="number">2</span>] &amp; <span class="number">0xFF</span>)&lt;&lt; <span class="number">16</span>)</span><br><span class="line">                | ((<span class="keyword">long</span>) (bKey[<span class="number">1</span>] &amp; <span class="number">0xFF</span>)&lt;&lt; <span class="number">8</span>)</span><br><span class="line">                | (bKey[<span class="number">0</span>] &amp; <span class="number">0xFF</span>);</span><br><span class="line">        <span class="keyword">return</span> rv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] computeMd5(String k) &#123;</span><br><span class="line">        MessageDigest md5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            md5 = (MessageDigest) md5Digest.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"clone of MD5 not supported"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        md5.update(k.getBytes());</span><br><span class="line">        <span class="keyword">return</span> md5.digest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>稍微不同的地方便在于：Ketama 将四个节点标为一组进行了虚拟节点的设置。</p><table><thead><tr><th></th><th>方差</th><th>标准差</th><th>不变流量比例</th></tr></thead><tbody><tr><td><strong>KetamaConsistentHashLoadBalancer</strong></td><td>911.08</td><td>30.18</td><td>0.7936</td></tr></tbody></table><p>实际结果并没有太大的提升，可能和测试数据的样本规模有关。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>优秀的哈希算法和一致性哈希算法可以帮助我们在大多数场景下应用的高性能，高稳定性，但在实际使用一致性哈希负载均衡的场景中，最好针对实际的集群规模和请求哈希方式进行压测，力保流量均匀打到所有的机器上，这才是王道。</p><p>不仅仅是分布式缓存，负载均衡等等有限的场景，一致性哈希算法、哈希算法，尤其是后者，是一个用处很广泛的常见算法，了解它的经典实现是很有必要的，例如 MurmurHash，在 guava 中就有其 Java 实现，当需要高性能，分布均匀，碰撞概率小的哈希算法时，可以考虑使用它。</p><p>本文代码的 github 地址：<a href="https://github.com/lexburner/consistent-hash-algorithm" target="_blank" rel="noopener">https://github.com/lexburner/consistent-hash-algorithm</a></p><h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><p><a href="https://www.cnkirito.moe/rpc-cluster/" target="_blank" rel="noopener">深入理解 RPC 之集群篇</a></p><p><a href="https://www.cnkirito.moe/spring-security-6/" target="_blank" rel="noopener">《该如何设计你的 PasswordEncoder?》</a> </p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://sites.google.com/site/murmurhash/" target="_blank" rel="noopener">MurmurHash</a></p><p><a href="https://colobu.com/2015/04/13/consistent-hash-algorithm-in-java-memcached-client/" target="_blank" rel="noopener">memcached Java 客户端 spymemcached 的一致性 Hash 算法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;一致性哈希算法在很多领域有应用，例如分布式缓存领域的 MemCache，Redis，负载均衡领域的 Nginx，各类 RPC 框架。不同领域场景不同，需要顾及的因素也有所差异，本文主要讨论在 &lt;strong&gt; 负载均衡 &lt;/strong&gt; 中一致性哈希算法的设计。&lt;/p&gt;
&lt;p&gt;在介绍一致性哈希算法之前，我将会介绍一些哈希算法，讨论它们的区别和使用场景。也会给出一致性哈希算法的 Java 通用实现，可以直接引用，文末会给出 github 地址。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;友情提示：阅读本文前，最好对一致性哈希算法有所了解，例如你最好听过一致性哈希环这个概念，我会在基本概念上缩短篇幅。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="RPC" scheme="http://lexburner.github.io/categories/RPC/"/>
    
    
      <category term="RPC" scheme="http://lexburner.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>定时器的几种实现方式</title>
    <link href="http://lexburner.github.io/timer/"/>
    <id>http://lexburner.github.io/timer/</id>
    <published>2019-01-24T10:47:55.000Z</published>
    <updated>2019-09-26T09:45:31.563Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h3><p>在开始正题之前，先闲聊几句。有人说，计算机科学这个学科，软件方向研究到头就是数学，硬件方向研究到头就是物理，最轻松的是中间这批使用者，可以不太懂物理，不太懂数学，依旧可以使用计算机作为自己谋生的工具。这个规律具有普适应，看看“定时器”这个例子，往应用层研究，有 Quartz，Spring Schedule 等框架；往分布式研究，又有 SchedulerX，ElasticJob 等分布式任务调度；往底层实现看，又有多种定时器实现方案的原理、工作效率、数据结构可以深究…简单上手使用一个框架，并不能体现出个人的水平，如何与他人构成区分度？我觉得至少要在某一个方向有所建树：</p><ol><li>深入研究某个现有框架的实现原理，例如：读源码</li><li>将一个传统技术在分布式领域很好地延伸，很多成熟的传统技术可能在单机 work well，但分布式场景需要很多额外的考虑。</li><li>站在设计者的角度，如果从零开始设计一个轮子，怎么利用合适的算法、数据结构，去实现它。</li></ol><p>回到这篇文章的主题，我首先会围绕第三个话题讨论：设计实现一个定时器，可以使用什么算法，采用什么数据结构。接着再聊聊第一个话题：探讨一些优秀的定时器实现方案。</p><a id="more"></a><h3 id="2-理解定时器"><a href="#2-理解定时器" class="headerlink" title="2 理解定时器"></a>2 理解定时器</h3><p>很多场景会用到定时器，例如</p><ol><li>使用 TCP 长连接时，客户端需要定时向服务端发送心跳请求。</li><li>财务系统每个月的月末定时生成对账单。</li><li>双 11 的 0 点，定时开启秒杀开关。</li></ol><p>定时器像水和空气一般，普遍存在于各个场景中，一般定时任务的形式表现为：经过固定时间后触发、按照固定频率周期性触发、在某个时刻触发。定时器是什么？可以理解为这样一个数据结构：</p><blockquote><p>存储一系列的任务集合，并且 Deadline 越接近的任务，拥有越高的执行优先级<br>在用户视角支持以下几种操作：<br>NewTask：将新任务加入任务集合<br>Cancel：取消某个任务<br>在任务调度的视角还要支持：<br>Run：执行一个到期的定时任务</p></blockquote><p>判断一个任务是否到期，基本会采用轮询的方式，<strong> 每隔一个时间片 </strong> 去检查 <strong> 最近的任务 </strong> 是否到期，并且，在 NewTask 和 Cancel 的行为发生之后，任务调度策略也会出现调整。</p><blockquote><p>说到底，定时器还是靠线程轮询实现的。</p></blockquote><h3 id="3-数据结构"><a href="#3-数据结构" class="headerlink" title="3 数据结构"></a>3 数据结构</h3><p>我们主要衡量 NewTask（新增任务），Cancel（取消任务），Run（执行到期的定时任务）这三个指标，分析他们使用不同数据结构的时间 / 空间复杂度。</p><h4 id="3-1-双向有序链表"><a href="#3-1-双向有序链表" class="headerlink" title="3.1 双向有序链表"></a>3.1 双向有序链表</h4><p>在 Java 中，<code>LinkedList</code> 是一个天然的双向链表</p><blockquote><p>NewTask：O(N)<br>Cancel：O(1)<br>Run：O(1)<br>N：任务数</p></blockquote><p>NewTask O(N) 很容易理解，按照 expireTime 查找合适的位置即可；Cancel O(1) ，任务在 Cancel 时，会持有自己节点的引用，所以不需要查找其在链表中所在的位置，即可实现当前节点的删除，这也是为什么我们使用双向链表而不是普通链表的原因是 ；Run O(1)，由于整个双向链表是基于 expireTime 有序的，所以调度器只需要轮询第一个任务即可。</p><h4 id="3-2-堆"><a href="#3-2-堆" class="headerlink" title="3.2 堆"></a>3.2 堆</h4><p>在 Java 中，<code>PriorityQueue</code> 是一个天然的堆，可以利用传入的 <code>Comparator</code> 来决定其中元素的优先级。</p><blockquote><p>NewTask：O(logN)<br>Cancel：O(logN)<br>Run：O(1)<br>N：任务数</p></blockquote><p>expireTime 是  <code>Comparator</code>  的对比参数。NewTask O(logN) 和 Cancel O(logN) 分别对应堆插入和删除元素的时间复杂度 ；Run O(1)，由 expireTime 形成的小根堆，我们总能在堆顶找到最快的即将过期的任务。</p><p>堆与双向有序链表相比，NewTask 和 Cancel 形成了 trade off，但考虑到现实中，定时任务取消的场景并不是很多，所以堆实现的定时器要比双向有序链表优秀。</p><h4 id="3-3-时间轮"><a href="#3-3-时间轮" class="headerlink" title="3.3 时间轮"></a>3.3 时间轮</h4><p>Netty 针对 I/O 超时调度的场景进行了优化，实现了 <code>HashedWheelTimer</code> 时间轮算法。</p><p><img src="http://kirito.iocoder.cn/201807171109599678a80c-075a-40ee-b25f-10fd82c1025c.png" alt="时间轮算法"></p><p><code>HashedWheelTimer</code> 是一个环形结构，可以用时钟来类比，钟面上有很多 bucket ，每一个 bucket 上可以存放多个任务，使用一个 List 保存该时刻到期的所有任务，同时一个指针随着时间流逝一格一格转动，并执行对应 bucket 上所有到期的任务。任务通过 <code>取模</code> 决定应该放入哪个 bucket 。和 HashMap 的原理类似，newTask 对应 put，使用 List 来解决 Hash 冲突。</p><p>以上图为例，假设一个 bucket 是 1 秒，则指针转动一轮表示的时间段为 8s，假设当前指针指向 0，此时需要调度一个 3s 后执行的任务，显然应该加入到 (0+3=3) 的方格中，指针再走 3 次就可以执行了；如果任务要在 10s 后执行，应该等指针走完一轮零 2 格再执行，因此应放入 2，同时将 round（1）保存到任务中。检查到期任务时只执行 round 为 0 的， bucket 上其他任务的 round 减 1。</p><p>再看图中的 bucket5，我们可以知道在 $1<em>8+5=13s$  后，有两个任务需要执行，在 $2</em>8+5=21s$ 后有一个任务需要执行。</p><blockquote><p>NewTask：O(1)<br>Cancel：O(1)<br>Run：O(M)<br>Tick：O(1)<br>M： bucket ，M ~ N/C ，其中 C 为单轮 bucket 数，Netty 中默认为 512 </p></blockquote><p>时间轮算法的复杂度可能表达有误，比较难算，仅供参考。另外，其复杂度还受到多个任务分配到同一个 bucket 的影响。并且多了一个转动指针的开销。</p><blockquote><p>传统定时器是面向任务的，时间轮定时器是面向 bucket 的。</p></blockquote><p>构造 Netty 的 <code>HashedWheelTimer</code> 时有两个重要的参数：<code>tickDuration</code> 和 <code>ticksPerWheel</code>。</p><ol><li><code>tickDuration</code>：即一个 bucket 代表的时间，默认为 100ms，Netty 认为大多数场景下不需要修改这个参数；</li><li><code>ticksPerWheel</code>：一轮含有多少个 bucket ，默认为 512 个，如果任务较多可以增大这个参数，降低任务分配到同一个 bucket 的概率。</li></ol><h4 id="3-4-层级时间轮"><a href="#3-4-层级时间轮" class="headerlink" title="3.4 层级时间轮"></a>3.4 层级时间轮</h4><p>Kafka 针对时间轮算法进行了优化，实现了层级时间轮 <code>TimingWheel</code></p><p>如果任务的时间跨度很大，数量也多，传统的 <code>HashedWheelTimer</code> 会造成任务的 <code>round</code> 很大，单个 bucket 的任务 List 很长，并会维持很长一段时间。这时可将轮盘按时间粒度分级：</p><p><img src="http://kirito.iocoder.cn/7f03c027b1de345a0b1e57239d73de74.png" alt="层级时间轮"></p><p>现在，每个任务除了要维护在当前轮盘的 <code>round</code>，还要计算在所有下级轮盘的 <code>round</code>。当本层的 <code>round</code> 为 0 时，任务按下级 <code>round</code> 值被下放到下级轮子，最终在最底层的轮盘得到执行。</p><blockquote><p>NewTask：O(H)<br>Cancel：O(H)<br>Run：O(M)<br>Tick：O(1)<br>H：层级数量</p></blockquote><p>设想一下一个定时了 3 天，10 小时，50 分，30 秒的定时任务，在 tickDuration = 1s 的单层时间轮中，需要经过：$3<em>24</em>60<em>60+10</em>60<em>60+50</em>60+30$ 次指针的拨动才能被执行。但在 wheel1 tickDuration = 1 天，wheel2 tickDuration = 1 小时，wheel3 tickDuration = 1 分，wheel4 tickDuration = 1 秒 的四层时间轮中，只需要经过 $3+10+50+30$ 次指针的拨动！ </p><p>相比单层时间轮，层级时间轮在时间跨度较大时存在明显的优势。</p><h3 id="4-常见实现"><a href="#4-常见实现" class="headerlink" title="4 常见实现"></a>4 常见实现</h3><h4 id="4-1-Timer"><a href="#4-1-Timer" class="headerlink" title="4.1 Timer"></a>4.1 Timer</h4><p>JDK 中的 <code>Timer</code> 是非常早期的实现，在现在看来，它并不是一个好的设计。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行一个一秒后执行的定时任务</span></span><br><span class="line">Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do sth</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>使用 <code>Timer</code> 实现任务调度的核心是 <code>Timer</code> 和 <code>TimerTask</code>。其中 <code>Timer</code> 负责设定 <code>TimerTask</code> 的起始与间隔执行时间。使用者只需要创建一个 <code>TimerTask</code> 的继承类，实现自己的 <code>run</code> 方法，然后将其丢给 <code>Timer</code> 去执行即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Timer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TaskQueue queue = <span class="keyword">new</span> TaskQueue();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TimerThread thread = <span class="keyword">new</span> TimerThread(queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 TaskQueue 是使用数组实现的一个简易的堆。另外一个值得注意的属性是 <code>TimerThread</code>，<code>Timer</code> 使用唯一的线程负责轮询并执行任务。<code>Timer</code> 的优点在于简单易用，但也因为所有任务都是由同一个线程来调度，因此整个过程是串行执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务。</p><blockquote><p>轮询时如果发现  currentTime &lt; heapFirst.executionTime，可以 wait(executionTime - currentTime) 来减少不必要的轮询时间。这是普遍被使用的一个优化。</p></blockquote><ol><li><code>Timer</code> 只能被单线程调度</li><li><code>TimerTask</code> 中出现的异常会影响到 <code>Timer</code> 的执行。 </li></ol><p>由于这两个缺陷，JDK 1.5 支持了新的定时器方案 <code>ScheduledExecutorService</code>。</p><h4 id="4-2-ScheduledExecutorService"><a href="#4-2-ScheduledExecutorService" class="headerlink" title="4.2 ScheduledExecutorService"></a>4.2 ScheduledExecutorService</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行一个一秒后执行的定时任务</span></span><br><span class="line">ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line">service.scheduleA(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do sth</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>相比 <code>Timer</code>，<code>ScheduledExecutorService</code> 解决了同一个定时器调度多个任务的阻塞问题，并且任务异常不会中断 <code>ScheduledExecutorService</code>。</p><p><code>ScheduledExecutorService</code> 提供了两种常用的周期调度方法 ScheduleAtFixedRate 和 ScheduleWithFixedDelay。</p><p>ScheduleAtFixedRate 每次执行时间为上一次任务开始起向后推一个时间间隔，即每次执行时间为 : $initialDelay$, $initialDelay+period$, $initialDelay+2*period$, …</p><p>ScheduleWithFixedDelay 每次执行时间为上一次任务结束起向后推一个时间间隔，即每次执行时间为：$initialDelay$, $initialDelay+executeTime+delay$, $initialDelay+2<em>executeTime+2</em>delay$, … </p><p>由此可见，ScheduleAtFixedRate 是基于固定时间间隔进行任务调度，ScheduleWithFixedDelay 取决于每次任务执行的时间长短，是基于不固定时间间隔的任务调度。</p><p><code>ScheduledExecutorService</code> 底层使用的数据结构为 <code>PriorityQueue</code>，任务调度方式较为常规，不做特别介绍。</p><h4 id="4-3-HashedWheelTimer"><a href="#4-3-HashedWheelTimer" class="headerlink" title="4.3 HashedWheelTimer"></a>4.3 HashedWheelTimer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Timer timer = <span class="keyword">new</span> HashedWheelTimer();</span><br><span class="line"><span class="comment">// 等价于 Timer timer = new HashedWheelTimer(100, TimeUnit.MILLISECONDS, 512);</span></span><br><span class="line">timer.newTimeout(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//do sth</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>前面已经介绍过了 Netty 中 <code>HashedWheelTimer</code> 内部的数据结构，默认构造器会配置轮询周期为 100ms，bucket 数量为 512。其使用方法和 JDK 的 <code>Timer</code> 十分相似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Worker worker = <span class="keyword">new</span> Worker();<span class="comment">// Runnable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Thread workerThread;<span class="comment">// Thread</span></span><br></pre></td></tr></table></figure><p>由于篇幅限制，我并不打算做详细的源码分析，但上述两行来自 <code>HashedWheelTimer</code> 的代码阐释了一个事实：<code>HashedWheelTimer</code> 内部也同样是使用单个线程进行任务调度。与  JDK 的 <code>Timer</code> 一样，存在”前一个任务执行时间过长，影响后续定时任务执行“的问题。</p><blockquote><p>理解 HashedWheelTimer 中的 ticksPerWheel，tickDuration，对二者进行合理的配置，可以使得用户在合适的场景得到最佳的性能。</p></blockquote><h3 id="5-最佳实践"><a href="#5-最佳实践" class="headerlink" title="5 最佳实践"></a>5 最佳实践</h3><h4 id="5-1-选择合适的定时器"><a href="#5-1-选择合适的定时器" class="headerlink" title="5.1 选择合适的定时器"></a>5.1 选择合适的定时器</h4><p>毋庸置疑，JDK 的 <code>Timer</code> 使用的场景是最窄的，完全可以被后两者取代。如何在 <code>ScheduledExecutorService</code> 和 <code>HashedWheelTimer</code> 之间如何做选择，需要区分场景，做一个简单的对比：</p><ol><li><code>ScheduledExecutorService</code> 是面向任务的，当任务数非常大时，使用堆 (PriorityQueue) 维护任务的新增、删除会导致性能下降，而 <code>HashedWheelTimer</code> 面向 bucket，设置合理的 ticksPerWheel，tickDuration ，可以不受任务量的限制。所以在任务非常多时，<code>HashedWheelTimer</code> 可以表现出它的优势。</li><li>相反，如果任务量少，<code>HashedWheelTimer</code> 内部的 Worker 线程依旧会不停的拨动指针，虽然不是特别消耗性能，但至少不能说：<code>HashedWheelTimer</code> 一定比 <code>ScheduledExecutorService</code> 优秀。</li><li><code>HashedWheelTimer</code> 由于开辟了一个 bucket 数组，占用的内存会稍大。</li></ol><p>上述的对比，让我们得到了一个最佳实践：在任务非常多时，使用 <code>HashedWheelTimer</code> 可以获得性能的提升。例如服务治理框架中的心跳定时任务，服务实例非常多时，每一个客户端都需要定时发送心跳，每一个服务端都需要定时检测连接状态，这是一个非常适合使用 <code>HashedWheelTimer</code>  的场景。</p><h4 id="5-2-单线程与业务线程池"><a href="#5-2-单线程与业务线程池" class="headerlink" title="5.2 单线程与业务线程池"></a>5.2 单线程与业务线程池</h4><p>我们需要注意 <code>HashedWheelTimer</code> 使用单线程来调度任务，如果任务比较耗时，应当设置一个业务线程池，将 <code>HashedWheelTimer</code> 当做一个定时触发器，任务的实际执行，交给业务线程池。</p><blockquote><p>如果所有的任务都满足： taskNStartTime - taskN-1StartTime &gt; taskN-1CostTime，即任意两个任务的间隔时间小于先执行任务的执行时间，则无需担心这个问题。</p></blockquote><h4 id="5-3-全局定时器"><a href="#5-3-全局定时器" class="headerlink" title="5.3 全局定时器"></a>5.3 全局定时器</h4><p>实际使用 <code>HashedWheelTimer</code> 时，<strong> 应当将其当做一个全局的任务调度器，例如设计成 static</strong> 。时刻谨记一点：<code>HashedWheelTimer</code> 对应一个线程，如果每次实例化 <code>HashedWheelTimer</code>，首先是线程会很多，其次是时间轮算法将会完全失去意义。</p><h4 id="5-4-为-HashedWheelTimer-设置合理的参数"><a href="#5-4-为-HashedWheelTimer-设置合理的参数" class="headerlink" title="5.4 为 HashedWheelTimer 设置合理的参数"></a>5.4 为 HashedWheelTimer 设置合理的参数</h4><p>ticksPerWheel，tickDuration 这两个参数尤为重要，ticksPerWheel 控制了时间轮中 bucket 的数量，决定了冲突发生的概率，tickDuration 决定了指针拨动的频率，一方面会影响定时的精度，一方面决定 CPU 的消耗量。当任务数量非常大时，考虑增大 ticksPerWheel；当时间精度要求不高时，可以适当加大 tickDuration，不过大多数情况下，不需要 care 这个参数。</p><h4 id="5-5-什么时候使用层级时间轮"><a href="#5-5-什么时候使用层级时间轮" class="headerlink" title="5.5 什么时候使用层级时间轮"></a>5.5 什么时候使用层级时间轮</h4><p>当时间跨度很大时，提升单层时间轮的 tickDuration 可以减少空转次数，但会导致时间精度变低，层级时间轮既可以避免精度降低，又避免了指针空转的次数。如果有时间跨度较长的定时任务，则可以交给层级时间轮去调度。此外，也可以按照定时精度实例化多个不同作用的单层时间轮，dayHashedWheelTimer、hourHashedWheelTimer、minHashedWheelTimer，配置不同的 tickDuration，此法虽 low，但不失为一个解决方案。Netty 设计的 <code>HashedWheelTimer</code> 是专门用来优化 I/O 调度的，场景较为局限，所以并没有实现层级时间轮；而在 Kafka 中定时器的适用范围则较广，所以其实现了层级时间轮，以应对更为复杂的场景。</p><h3 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6 参考资料"></a>6 参考资料</h3><p>[1] <a href="https://www.ibm.com/developerworks/cn/java/j-lo-taskschedule/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-taskschedule/index.html</a></p><p>[2] <a href="http://novoland.github.io/" target="_blank" rel="noopener">http://novoland.github.io/</a> 并发 /2014/07/26/ 定时器（Timer）的实现.html</p><p>[3] <a href="http://www.cs.columbia.edu/~nahum/w6998/papers/sosp87-timing-wheels.pdf" target="_blank" rel="noopener">http://www.cs.columbia.edu/~nahum/w6998/papers/sosp87-timing-wheels.pdf</a></p><p><strong> 欢迎关注我的微信公众号：「Kirito 的技术分享」，关于文章的任何疑问都会得到回复，带来更多 Java 相关的技术分享。</strong></p><p><img src="http://kirito.iocoder.cn/qrcode_for_gh_c06057be7960_258%20%281%29.jpg" alt="关注微信公众号"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1 前言&quot;&gt;&lt;/a&gt;1 前言&lt;/h3&gt;&lt;p&gt;在开始正题之前，先闲聊几句。有人说，计算机科学这个学科，软件方向研究到头就是数学，硬件方向研究到头就是物理，最轻松的是中间这批使用者，可以不太懂物理，不太懂数学，依旧可以使用计算机作为自己谋生的工具。这个规律具有普适应，看看“定时器”这个例子，往应用层研究，有 Quartz，Spring Schedule 等框架；往分布式研究，又有 SchedulerX，ElasticJob 等分布式任务调度；往底层实现看，又有多种定时器实现方案的原理、工作效率、数据结构可以深究…简单上手使用一个框架，并不能体现出个人的水平，如何与他人构成区分度？我觉得至少要在某一个方向有所建树：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;深入研究某个现有框架的实现原理，例如：读源码&lt;/li&gt;
&lt;li&gt;将一个传统技术在分布式领域很好地延伸，很多成熟的传统技术可能在单机 work well，但分布式场景需要很多额外的考虑。&lt;/li&gt;
&lt;li&gt;站在设计者的角度，如果从零开始设计一个轮子，怎么利用合适的算法、数据结构，去实现它。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;回到这篇文章的主题，我首先会围绕第三个话题讨论：设计实现一个定时器，可以使用什么算法，采用什么数据结构。接着再聊聊第一个话题：探讨一些优秀的定时器实现方案。&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://lexburner.github.io/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://lexburner.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>提问前，请先让自己成为值得被教的人</title>
    <link href="http://lexburner.github.io/thinging-in-ask/"/>
    <id>http://lexburner.github.io/thinging-in-ask/</id>
    <published>2019-01-21T18:18:51.000Z</published>
    <updated>2019-09-26T09:45:29.551Z</updated>
    
    <content type="html"><![CDATA[<p>每一个不恰当的提问都在消耗别人对你的耐心，程序员届早已经有了诸如《提问的智慧》之类的经典文章介绍了什么是蠢问题，如何避免问蠢问题。然而，常年混迹于十几个技术交流微信群的我，发现很多小白程序员并不懂得这一点，为改善微信群的技术交流氛围，转此文，意图是让大家在担任提问者的角色时，尽可能提高提问的素质，让自己成为值得被教的人。</p><blockquote><p>原文出处：<a href="https://github.com/aptx4869yuyang2017/How-To-Ask-Questions-The-Smart-Way" target="_blank" rel="noopener">https://github.com/aptx4869yuyang2017/How-To-Ask-Questions-The-Smart-Way</a></p></blockquote><a id="more"></a><h3 id="用清晰、正确、精准并语法正确的语句"><a href="#用清晰、正确、精准并语法正确的语句" class="headerlink" title="用清晰、正确、精准并语法正确的语句"></a>用清晰、正确、精准并语法正确的语句</h3><p>我们从经验中发现，粗心的提问者通常也会粗心的写程序与思考（我敢打包票）。回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。</p><p>正确的拼字、标点符号和大小写是很重要的。一般来说，如果你觉得这样做很麻烦，不想在乎这些，那我们也觉得麻烦，不想在乎你的提问。花点额外的精力斟酌一下字句，用不着太僵硬与正式。</p><p>更白话地说，如果你写得像是个小白，那多半得不到理睬。</p><p>如果在使用非母语的论坛提问，你可以犯点拼写和语法上的小错，但决不能在思考上马虎（没错，我们通常能弄清两者的分别）。同时，除非你知道回复者使用的语言，否则请使用英语书写。繁忙的程序员一般会直接删除用他们看不懂语言写的消息。在网络上英语是通用语言，用英语书写可以将你的问题在尚未被阅读就被直接删除的可能性降到最低。</p><p>如果英文是你的外语（Second language），提示潜在回复者你有潜在的语言困难是很好的： [译注：以下附上原文以供使用]</p><blockquote><p>English is not my native language; please excuse typing errors.</p></blockquote><ul><li>英文不是我的母语，请原谅我的错字或语法</li></ul><blockquote><p>If you speak $LANGUAGE, please email/PM me; I may need assistance translating my question.</p></blockquote><ul><li>如果你说 <strong> 某语言 </strong>，请寄信 / 私讯给我；我需要有人协助我翻译我的问题</li></ul><blockquote><p>I am familiar with the technical terms, but some slang expressions and idioms are difficult for me.</p></blockquote><ul><li>我对技术名词很熟悉，但对于俗语或是特别用法比较不甚了解。</li></ul><blockquote><p>I’ve posted my question in $LANGUAGE and English. I’ll be glad to translate responses, if you only use one or the other.</p></blockquote><ul><li>我把我的问题用 <strong> 某语言 </strong> 和英文写出来，如果你只用一种语言回答，我会乐意将其翻译成另一种。</li></ul><h3 id="精确的描述问题并言之有物"><a href="#精确的描述问题并言之有物" class="headerlink" title="精确的描述问题并言之有物"></a>精确的描述问题并言之有物</h3><ul><li>仔细、清楚地描述你的问题或 Bug 的症状。</li><li>描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：<code>Fedora Core 4</code>、<code>Slackware 9.1</code> 等）。</li><li>描述在提问前你是怎样去研究和理解这个问题的。</li><li>描述在提问前为确定问题而采取的诊断步骤。</li><li>描述最近做过什么可能相关的硬件或软件变更。</li><li>尽可能的提供一个可以 <code>重现这个问题的可控环境</code> 的方法。</li></ul><p>尽量去揣测一个程序员会怎样反问你，在你提问之前预先将程序员们可能遇到的问题回答一遍。</p><p>以上几点中，当你报告的是你认为可能在代码中的问题时，给程序员一个可以重现你的问题的环境尤其重要。当你这么做时，你得到有效的回答的机会和速度都会大大的提升。</p><p><a href="http://www.chiark.greenend.org.uk/~sgtatham/" target="_blank" rel="noopener">Simon Tatham</a> 写过一篇名为《<a href="http://www.chiark.greenend.org.uk/~sgtatham/bugs-tw.html" target="_blank" rel="noopener">如何有效的报告 Bug</a>》的出色文章。强力推荐你也读一读。</p><h3 id="话不在多而在精"><a href="#话不在多而在精" class="headerlink" title="话不在多而在精"></a>话不在多而在精</h3><p>你需要提供精确有内容的信息。这并不是要求你简单的把成堆的出错代码或者资料完全转录到你的提问中。如果你有庞大而复杂的测试样例能重现程序挂掉的情境，尽量将它剪裁得越小越好。</p><p>这样做的用处至少有三点。 第一，表现出你为简化问题付出了努力，这可以使你得到回答的机会增加； 第二，简化问题使你更有可能得到 <strong><em> 有用 </em></strong> 的答案； 第三，在精炼你的 bug 报告的过程中，你很可能就自己找到了解决方法或权宜之计。</p><h3 id="别动辄声称找到-Bug"><a href="#别动辄声称找到-Bug" class="headerlink" title="别动辄声称找到 Bug"></a>别动辄声称找到 Bug</h3><p>当你在使用软件中遇到问题，除非你非常、<strong><em> 非常 </em></strong> 的有根据，不要动辄声称找到了 Bug。提示：除非你能提供解决问题的源代码补丁，或者提供回归测试来表明前一版本中行为不正确，否则你都多半不够完全确信。这同样适用在网页和文件，如果你（声称）发现了文件的 <code>Bug</code>，你应该能提供相应位置的修正或替代文件。</p><p>请记得，还有许多其它使用者没遇到你发现的问题，否则你在阅读文件或搜索网页时就应该发现了（你在抱怨前 <a href="https://github.com/aptx4869yuyang2017/How-To-Ask-Questions-The-Smart-Way#%E5%9C%A8%E6%8F%90%E9%97%AE%E4%B9%8B%E5%89%8D" target="_blank" rel="noopener">已经做了这些，是吧</a>？）。这也意味着很有可能是你弄错了而不是软件本身有问题。</p><p>编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了 Bug，也就是在质疑他们的能力，即使你是对的，也有可能会冒犯到其中某部分人。当你在标题中嚷嚷着有 <code>Bug</code> 时，这尤其严重。</p><p>提问时，即使你私下非常确信已经发现一个真正的 Bug，最好写得像是 <strong><em> 你 </em></strong> 做错了什么。如果真的有 Bug，你会在回复中看到这点。这样做的话，如果真有 Bug，维护者就会向你道歉，这总比你惹恼别人然后欠别人一个道歉要好一点。</p><h3 id="低声下气不能代替你的功课"><a href="#低声下气不能代替你的功课" class="headerlink" title="低声下气不能代替你的功课"></a>低声下气不能代替你的功课</h3><p>有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 – 低声下气：<code>我知道我只是个可悲的新手，一个撸瑟，但...</code>。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描述时更令人反感。</p><p>别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。</p><p>有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。</p><h3 id="描述问题症状而非你的猜测"><a href="#描述问题症状而非你的猜测" class="headerlink" title="描述问题症状而非你的猜测"></a>描述问题症状而非你的猜测</h3><p>告诉程序员们你认为问题是怎样造成的并没什么帮助。（如果你的推断如此有效，还用向别人求助吗？），因此要确信你原原本本告诉了他们问题的症状，而不是你的解释和理论；让程序员们来推测和诊断。如果你认为陈述自己的猜测很重要，清楚地说明这只是你的猜测，并描述为什么它们不起作用。</p><p><strong> 蠢问题 </strong></p><blockquote><p>我在编译内核时接连遇到 SIG11 错误， 我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？</p></blockquote><p><strong> 聪明问题 </strong></p><blockquote><p>我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6/233 CPU（威盛 Apollo VP2 芯片组）， 256MB Corsair PC133 SDRAM 内存，在编译内核时，从开机 20 分钟以后就频频产生 SIG11 错误， 但是在头 20 分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作 20 分钟。 所有内存都换过了，没有效果。相关部分的标准编译记录如下…。</p></blockquote><p>由于以上这点似乎让许多人觉得难以配合，这里有句话可以提醒你：<code>所有的诊断专家都来自密苏里州。</code> 美国国务院的官方座右铭则是：<code>让我看看</code>（出自国会议员 Willard D. Vandiver 在 1899 年时的讲话：<code>我来自一个出产玉米，棉花，牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。</code>） 针对诊断者而言，这并不是一种怀疑，而只是一种真实而有用的需求，以便让他们看到的是与你看到的原始证据尽可能一致的东西，而不是你的猜测与归纳的结论。所以，大方的展示给我们看吧！</p><h3 id="按发生时间先后列出问题症状"><a href="#按发生时间先后列出问题症状" class="headerlink" title="按发生时间先后列出问题症状"></a>按发生时间先后列出问题症状</h3><p>问题发生前的一系列操作，往往就是对找出问题最有帮助的线索。因此，你的说明里应该包含你的操作步骤，以及机器和软件的反应，直到问题发生。在命令行处理的情况下，提供一段操作记录（例如运行脚本工具所生成的），并引用相关的若干行（如 20 行）记录会非常有帮助。</p><p>如果挂掉的程序有诊断选项（如 -v 的详述开关），试着选择这些能在记录中增加调试信息的选项。记住，<code>多</code> 不等于 <code>好</code>。试着选取适当的调试级别以便提供有用的信息而不是让读者淹没在垃圾中。</p><p>如果你的说明很长（如超过四个段落），在开头简述问题，接下来再按时间顺序详述会有所帮助。这样程序员们在读你的记录时就知道该注意哪些内容了。</p><h3 id="描述目标而不是过程"><a href="#描述目标而不是过程" class="headerlink" title="描述目标而不是过程"></a>描述目标而不是过程</h3><p>如果你想弄清楚如何做某事（而不是报告一个 Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。</p><p>经常寻求技术帮助的人在心中有个更高层次的目标，而他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身就有问题。结果要费很大的劲才能搞定。</p><p><strong> 蠢问题 </strong></p><blockquote><p>我怎样才能从某绘图程序的颜色选择器中取得十六进制的的 RGB 值？</p></blockquote><p><strong> 聪明问题 </strong></p><blockquote><p>我正试着用替换一幅图片的色码（color table）成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块（table slot）， 但却无法从某绘图程序的颜色选择器取得十六进制的的 RGB 值。</p></blockquote><p>第二种提问法比较聪明，你可能得到像是 <code>建议采用另一个更合适的工具</code> 的回复。</p><h3 id="清楚明确的表达你的问题以及需求"><a href="#清楚明确的表达你的问题以及需求" class="headerlink" title="清楚明确的表达你的问题以及需求"></a>清楚明确的表达你的问题以及需求</h3><p>漫无边际的提问是近乎无休无止的时间黑洞。最有可能给你有用答案的人通常也正是最忙的人（他们忙是因为要亲自完成大部分工作）。这样的人对无节制的时间黑洞相当厌恶，所以他们也倾向于厌恶那些漫无边际的提问。</p><p>如果你明确表述需要回答者做什么（如提供指点、发送一段代码、检查你的补丁、或是其他等等），就最有可能得到有用的答案。因为这会定出一个时间和精力的上限，便于回答者能集中精力来帮你。这么做很棒。</p><p>要理解专家们所处的世界，请把专业技能想像为充裕的资源，而回复的时间则是稀缺的资源。你要求他们奉献的时间越少，你越有可能从真正专业而且很忙的专家那里得到解答。</p><p>所以，界定一下你的问题，使专家花在辨识你的问题和回答所需要付出的时间减到最少，这技巧对你有用答案相当有帮助 – 但这技巧通常和简化问题有所区别。因此，问 <code>我想更好的理解 X，可否指点一下哪有好一点说明？</code> 通常比问 <code>你能解释一下 X 吗？</code> 更好。如果你的代码不能运作，通常请别人看看哪里有问题，比要求别人替你改正要明智得多。</p><h3 id="询问有关代码的问题时"><a href="#询问有关代码的问题时" class="headerlink" title="询问有关代码的问题时"></a>询问有关代码的问题时</h3><p>别要求他人帮你调试有问题的代码，不提示一下应该从何入手。张贴几百行的代码，然后说一声：<code>它不能工作</code> 会让你完全被忽略。只贴几十行代码，然后说一句：<code>在第七行以后，我期待它显示 &lt;x&gt;，但实际出现的是 &lt;y&gt;</code> 比较有可能让你得到回应。</p><p>最有效描述程序问题的方法是提供最精简的 Bug 展示测试用例（bug-demonstrating test case）。什么是最精简的测试用例？那是问题的缩影；一小个程序片段能 <strong> 刚好 </strong> 展示出程序的异常行为，而不包含其他令人分散注意力的内容。怎么制作最精简的测试用例？如果你知道哪一行或哪一段代码会造成异常的行为，复制下来并加入足够重现这个状况的代码（例如，足以让这段代码能被编译 / 直译 / 被应用程序处理）。如果你无法将问题缩减到一个特定区块，就复制一份代码并移除不影响产生问题行为的部分。总之，测试用例越小越好。</p><p>一般而言，要得到一段相当精简的测试用例并不太容易，但永远先尝试这样做的是种好习惯。这种方式可以帮助你了解如何自行解决这个问题 —- 而且即使你的尝试不成功，程序员们也会看到你在尝试取得答案的过程中付出了努力，这可以让他们更愿意与你合作。</p><p>如果你只是想让别人帮忙审查（Review）一下代码，在信的开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。</p><h3 id="别把自己家庭作业的问题贴上来"><a href="#别把自己家庭作业的问题贴上来" class="headerlink" title="别把自己家庭作业的问题贴上来"></a>别把自己家庭作业的问题贴上来</h3><p>程序员们很擅长分辨哪些问题是家庭作业式的问题；因为我们中的大多数都曾自己解决这类问题。同样，这些问题得由 <strong> 你 </strong> 来搞定，你会从中学到东西。你可以要求给点提示，但别要求得到完整的解决方案。</p><p>如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在使用者群组，论坛或（最后一招）在项目的 <strong> 使用者 </strong> 邮件列表或论坛中提问。尽管程序员们 <strong> 会 </strong> 看出来，但一些有经验的使用者也许仍会给你一些提示。</p><h3 id="去掉无意义的提问句"><a href="#去掉无意义的提问句" class="headerlink" title="去掉无意义的提问句"></a>去掉无意义的提问句</h3><p>避免用无意义的话结束提问，例如 <code>有人能帮我吗？</code> 或者 <code>这有答案吗？</code>。</p><p>首先：如果你对问题的描述不是很好，这样问更是画蛇添足。</p><p>其次：由于这样问是画蛇添足，程序员们会很厌烦你 – 而且通常会用逻辑上正确，但毫无意义的回答来表示他们的蔑视， 例如：<code>没错，有人能帮你</code> 或者 <code>不，没答案</code>。</p><p>一般来说，避免用 <code>是或否</code>、<code>对或错</code>、<code>有或没有</code> 类型的问句，除非你想得到 <a href="http://homepage.ntlworld.com./jonathan.deboynepollard/FGA/questions-with-yes-or-no-answers.html" target="_blank" rel="noopener">是或否类型的回答</a>。</p><h3 id="礼多人不怪，而且有时还很有帮助"><a href="#礼多人不怪，而且有时还很有帮助" class="headerlink" title="礼多人不怪，而且有时还很有帮助"></a>礼多人不怪，而且有时还很有帮助</h3><p>彬彬有礼，多用 <code>请</code> 和 <code>谢谢您的关注</code>，或 <code>谢谢你的关照</code>。让大家都知道你对他们花时间免费提供帮助心存感激。</p><p>坦白说，这一点并没有比清晰、正确、精准并合法语法和避免使用专用格式重要（也不能取而代之）。程序员们一般宁可读有点唐突但技术上鲜明的 Bug 报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教给我们什么来评价问题的价值的）</p><p>然而，如果你有一串的问题待解决，客气一点肯定会增加你得到有用回应的机会。</p><p>（我们注意到，自从本指南发布后，从资深程序员那里得到的唯一严重缺陷反馈，就是对预先道谢这一条。一些程序员觉得 <code>先谢了</code> 意味着事后就不用再感谢任何人的暗示。我们的建议是要么先说 <code>先谢了</code>，<strong><em> 然后 </em></strong> 事后再对回复者表示感谢，或者换种方式表达感激，譬如用 <code>谢谢你的关注</code> 或 <code>谢谢你的关照</code>。）</p><h3 id="问题解决后，加个简短的补充说明"><a href="#问题解决后，加个简短的补充说明" class="headerlink" title="问题解决后，加个简短的补充说明"></a>问题解决后，加个简短的补充说明</h3><p>问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个说明比较恰当。</p><p>最理想的方式是向最初提问的话题回复此消息，并在标题中包含 <code>已修正</code>，<code>已解决</code> 或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见讨论串 <code>问题 X</code> 和 <code>问题 X - 已解决</code> 的潜在回复者就明白不用再浪费时间了（除非他个人觉得 <code>问题 X</code> 的有趣），因此可以利用此时间去解决其它问题。</p><p>补充说明不必很长或是很深入；简单的一句 <code>你好，原来是网线出了问题！谢谢大家 – Bill</code> 比什么也不说要来的好。事实上，除非结论真的很有技术含量，否则简短可爱的小结比长篇大论更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。</p><p>对于有深度的问题，张贴调试记录的摘要是有帮助的。描述问题的最终状态，说明是什么解决了问题，在此 <strong><em> 之后 </em></strong> 才指明可以避免的盲点。避免盲点的部分应放在正确的解决方案和其它总结材料之后，而不要将此信息搞成侦探推理小说。列出那些帮助过你的名字，会让你交到更多朋友。</p><p>除了有礼貌和有内涵以外，这种类型的补充也有助于他人在邮件列表 / 新闻群组 / 论坛中搜索到真正解决你问题的方案，让他们也从中受益。</p><p>至少，这种补充有助于让每位参与协助的人因问题的解决而从中得到满足感。如果你自己不是技术专家或者程序员，那就相信我们，这种感觉对于那些你向他们求助的大师或者专家而言，是非常重要的。问题悬而未决会让人灰心；程序员们渴望看到问题被解决。好人有好报，满足他们的渴望，你会在下次提问时尝到甜头。</p><p>思考一下怎样才能避免他人将来也遇到类似的问题，自问写一份文件或加个常见问题（FAQ）会不会有帮助。如果是的话就将它们发给维护者。</p><p>在程序员中，这种良好的后继行动实际上比传统的礼节更为重要，也是你如何透过善待他人而赢得声誉的方式，这是非常有价值的资产。</p><h2 id="如何解读答案"><a href="#如何解读答案" class="headerlink" title="如何解读答案"></a>如何解读答案</h2><h3 id="RTFM-和-STFW：如何知道你已完全搞砸了"><a href="#RTFM-和-STFW：如何知道你已完全搞砸了" class="headerlink" title="RTFM 和 STFW：如何知道你已完全搞砸了"></a>RTFM 和 STFW：如何知道你已完全搞砸了</h3><p>有一个古老而神圣的传统：如果你收到 <code>RTFM （Read The Fucking Manual）</code> 的回应，回答者认为你 <strong> 应该去读他妈的手册 </strong>。当然，基本上他是对的，你应该去读一读。</p><p>RTFM 有一个年轻的亲戚。如果你收到 <code>STFW（Search The Fucking Web）</code> 的回应，回答者认为你 <strong> 应该到他妈的网上搜索 </strong> 过了。那人多半也是对的，去搜索一下吧。（更温和一点的说法是 <strong>Google 是你的朋友 </strong>！）</p><p>在论坛，你也可能被要求去爬爬论坛的旧文。事实上，有人甚至可能热心地为你提供以前解决此问题的讨论串。但不要依赖这种关照，提问前应该先搜索一下旧文。</p><p>通常，用这两句之一回答你的人会给你一份包含你需要内容的手册或者一个网址，而且他们打这些字的时候也正在读着。这些答复意味着回答者认为</p><ul><li><strong> 你需要的信息非常容易获得 </strong>；</li><li><strong> 你自己去搜索这些信息比灌给你，能让你学到更多 </strong>。</li></ul><p>你不应该因此不爽；<strong> 依照程序员的标准，他已经表示了对你一定程度的关注，而没有对你的要求视而不见 </strong>。你应该对他祖母般的慈祥表示感谢。</p><h3 id="如果还是搞不懂"><a href="#如果还是搞不懂" class="headerlink" title="如果还是搞不懂"></a>如果还是搞不懂</h3><p>如果你看不懂回应，别立刻要求对方解释。像你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），先试着去搞懂他的回应。如果你真的需要对方解释，记得表现出你已经从中学到了点什么。</p><p>比方说，如果我回答你：<code>看来似乎是 zentry 卡住了；你应该先清除它。</code>，然后，这是一个 <strong><em> 很糟的 </em></strong> 后续问题回应：<code>zentry 是什么？</code> <strong><em> 好 </em></strong> 的问法应该是这样：<code>哦 ~~~ 我看过说明了但是只有 -z 和 -p 两个参数中提到了 zentries，而且还都没有清楚的解释如何清除它。你是指这两个中的哪一个吗？还是我看漏了什么？</code></p><h3 id="处理无礼的回应"><a href="#处理无礼的回应" class="headerlink" title="处理无礼的回应"></a>处理无礼的回应</h3><p>很多程序员圈子中看似无礼的行为并不是存心冒犯。相反，它是直接了当，一针见血式的交流风格，这种风格更注重解决问题，而不是使人感觉舒服而却模模糊糊。</p><p>如果你觉得被冒犯了，试着平静地反应。如果有人真的做了出格的事，邮件列表、新闻群组或论坛中的前辈多半会招呼他。如果这 <strong><em> 没有 </em></strong> 发生而你却发火了，那么你发火对象的言语可能在程序员社区中看起来是正常的，而 <strong><em> 你 </em></strong> 将被视为有错的一方，这将伤害到你获取信息或帮助的机会。</p><p>另一方面，你偶而真的会碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击，用犀利的语言将其驳得体无完肤都是可以接受的。然而，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，程序员们自己莽撞地越线的情况并不鲜见。如果你是新手或外人，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。</p><p>（有些人断言很多程序员都有轻度的自闭症或亚斯伯格综合症，缺少用于润滑人类社会 <strong> 正常 </strong> 交往所需的神经。这既可能是真也可能是假的。如果你自己不是程序员，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们 <strong><em> 喜欢 </em></strong> 我们现在这个样子，并且通常对病患标记都有站得住脚的怀疑。）</p><p>Jeff Bigler 的观察总结和这个相关也值得一读 (<strong>tact filters</strong>)。</p><p>在下一节，我们会谈到另一个问题，当 <strong><em> 你 </em></strong> 行为不当时所会受到的 <code>冒犯</code>。</p><h2 id="如何避免扮演失败者"><a href="#如何避免扮演失败者" class="headerlink" title="如何避免扮演失败者"></a>如何避免扮演失败者</h2><p>在程序员社区的论坛中有那么几次你可能会搞砸 – 以本指南所描述到的或类似的方式。而你会在公开场合中被告知你是如何搞砸的，也许攻击的言语中还会带点夹七夹八的颜色。</p><p>这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被口头攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、忘了关马桶盖等等。相反地，你该这么做：</p><p>熬过去，这很正常。事实上，它是有益健康且合理的。</p><p>社区的标准不会自行维持，它们是通过参与者积极而 <strong><em> 公开地 </em></strong> 执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，它不是这样运作的。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。</p><p>也有其它的程序员论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称 <code>如果你不想帮助用户就闭嘴。</code> 结果造成有想法的参与者纷纷离开，这么做只会使它们沦为毫无意义的唠叨与无用的技术论坛。</p><p>夸张的讲法是：你要的是 <strong> 友善 </strong>（以上述方式）还是有用？两个里面挑一个。</p><p>记着：当程序员说你搞砸了，并且（无论多么刺耳）告诉你别再这样做时，他正在为关心 <strong> 你 </strong> 和 <strong> 他的社区 </strong> 而行动。对他而言，不理你并将你从他的生活中滤掉更简单。如果你无法做到感谢，至少要表现得有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人像对待脆弱的洋娃娃那样对你。</p><p>有时候，即使你没有搞砸（或者只是在他的想像中你搞砸了），有些人也会无缘无故地攻击你本人。在这种情况下，抱怨倒是 <strong><em> 真的 </em></strong> 会把问题搞砸。</p><p>这些来找麻烦的人要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些来找麻烦的人在给他们自己找麻烦，这点你不用操心。</p><p>也别让自己卷入口水战，最好不要理睬大多数的口水战 – 当然，这是在你检验它们只是口水战，并且未指出你有搞砸的地方，同时也没有巧妙地将问题真正的答案藏于其后（这也是有可能的）。</p><h2 id="不该问的问题"><a href="#不该问的问题" class="headerlink" title="不该问的问题"></a>不该问的问题</h2><p>以下是几个经典蠢问题，以及程序员没回答时心中所想的：</p><p>问题：<a href="https://github.com/aptx4869yuyang2017/How-To-Ask-Questions-The-Smart-Way#q1" target="_blank" rel="noopener">我能在哪找到 X 程序或 X 资源？</a></p><p>问题：<a href="https://github.com/aptx4869yuyang2017/How-To-Ask-Questions-The-Smart-Way#q2" target="_blank" rel="noopener">我怎样用 X 做 Y？</a></p><p>问题：<a href="https://github.com/aptx4869yuyang2017/How-To-Ask-Questions-The-Smart-Way#q3" target="_blank" rel="noopener">如何设定我的 shell 提示？</a></p><p>问题：<a href="https://github.com/aptx4869yuyang2017/How-To-Ask-Questions-The-Smart-Way#q4" target="_blank" rel="noopener">我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？</a></p><p>问题：<a href="https://github.com/aptx4869yuyang2017/How-To-Ask-Questions-The-Smart-Way#q5" target="_blank" rel="noopener">我的程序 / 设定 /SQL 语句没有用</a></p><p>问题：<a href="https://github.com/aptx4869yuyang2017/How-To-Ask-Questions-The-Smart-Way#q6" target="_blank" rel="noopener">我的 Windows 电脑有问题，你能帮我吗？</a></p><p>问题：<a href="https://github.com/aptx4869yuyang2017/How-To-Ask-Questions-The-Smart-Way#q7" target="_blank" rel="noopener">我的程序不会动了，我认为系统工具 X 有问题</a></p><p>问题：<a href="https://github.com/aptx4869yuyang2017/How-To-Ask-Questions-The-Smart-Way#q8" target="_blank" rel="noopener">我在安装 Linux（或者 X ）时有问题，你能帮我吗？</a></p><p>问题：<a href="https://github.com/aptx4869yuyang2017/How-To-Ask-Questions-The-Smart-Way#q9" target="_blank" rel="noopener">我怎么才能破解 root 帐号 / 窃取 OP 特权 / 读别人的邮件呢？</a></p><hr><blockquote><p>问题：我能在哪找到 X 程序或 X 资源？</p></blockquote><p>回答：就在我找到它的地方啊，白痴 – 搜索引擎的那一头。天哪！难道还有人不会用 <a href="http://www.google.com/" target="_blank" rel="noopener">Google</a> 吗？</p><blockquote><p>问题：我怎样用 X 做 Y？</p></blockquote><p>回答：如果你想解决的是 Y ，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对 Y 要解决的问题糊涂，还被特定形势禁锢了思维。最好忽略这种人，等他们把问题搞清楚了再说。</p><blockquote><p>问题：如何设定我的 shell 提示？？</p></blockquote><p>回答：如果你有足够的智慧提这个问题，你也该有足够的智慧去 <a href="https://github.com/aptx4869yuyang2017/How-To-Ask-Questions-The-Smart-Way#RTFM" target="_blank" rel="noopener">RTFM</a>，然后自己去找出来。</p><blockquote><p>问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？</p></blockquote><p>回答：试试看就知道了。如果你试过，你既知道了答案，就不用浪费我的时间了。</p><blockquote><p>问题：我的 {程序 / 设定 /SQL 语句} 不工作</p></blockquote><p>回答：这不算是问题吧，我对要我问你二十个问题才找得出你真正问题的问题没兴趣 – 我有更有意思的事要做呢。在看到这类问题的时候，我的反应通常不外如下三种</p><ul><li>你还有什么要补充的吗？</li><li>真糟糕，希望你能搞定。</li><li>这关我有什么屁事？</li></ul><blockquote><p>问题：我的 Windows 电脑有问题，你能帮我吗？</p></blockquote><p>回答：能啊，扔掉微软的垃圾，换个像 Linux 或 BSD 的开放源代码操作系统吧。</p><p>注意：如果程序有官方版 Windows 或者与 Windows 有互动（如 Samba），你 <strong><em> 可以 </em></strong> 问与 Windows 相关的问题， 只是别对问题是由 Windows 操作系统而不是程序本身造成的回复感到惊讶， 因为 Windows 一般来说实在太烂，这种说法通常都是对的。</p><blockquote><p>问题：我的程序不会动了，我认为系统工具 X 有问题</p></blockquote><p>回答：你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与函数库档案有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文件作后盾。</p><blockquote><p>问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？</p></blockquote><p>回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的 Linux 使用群组者寻求实际的指导吧（你能在 <a href="http://www.linux.org/groups/index.html" target="_blank" rel="noopener">这儿</a> 找到使用者群组的清单）。</p><p>注意：如果安装问题与某 Linux 的发行版有关，在它的邮件列表、论坛或本地使用者群组中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 <code>Linux</code> 和 <strong><em> 所有 </em></strong> 被怀疑的硬件作关键词仔细搜索。</p><blockquote><p>问题：我怎么才能破解 root 帐号 / 窃取 OP 特权 / 读别人的邮件呢？</p></blockquote><p>回答：想要这样做，说明了你是个卑鄙小人；想找个程序员帮你，说明你是个白痴！</p><h2 id="好问题与蠢问题"><a href="#好问题与蠢问题" class="headerlink" title="好问题与蠢问题"></a>好问题与蠢问题</h2><p>最后，我将透过举一些例子，来说明怎样聪明的提问；同一个问题的两种问法被放在一起，一种是愚蠢的，另一种才是明智的。</p><p><strong> 蠢问题 </strong>：</p><blockquote><p>我可以在哪儿找到关于 Foonly Flurbamatic 的资料？</p></blockquote><p>这种问法无非想得到 <a href="https://github.com/aptx4869yuyang2017/How-To-Ask-Questions-The-Smart-Way#RTFM" target="_blank" rel="noopener">STFW</a> 这样的回答。</p><p><strong> 聪明问题 </strong>：</p><blockquote><p>我用 Google 搜索过 “Foonly Flurbamatic 2600”，但是没找到有用的结果。谁知道上哪儿去找对这种设备编程的资料？</p></blockquote><p>这个问题已经 STFW 过了，看起来他真的遇到了麻烦。</p><p><strong> 蠢问题 </strong></p><blockquote><p>我从 foo 项目找来的源码没法编译。它怎么这么烂？</p></blockquote><p>他觉得都是别人的错，这个傲慢自大的提问者。</p><p><strong> 聪明问题 </strong></p><blockquote><p>foo 项目代码在 Nulix 6.2 版下无法编译通过。我读过了 FAQ，但里面没有提到跟 Nulix 有关的问题。这是我编译过程的记录，我有什么做的不对的地方吗？</p></blockquote><p>提问者已经指明了环境，也读过了 FAQ，还列出了错误，并且他没有把问题的责任推到别人头上，他的问题值得被关注。</p><p><strong> 蠢问题 </strong></p><blockquote><p>我的主机板有问题了，谁来帮我？</p></blockquote><p>某程序员对这类问题的回答通常是：<code>好的，还要帮你拍拍背和换尿布吗？</code>，然后按下删除键。</p><p><strong> 聪明问题 </strong></p><blockquote><p>我在 S2464 主机板上试过了 X 、 Y 和 Z ，但没什么作用，我又试了 A 、 B 和 C 。请注意当我尝试 C 时的奇怪现象。显然 florbish 正在 grommicking，但结果出人意料。通常在 Athlon MP 主机板上引起 grommicking 的原因是什么？有谁知道接下来我该做些什么测试才能找出问题？</p></blockquote><p>这个家伙，从另一个角度来看，值得去回答他。他表现出了解决问题的能力，而不是坐等天上掉答案。</p><p>在最后一个问题中，注意 <code>告诉我答案</code> 和 <code>给我启示，指出我还应该做什么诊断工作</code> 之间微妙而又重要的区别。</p><p>事实上，后一个问题源自于 2001 年 8 月在 Linux 内核邮件列表（lkml）上的一个真实的提问。我（Eric）就是那个提出问题的人。我在 Tyan S2464 主板上观察到了这种无法解释的锁定现象，列表成员们提供了解决这一问题的重要信息。</p><p>通过我的提问方法，我给了别人可以咀嚼玩味的东西；我设法让人们很容易参与并且被吸引进来。我显示了自己具备和他们同等的能力，并邀请他们与我共同探讨。通过告诉他们我所走过的弯路，以避免他们再浪费时间，我也表明了对他们宝贵时间的尊重。</p><p>事后，当我向每个人表示感谢，并且赞赏这次良好的讨论经历的时候， 一个 Linux 内核邮件列表的成员表示，他觉得我的问题得到解决并非由于我是这个列表中的 <strong><em> 名人 </em></strong>，而是因为我用了正确的方式来提问。</p><p>程序员从某种角度来说是拥有丰富知识但缺乏人情味的家伙；我相信他是对的，如果我 <strong><em> 像 </em></strong> 个乞讨者那样提问，不论我是谁，一定会惹恼某些人或者被他们忽视。他建议我记下这件事，这直接导致了本指南的出现。</p><h2 id="如果得不到回答"><a href="#如果得不到回答" class="headerlink" title="如果得不到回答"></a>如果得不到回答</h2><p>如果仍得不到回答，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。</p><p>总的来说，简单的重复张贴问题是个很糟的点子。这将被视为无意义的喧闹。有点耐心，知道你问题答案的人可能生活在不同的时区，可能正在睡觉，也有可能你的问题一开始就没有组织好。</p><p>你可以通过其他渠道获得帮助，这些渠道通常更适合初学者的需要。</p><p>有许多网上的以及本地的使用者群组，由热情的软件爱好者（即使他们可能从没亲自写过任何软件）组成。通常人们组建这样的团体来互相帮助并帮助新手。</p><p>另外，你可以向很多商业公司寻求帮助，不论公司大还是小。别为要付费才能获得帮助而感到沮丧！毕竟，假使你的汽车发动机汽缸密封圈爆掉了 – 完全可能如此 – 你还得把它送到修车铺，并且为维修付费。就算软件没花费你一分钱，你也不能强求技术支持总是免费的。</p><p>对像是 Linux 这种大众化的软件，每个开发者至少会对应到上万名使用者。根本不可能由一个人来处理来自上万名使用者的求助电话。要知道，即使你要为这些协助付费，和你所购买的同类软件相比，你所付出的也是微不足道的（通常封闭源代码软件的技术支持费用比开放源代码软件的要高得多，且内容也没那么丰富）。</p><h2 id="如何更好地回答问题"><a href="#如何更好地回答问题" class="headerlink" title="如何更好地回答问题"></a>如何更好地回答问题</h2><p><strong> 态度和善一点 </strong>。问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。</p><p><strong> 对初犯者私下回复 </strong>。对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。</p><p><strong> 如果你不确定，一定要说出来 </strong>！一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。</p><p><strong> 如果帮不了忙，也别妨碍他 </strong>。不要在实际步骤上开玩笑，那样也许会毁了使用者的设置 – 有些可怜的呆瓜会把它当成真的指令。</p><p><strong> 试探性的反问以引出更多的细节 </strong>。如果你做得好，提问者可以学到点东西 – 你也可以。试试将蠢问题转变成好问题，别忘了我们都曾是新手。</p><p>尽管对那些懒虫抱怨一声 RTFM 是正当的，能指出文件的位置（即使只是建议个 Google 搜索关键词）会更好。</p><p><strong> 如果你决定回答，就请给出好的答案 </strong>。当别人正在用错误的工具或方法时别建议笨拙的权宜之计（wordaround），应推荐更好的工具，重新界定问题。</p><p><strong> 正面的回答问题 </strong>！如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但没得到结果，回答 <code>试试看 A 或是 B</code> 或者 <code>试试 X 、 Y 、 Z 、 A 、 B 、 C</code> 并附上一个链接一点用都没有。</p><p><strong> 帮助你的社区从问题中学习 </strong>。当回复一个好问题时，问问自己 <code>如何修改相关文件或常见问题文件以免再次解答同样的问题？</code>，接着再向文件维护者发一份补丁。</p><p>如果你是在研究一番后才做出的回答，<strong> 展现你的技巧而不是直接端出结果 </strong>。毕竟 <code>授人以鱼不如授人以渔</code>。</p><blockquote><p>tips：还有一点博主我觉得挺重要的：如果有妹子私聊你请教问题，请务必不要介意本文介绍的反例。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每一个不恰当的提问都在消耗别人对你的耐心，程序员届早已经有了诸如《提问的智慧》之类的经典文章介绍了什么是蠢问题，如何避免问蠢问题。然而，常年混迹于十几个技术交流微信群的我，发现很多小白程序员并不懂得这一点，为改善微信群的技术交流氛围，转此文，意图是让大家在担任提问者的角色时，尽可能提高提问的素质，让自己成为值得被教的人。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;原文出处：&lt;a href=&quot;https://github.com/aptx4869yuyang2017/How-To-Ask-Questions-The-Smart-Way&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/aptx4869yuyang2017/How-To-Ask-Questions-The-Smart-Way&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="技术杂谈" scheme="http://lexburner.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="技术杂谈" scheme="http://lexburner.github.io/tags/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>一种心跳，两种设计</title>
    <link href="http://lexburner.github.io/heartbeat-design/"/>
    <id>http://lexburner.github.io/heartbeat-design/</id>
    <published>2019-01-11T22:24:09.000Z</published>
    <updated>2019-09-26T09:45:29.612Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h3><p>在前一篇文章 <strong>《聊聊 TCP 长连接和心跳那些事》</strong> 中，我们已经聊过了 TCP 中的 KeepAlive，以及在应用层设计心跳的意义，但却对长连接心跳的设计方案没有做详细地介绍。事实上，设计一个好的心跳机制并不是一件容易的事，就我所熟知的几个 RPC 框架，它们的心跳机制可以说大相径庭，这篇文章我将探讨一下 <strong> 如何设计一个优雅的心跳机制，主要从 Dubbo 的现有方案以及一个改进方案来做分析 </strong>。</p><a id="more"></a><h3 id="2-预备知识"><a href="#2-预备知识" class="headerlink" title="2 预备知识"></a>2 预备知识</h3><p>因为后续我们将从源码层面来进行介绍，所以一些服务治理框架的细节还需要提前交代一下，方便大家理解。</p><h4 id="2-1-客户端如何得知请求失败了？"><a href="#2-1-客户端如何得知请求失败了？" class="headerlink" title="2.1 客户端如何得知请求失败了？"></a>2.1 客户端如何得知请求失败了？</h4><p>高性能的 RPC 框架几乎都会选择使用 Netty 来作为通信层的组件，非阻塞式通信的高效不需要我做过多的介绍。但也由于非阻塞的特性，导致其发送数据和接收数据是一个异步的过程，所以当存在服务端异常、网络问题时，客户端接是接收不到响应的，那我们如何判断一次 RPC 调用是失败的呢？</p><p>误区一：Dubbo 调用不是默认同步的吗？</p><p>Dubbo 在通信层是异步的，呈现给使用者同步的错觉是因为内部做了阻塞等待，实现了异步转同步。</p><p>误区二： <code>Channel.writeAndFlush</code> 会返回一个 <code>channelFuture</code>，我只需要判断 <code>channelFuture.isSuccess</code> 就可以判断请求是否成功了。</p><p>注意，writeAndFlush 成功并不代表对端接受到了请求，返回值为 true 只能保证写入网络缓冲区成功，并不代表发送成功。</p><p>避开上述两个误区，我们再来回到本小节的标题：客户端如何得知请求失败？<strong> 正确的逻辑应当是以客户端接收到失败响应为判断依据 </strong>。等等，前面不还在说在失败的场景中，服务端是不会返回响应的吗？没错，既然服务端不会返回，那就只能客户端自己造了。</p><p>一个常见的设计是：客户端发起一个 RPC 请求，会设置一个超时时间 <code>client_timeout</code>，发起调用的同时，客户端会开启一个延迟 <code>client_timeout</code> 的定时器</p><ul><li>接收到正常响应时，移除该定时器。</li><li>定时器倒计时完毕，还没有被移除，则认为请求超时，构造一个失败的响应传递给客户端。</li></ul><p>Dubbo 中的超时判定逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DefaultFuture <span class="title">newFuture</span><span class="params">(Channel channel, Request request, <span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> DefaultFuture future = <span class="keyword">new</span> DefaultFuture(channel, request, timeout);</span><br><span class="line">    <span class="comment">// timeout check</span></span><br><span class="line">    timeoutCheck(future);</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timeoutCheck</span><span class="params">(DefaultFuture future)</span> </span>&#123;</span><br><span class="line">    TimeoutCheckTask task = <span class="keyword">new</span> TimeoutCheckTask(future);</span><br><span class="line">    TIME_OUT_TIMER.newTimeout(task, future.getTimeout(), TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeoutCheckTask</span> <span class="keyword">implements</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DefaultFuture future;</span><br><span class="line">    TimeoutCheckTask(DefaultFuture future) &#123;</span><br><span class="line">        <span class="keyword">this</span>.future = future;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (future == <span class="keyword">null</span> || future.isDone()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// create exception response.</span></span><br><span class="line">        Response timeoutResponse = <span class="keyword">new</span> Response(future.getId());</span><br><span class="line">        <span class="comment">// set timeout status.</span></span><br><span class="line">        timeoutResponse.setStatus(future.isSent() ? Response.SERVER_TIMEOUT : Response.CLIENT_TIMEOUT);</span><br><span class="line">        timeoutResponse.setErrorMessage(future.getTimeoutMessage(<span class="keyword">true</span>));</span><br><span class="line">        <span class="comment">// handle response.</span></span><br><span class="line">        DefaultFuture.received(future.getChannel(), timeoutResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要逻辑涉及的类：<code>DubboInvoker</code>，<code>HeaderExchangeChannel</code>，<code>DefaultFuture</code> ，通过上述代码，我们可以得知一个细节，无论是何种调用，都会经过这个定时器的检测，<strong> 超时即调用失败，一次 RPC 调用的失败，必须以客户端收到失败响应为准 </strong>。</p><h4 id="2-2-心跳检测需要容错"><a href="#2-2-心跳检测需要容错" class="headerlink" title="2.2 心跳检测需要容错"></a>2.2 心跳检测需要容错</h4><p>网络通信永远要考虑到最坏的情况，一次心跳失败，不能认定为连接不通，多次心跳失败，才能采取相应的措施。</p><h4 id="2-3-心跳检测不需要忙检测"><a href="#2-3-心跳检测不需要忙检测" class="headerlink" title="2.3 心跳检测不需要忙检测"></a>2.3 心跳检测不需要忙检测</h4><p>忙检测的对立面是空闲检测，我们做心跳的初衷，是为了保证连接的可用性，以保证及时采取断连，重连等措施。如果一条通道上有频繁的 RPC 调用正在进行，我们不应该为通道增加负担去发送心跳包。<strong> 心跳扮演的角色应当是晴天收伞，雨天送伞。</strong></p><h3 id="3-Dubbo-现有方案"><a href="#3-Dubbo-现有方案" class="headerlink" title="3 Dubbo 现有方案"></a>3 Dubbo 现有方案</h3><blockquote><p>本文的源码对应 Dubbo  2.7.x 版本，在 apache 孵化的该版本中，心跳机制得到了增强。</p></blockquote><p>介绍完了一些基础的概念，我们再来看看 Dubbo 是如何设计应用层心跳的。Dubbo 的心跳是双向心跳，客户端会给服务端发送心跳，反之，服务端也会向客户端发送心跳。</p><h4 id="3-1-连接建立时创建定时器"><a href="#3-1-连接建立时创建定时器" class="headerlink" title="3.1 连接建立时创建定时器"></a>3.1 连接建立时创建定时器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderExchangeClient</span> <span class="keyword">implements</span> <span class="title">ExchangeClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> heartbeat;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> heartbeatTimeout;</span><br><span class="line">    <span class="keyword">private</span> HashedWheelTimer heartbeatTimer;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeaderExchangeClient</span><span class="params">(Client client, <span class="keyword">boolean</span> needHeartbeat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">        <span class="keyword">this</span>.channel = <span class="keyword">new</span> HeaderExchangeChannel(client);</span><br><span class="line">        <span class="keyword">this</span>.heartbeat = client.getUrl().getParameter(Constants.HEARTBEAT_KEY, dubbo != <span class="keyword">null</span> &amp;&amp; dubbo.startsWith(<span class="string">"1.0."</span>) ? Constants.DEFAULT_HEARTBEAT : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>.heartbeatTimeout = client.getUrl().getParameter(Constants.HEARTBEAT_TIMEOUT_KEY, heartbeat * <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span> (needHeartbeat) &#123; &lt;<span class="number">1</span>&gt;</span><br><span class="line">            <span class="keyword">long</span> tickDuration = calculateLeastDuration(heartbeat);</span><br><span class="line">            heartbeatTimer = <span class="keyword">new</span> HashedWheelTimer(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"dubbo-client-heartbeat"</span>, <span class="keyword">true</span>), tickDuration,</span><br><span class="line">                    TimeUnit.MILLISECONDS, Constants.TICKS_PER_WHEEL); &lt;<span class="number">2</span>&gt;</span><br><span class="line">            startHeartbeatTimer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><1> <strong> 默认开启心跳检测的定时器 </strong></1></p><p><2> <strong> 创建了一个 <code>HashedWheelTimer</code> 开启心跳检测 </strong>，这是 Netty 所提供的一个经典的时间轮定时器实现，至于它和 jdk 的实现有何不同，不了解的同学也可以关注下，我就不拓展了。</2></p><p>不仅 <code>HeaderExchangeClient</code> 客户端开起了定时器，<code>HeaderExchangeServer</code> 服务端同样开起了定时器，由于服务端的逻辑和客户端几乎一致，所以后续我并不会重复粘贴服务端的代码。</p><blockquote><p>Dubbo 在早期版本版本中使用的是 schedule 方案，在 2.7.x 中替换成了 HashWheelTimer。</p></blockquote><h4 id="3-2-开启两个定时任务"><a href="#3-2-开启两个定时任务" class="headerlink" title="3.2 开启两个定时任务"></a>3.2 开启两个定时任务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startHeartbeatTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> heartbeatTick = calculateLeastDuration(heartbeat);</span><br><span class="line">    <span class="keyword">long</span> heartbeatTimeoutTick = calculateLeastDuration(heartbeatTimeout);</span><br><span class="line">    HeartbeatTimerTask heartBeatTimerTask = <span class="keyword">new</span> HeartbeatTimerTask(cp, heartbeatTick, heartbeat); &lt;<span class="number">1</span>&gt;</span><br><span class="line">    ReconnectTimerTask reconnectTimerTask = <span class="keyword">new</span> ReconnectTimerTask(cp, heartbeatTimeoutTick, heartbeatTimeout); &lt;<span class="number">2</span>&gt;</span><br><span class="line"></span><br><span class="line">    heartbeatTimer.newTimeout(heartBeatTimerTask, heartbeatTick, TimeUnit.MILLISECONDS);</span><br><span class="line">    heartbeatTimer.newTimeout(reconnectTimerTask, heartbeatTimeoutTick, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dubbo 在 <code>startHeartbeatTimer</code> 方法中主要开启了两个定时器： <code>HeartbeatTimerTask</code>，<code>ReconnectTimerTask</code> </p><p><1> <code>HeartbeatTimerTask</code> 主要用于定时发送心跳请求</1></p><p><2> <code>ReconnectTimerTask</code>  主要用于心跳失败之后处理重连，断连的逻辑</2></p><p>至于方法中的其他代码，其实也是本文的重要分析内容，先容我卖个关子，后面再来看追溯。</p><h4 id="3-3-定时任务一：发送心跳请求"><a href="#3-3-定时任务一：发送心跳请求" class="headerlink" title="3.3 定时任务一：发送心跳请求"></a>3.3 定时任务一：发送心跳请求</h4><p>详细解析下心跳检测定时任务的逻辑 <code>HeartbeatTimerTask#doTask</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doTask</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    Long lastRead = lastRead(channel);</span><br><span class="line">    Long lastWrite = lastWrite(channel);</span><br><span class="line">    <span class="keyword">if</span> ((lastRead != <span class="keyword">null</span> &amp;&amp; now() - lastRead &gt; heartbeat)</span><br><span class="line">        || (lastWrite != <span class="keyword">null</span> &amp;&amp; now() - lastWrite &gt; heartbeat)) &#123;</span><br><span class="line">            Request req = <span class="keyword">new</span> Request();</span><br><span class="line">            req.setVersion(Version.getProtocolVersion());</span><br><span class="line">            req.setTwoWay(<span class="keyword">true</span>);</span><br><span class="line">            req.setEvent(Request.HEARTBEAT_EVENT);</span><br><span class="line">            channel.send(req);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面已经介绍过，<strong>Dubbo 采取的是是双向心跳设计 </strong>，即服务端会向客户端发送心跳，客户端也会向服务端发送心跳，接收的一方更新 lastRead 字段，发送的一方更新 lastWrite 字段，超过心跳间隙的时间，便发送心跳请求给对端。这里的 lastRead/lastWrite 同样会被同一个通道上的普通调用更新，通过更新这两个字段，实现了只在连接空闲时才会真正发送空闲报文的机制，符合我们一开始科普的做法。</p><blockquote><p>注意：不仅仅心跳请求会更新 lastRead 和 lastWrite，普通请求也会。这对应了我们预备知识中的空闲检测机制。</p></blockquote><h4 id="3-4-定时任务二：处理重连和断连"><a href="#3-4-定时任务二：处理重连和断连" class="headerlink" title="3.4 定时任务二：处理重连和断连"></a>3.4 定时任务二：处理重连和断连</h4><p>继续研究下重连和断连定时器都实现了什么 <code>ReconnectTimerTask#doTask</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doTask</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    Long lastRead = lastRead(channel);</span><br><span class="line">    Long now = now();</span><br><span class="line">    <span class="keyword">if</span> (lastRead != <span class="keyword">null</span> &amp;&amp; now - lastRead &gt; heartbeatTimeout) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel <span class="keyword">instanceof</span> Client) &#123;</span><br><span class="line">            ((Client) channel).reconnect();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个定时器则负责根据客户端、服务端类型来对连接做不同的处理，当超过设置的心跳总时间之后，客户端选择的是重新连接，服务端则是选择直接断开连接。这样的考虑是合理的，客户端调用是强依赖可用连接的，而服务端可以等待客户端重新建立连接。</p><blockquote><p>细心的朋友会发现，这个类被命名为 ReconnectTimerTask 是不太准确的，因为它处理的是重连和断连两个逻辑。</p></blockquote><h4 id="3-5-定时不精确的问题"><a href="#3-5-定时不精确的问题" class="headerlink" title="3.5 定时不精确的问题"></a>3.5 定时不精确的问题</h4><p>在 Dubbo 的 issue 中曾经有人反馈过定时不精确的问题，我们来看看是怎么一回事。</p><p>Dubbo 中默认的心跳周期是 60s，设想如下的时序：</p><ul><li>第 0 秒，心跳检测发现连接活跃</li><li>第 1 秒，连接实际断开</li><li>第 60 秒，心跳检测发现连接不活跃</li></ul><p>由于 <strong> 时间窗口的问题，死链不能够被及时检测出来，最坏情况为一个心跳周期 </strong>。</p><p>为了解决上述问题，我们再倒回去看一下上面的 <code>startHeartbeatTimer()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> heartbeatTick = calculateLeastDuration(heartbeat); </span><br><span class="line"><span class="keyword">long</span> heartbeatTimeoutTick = calculateLeastDuration(heartbeatTimeout);</span><br></pre></td></tr></table></figure><p>其中 <code>calculateLeastDuration</code> 根据心跳时间和超时时间分别计算出了一个 tick 时间，实际上就是将两个变量除以了 3，使得他们的值缩小，并传入了 <code>HashedWheelTimer</code> 的第二个参数之中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">heartbeatTimer.newTimeout(heartBeatTimerTask, heartbeatTick, TimeUnit.MILLISECONDS);</span><br><span class="line">heartbeatTimer.newTimeout(reconnectTimerTask, heartbeatTimeoutTick, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><p>tick 的含义便是定时任务执行的频率。这样，通过减少检测间隔时间，增大了及时发现死链的概率，原先的最坏情况是 60s，如今变成了 20s。这个频率依旧可以加快，但需要考虑资源消耗的问题。</p><blockquote><p>定时不准确的问题出现在 Dubbo 的两个定时任务之中，所以都做了 tick 操作。事实上，所有的定时检测的逻辑都存在类似的问题。</p></blockquote><h4 id="3-6-Dubbo-心跳总结"><a href="#3-6-Dubbo-心跳总结" class="headerlink" title="3.6 Dubbo 心跳总结"></a>3.6 Dubbo 心跳总结</h4><p>Dubbo 对于建立的每一个连接，同时在客户端和服务端开启了 2 个定时器，一个用于定时发送心跳，一个用于定时重连、断连，执行的频率均为各自检测周期的 1/3。定时发送心跳的任务负责在连接空闲时，向对端发送心跳包。定时重连、断连的任务负责检测 lastRead 是否在超时周期内仍未被更新，如果判定为超时，客户端处理的逻辑是重连，服务端则采取断连的措施。</p><p>先不急着判断这个方案好不好，再来看看改进方案是怎么设计的。</p><h3 id="4-Dubbo-改进方案"><a href="#4-Dubbo-改进方案" class="headerlink" title="4 Dubbo 改进方案"></a>4 Dubbo 改进方案</h3><p>实际上我们可以更优雅地实现心跳机制，本小节开始，我将介绍一个新的心跳机制。</p><h4 id="4-1-IdleStateHandler-介绍"><a href="#4-1-IdleStateHandler-介绍" class="headerlink" title="4.1 IdleStateHandler 介绍"></a>4.1 IdleStateHandler 介绍</h4><p>Netty 对空闲连接的检测提供了天然的支持，使用 <code>IdleStateHandler</code> 可以很方便的实现空闲检测逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdleStateHandler</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> readerIdleTime, <span class="keyword">long</span> writerIdleTime, <span class="keyword">long</span> allIdleTime,</span></span></span><br><span class="line"><span class="function"><span class="params">            TimeUnit unit)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>readerIdleTime：读超时时间</li><li>writerIdleTime：写超时时间</li><li>allIdleTime：所有类型的超时时间</li></ul><p><code>IdleStateHandler</code> 这个类会根据设置的超时参数，循环检测 channelRead 和 write 方法多久没有被调用。当在 pipeline 中加入 <code>IdleSateHandler</code> 之后，可以在此 pipeline 的任意 Handler 的 <code>userEventTriggered</code> 方法之中检测 <code>IdleStateEvent</code> 事件，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    ctx.fireUserEventTriggered(evt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么需要介绍 <code>IdleStateHandler</code> 呢？其实提到它的空闲检测 + 定时的时候，大家应该能够想到了，这不天然是给心跳机制服务的吗？很多服务治理框架都选择了借助 <code>IdleStateHandler</code> 来实现心跳。</p><blockquote><p>IdleStateHandler 内部使用了 eventLoop.schedule(task) 的方式来实现定时任务，使用 eventLoop 线程的好处是还同时保证了 <strong> 线程安全 </strong>，这里是一个小细节。 </p></blockquote><h4 id="4-2-客户端和服务端配置"><a href="#4-2-客户端和服务端配置" class="headerlink" title="4.2 客户端和服务端配置"></a>4.2 客户端和服务端配置</h4><p>首先是将 <code>IdleStateHandler</code> 加入 pipeline 中。</p><p><strong> 客户端：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ch.pipeline().addLast(<span class="string">"clientIdleHandler"</span>, <span class="keyword">new</span> IdleStateHandler(<span class="number">60</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong> 服务端：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ch.pipeline().addLast(<span class="string">"serverIdleHandler"</span>,<span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端配置了 read 超时为 60s，服务端配置了 write/read 超时为 200s，先在此埋下两个伏笔：</p><ol><li>为什么客户端和服务端配置的超时时间不一致？</li><li>为什么客户端检测的是读超时，而服务端检测的是读写超时？</li></ol><h4 id="4-3-空闲超时逻辑-—-客户端"><a href="#4-3-空闲超时逻辑-—-客户端" class="headerlink" title="4.3 空闲超时逻辑 — 客户端"></a>4.3 空闲超时逻辑 — 客户端</h4><p>对于空闲超时的处理逻辑，客户端和服务端是不同的。首先来看客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">        <span class="comment">// send heartbeat</span></span><br><span class="line">        sendHeartBeat();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检测到空闲超时之后，采取的行为是向服务端发送心跳包，具体是如何发送，以及处理响应的呢？伪代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendHeartBeat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Invocation invocation = <span class="keyword">new</span> Invocation();</span><br><span class="line">    invocation.setInvocationType(InvocationType.HEART_BEAT);</span><br><span class="line">    channel.writeAndFlush(invocation).addListener(<span class="keyword">new</span> CallbackFuture() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callback</span><span class="params">(Future future)</span> </span>&#123;</span><br><span class="line">            RPCResult result = future.get();</span><br><span class="line">            <span class="comment">// 超时 或者 写失败</span></span><br><span class="line">            <span class="keyword">if</span> (result.isError()) &#123;</span><br><span class="line">                channel.addFailedHeartBeatTimes();</span><br><span class="line">                <span class="keyword">if</span> (channel.getFailedHeartBeatTimes() &gt;= channel.getMaxHeartBeatFailedTimes()) &#123;</span><br><span class="line">                    channel.reconnect();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                channel.clearHeartBeatFailedTimes();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>行为并不复杂，构造一个心跳包发送到服务端，接受响应结果</p><ul><li>响应成功，清空请求失败标记</li><li>响应失败，心跳失败标记 +1，如果超过配置的失败次数，则重新连接</li></ul><blockquote><p>不仅仅是心跳，普通请求返回成功响应时也会清空标记</p></blockquote><h4 id="4-4-空闲超时逻辑-—-服务端"><a href="#4-4-空闲超时逻辑-—-服务端" class="headerlink" title="4.4 空闲超时逻辑 — 服务端"></a>4.4 空闲超时逻辑 — 服务端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">        channel.close();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端处理空闲连接的方式非常简单粗暴，直接关闭连接。</p><h4 id="4-5-改进方案心跳总结"><a href="#4-5-改进方案心跳总结" class="headerlink" title="4.5 改进方案心跳总结"></a>4.5 改进方案心跳总结</h4><ol><li><p>为什么客户端和服务端配置的超时时间不一致？</p><p>因为客户端有重试逻辑，不断发送心跳失败 n 次之后，才认为是连接断开；而服务端是直接断开，留给服务端时间得长一点。60 * 3 &lt; 200 还说明了一个问题，双方都拥有断开连接的能力，但连接的创建是由客户端主动发起的，那么客户端也更有权利去主动断开连接。</p></li><li><p>为什么客户端检测的是读超时，而服务端检测的是读写超时？</p><p>这其实是一个心跳的共识了，仔细思考一下，定时逻辑是由客户端发起的，所以整个链路中不通的情况只有可能是：服务端接收，服务端发送，客户端接收。也就是说，只有客户端的 pong，服务端的 ping，pong 的检测是有意义的。</p></li></ol><blockquote><p>主动追求别人的是你，主动说分手的也是你。</p></blockquote><p>利用 <code>IdleStateHandler</code> 实现心跳机制可以说是十分优雅的，借助 Netty 提供的空闲检测机制，利用客户端维护单向心跳，在收到 3 次心跳失败响应之后，客户端断开连接，交由异步线程重连，本质还是表现为客户端重连。服务端在连接空闲较长时间后，主动断开连接，以避免无谓的资源浪费。</p><h3 id="5-心跳设计方案对比"><a href="#5-心跳设计方案对比" class="headerlink" title="5 心跳设计方案对比"></a>5 心跳设计方案对比</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Dubbo 现有方案</th><th style="text-align:center">Dubbo 改进方案</th></tr></thead><tbody><tr><td style="text-align:center"><strong> 主体设计 </strong></td><td style="text-align:center">开启两个定时器</td><td style="text-align:center">借助 IdleStateHandler，底层使用 schedule</td></tr><tr><td style="text-align:center"><strong> 心跳方向 </strong></td><td style="text-align:center">双向</td><td style="text-align:center">单向（客户端 -&gt; 服务端）</td></tr><tr><td style="text-align:center"><strong> 心跳失败判定方式 </strong></td><td style="text-align:center">心跳成功更新标记，借助定时器定时扫描标记，如果超过心跳超时周期未更新标记，认为心跳失败。</td><td style="text-align:center">通过判断心跳响应是否失败，超过失败次数，认为心跳失败</td></tr><tr><td style="text-align:center"><strong> 扩展性 </strong></td><td style="text-align:center">Dubbo 存在 mina，grizzy 等其他通信层实现，自定义定时器很容易适配多种扩展</td><td style="text-align:center">多通信层各自实现心跳，不做心跳的抽象</td></tr><tr><td style="text-align:center"><strong> 设计性 </strong></td><td style="text-align:center">编码复杂度高，代码量大，方案复杂，不易维护</td><td style="text-align:center">编码量小，可维护性强</td></tr></tbody></table><p>私下请教过 <strong> 美团点评的长连接负责人：俞超（闪电侠）</strong>，美点使用的心跳方案和 Dubbo 改进方案几乎一致，可以说该方案是标准实现了。</p><h3 id="6-Dubbo-实际改动点建议"><a href="#6-Dubbo-实际改动点建议" class="headerlink" title="6 Dubbo 实际改动点建议"></a>6 Dubbo 实际改动点建议</h3><p>鉴于 Dubbo 存在一些其他通信层的实现，所以可以保留现有的定时发送心跳的逻辑。</p><ul><li><strong> 建议改动点一：</strong></li></ul><p>双向心跳的设计是不必要的，兼容现有的逻辑，可以让客户端在连接空闲时发送单向心跳，服务端定时检测连接可用性。定时时间尽量保证：客户端超时时间 * 3 ≈ 服务端超时时间</p><ul><li><strong> 建议改动点二：</strong></li></ul><p>去除处理重连和断连的定时任务，Dubbo 可以判断心跳请求是否响应失败，可以借鉴改进方案的设计，在连接级别维护一个心跳失败次数的标记，任意响应成功，清除标记；连续心跳失败 n 次，客户端发起重连。这样可以减少一个不必要的定时器，任何轮询的方式，都是不优雅的。</p><p>最后再聊聊可扩展性这个话题。其实我是建议把定时器交给更加底层的 Netty 去做，也就是完全使用 <code>IdleStateHandler</code> ，其他通信层组件各自实现自己的空闲检测逻辑，但是 Dubbo 中 mina，grizzy 的兼容问题囿住了我的拳脚，但试问一下，如今的 2019 年，又有多少人在使用 mina 和 grizzy？因为一些不太可能用的特性，而限制了主流用法的优化，这肯定不是什么好事。抽象，功能，可扩展性并不是越多越好，开源产品的人力资源是有限的，框架使用者的理解能力也是有限的，能解决大多数人问题的设计，才是好的设计。哎，谁让我不会 mina，grizzy，还懒得去学呢 [摊手]。</p><p><strong> 欢迎关注我的微信公众号：「Kirito 的技术分享」，关于文章的任何疑问都会得到回复，带来更多 Java 相关的技术分享。</strong></p><p><img src="http://kirito.iocoder.cn/qrcode_for_gh_c06057be7960_258%20%281%29.jpg" alt="关注微信公众号"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1 前言&quot;&gt;&lt;/a&gt;1 前言&lt;/h3&gt;&lt;p&gt;在前一篇文章 &lt;strong&gt;《聊聊 TCP 长连接和心跳那些事》&lt;/strong&gt; 中，我们已经聊过了 TCP 中的 KeepAlive，以及在应用层设计心跳的意义，但却对长连接心跳的设计方案没有做详细地介绍。事实上，设计一个好的心跳机制并不是一件容易的事，就我所熟知的几个 RPC 框架，它们的心跳机制可以说大相径庭，这篇文章我将探讨一下 &lt;strong&gt; 如何设计一个优雅的心跳机制，主要从 Dubbo 的现有方案以及一个改进方案来做分析 &lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="RPC" scheme="http://lexburner.github.io/categories/RPC/"/>
    
    
      <category term="TCP" scheme="http://lexburner.github.io/tags/TCP/"/>
    
      <category term="心跳" scheme="http://lexburner.github.io/tags/%E5%BF%83%E8%B7%B3/"/>
    
  </entry>
  
  <entry>
    <title>聊聊 TCP 长连接和心跳那些事</title>
    <link href="http://lexburner.github.io/tcp-talk/"/>
    <id>http://lexburner.github.io/tcp-talk/</id>
    <published>2019-01-06T10:24:09.000Z</published>
    <updated>2019-09-26T09:45:29.692Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>可能很多 Java 程序员对 TCP 的理解只有一个三次握手，四次握手的认识，我觉得这样的原因主要在于 TCP 协议本身稍微有点抽象（相比较于应用层的 HTTP 协议）；其次，非框架开发者不太需要接触到 TCP 的一些细节。其实我个人对 TCP 的很多细节也并没有完全理解，这篇文章主要针对微信交流群里有人提出的长连接，心跳问题，做一个统一的整理。 </p><p>在 Java 中，使用 TCP 通信，大概率会涉及到 Socket、Netty，本文将借用它们的一些 API 和设置参数来辅助介绍。</p><a id="more"></a><h3 id="长连接与短连接"><a href="#长连接与短连接" class="headerlink" title="长连接与短连接"></a>长连接与短连接</h3><p><strong>TCP 本身并没有长短连接的区别 </strong>，长短与否，完全取决于我们怎么用它。</p><ul><li>短连接：每次通信时，创建 Socket；一次通信结束，调用 socket.close()。这就是一般意义上的短连接，短连接的好处是管理起来比较简单，存在的连接都是可用的连接，不需要额外的控制手段。</li><li>长连接：每次通信完毕后，不会关闭连接，这样可以做到连接的复用。<strong> 长连接的好处是省去了创建连接的耗时。</strong></li></ul><p>短连接和长连接的优势，分别是对方的劣势。想要图简单，不追求高性能，使用短连接合适，这样我们就不需要操心连接状态的管理；想要追求性能，使用长连接，我们就需要担心各种问题：比如 <strong> 端对端连接的维护，连接的保活 </strong>。</p><p>长连接还常常被用来做数据的推送，我们大多数时候对通信的认知还是 request/response 模型，但 TCP 双工通信的性质决定了它还可以被用来做双向通信。在长连接之下，可以很方便的实现 push 模型，长连接的这一特性在本文并不会进行探讨，有兴趣的同学可以专门去搜索相关的文章。</p><p>短连接没有太多东西可以讲，所以下文我们将目光聚焦在长连接的一些问题上。纯讲理论未免有些过于单调，所以下文我借助一些 RPC 框架的实践来展开 TCP 的相关讨论。</p><h3 id="服务治理框架中的长连接"><a href="#服务治理框架中的长连接" class="headerlink" title="服务治理框架中的长连接"></a>服务治理框架中的长连接</h3><p>前面已经提到过，追求性能时，必然会选择使用长连接，所以借助 Dubbo 可以很好的来理解 TCP。我们开启两个 Dubbo 应用，一个 server 负责监听本地 20880 端口（众所周知，这是 Dubbo 协议默认的端口），一个 client 负责循环发送请求。执行 <code>lsof -i:20880</code> 命令可以查看端口的相关使用情况：</p><p><img src="http://kirito.iocoder.cn/image-20190106203341694.png" alt="image-20190106203341694"></p><ul><li><code>*:20880 (LISTEN)</code> 说明了 Dubbo 正在监听本地的 20880 端口，处理发送到本地 20880 端口的请求</li><li>后两条信息说明请求的发送情况，验证了 TCP 是一个双向的通信过程，由于我是在同一个机器开启了两个 Dubbo 应用，所以你能够看到是本地的 53078 端口与 20880 端口在通信。我们并没有手动设置 53078 这个客户端端口，它是随机的。通过这两条信息，阐释了一个事实：<strong> 即使是发送请求的一方，也需要占用一个端口 </strong>。</li><li>稍微说一下 FD 这个参数，他代表了 <strong> 文件句柄 </strong>，每新增一条连接都会占用新的文件句柄，如果你在使用 TCP 通信的过程中出现了 <code>open too many files</code> 的异常，那就应该检查一下，你是不是创建了太多连接，而没有关闭。细心的读者也会联想到长连接的另一个好处，那就是会占用较少的文件句柄。</li></ul><h3 id="长连接的维护"><a href="#长连接的维护" class="headerlink" title="长连接的维护"></a>长连接的维护</h3><p>因为客户端请求的服务可能分布在多个服务器上，客户端自然需要跟对端创建多条长连接，我们遇到的第一个问题就是如何维护长连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Channel&gt; channels = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Channel&gt;(); <span class="comment">// &lt;ip:port, channel&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> <span class="keyword">extends</span> <span class="title">AbstractServer</span> <span class="keyword">implements</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Channel&gt; channels; <span class="comment">// &lt;ip:port, channel&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Dubbo 中，客户端和服务端都使用 <code>ip:port</code> 维护了端对端的长连接，Channel 便是对连接的抽象。我们主要关注 NettyHandler 中的长连接，服务端同时维护一个长连接的集合是 Dubbo 的额外设计，我们将在后面提到。</p><p>这里插一句，解释下为什么我认为客户端的连接集合要重要一点。TCP 是一个双向通信的协议，任一方都可以是发送者，接受者，那为什么还抽象了 Client 和 Server 呢？因为 <strong> 建立连接这件事就跟谈念爱一样，必须要有主动的一方，你主动我们就会有故事 </strong>。Client 可以理解为主动建立连接的一方，实际上两端的地位可以理解为是对等的。</p><h3 id="连接的保活"><a href="#连接的保活" class="headerlink" title="连接的保活"></a>连接的保活</h3><p>这个话题就有的聊了，会牵扯到比较多的知识点。首先需要明确一点，为什么需要连接的保活？当双方已经建立了连接，但因为网络问题，链路不通，这样长连接就不能使用了。需要明确的一点是，通过 netstat，lsof 等指令查看到连接的状态处于 <code>ESTABLISHED</code> 状态并不是一件非常靠谱的事，因为连接可能已死，但没有被系统感知到，更不用提假死这种疑难杂症了。如果保证长连接可用是一件技术活。</p><h3 id="连接的保活：KeepAlive"><a href="#连接的保活：KeepAlive" class="headerlink" title="连接的保活：KeepAlive"></a>连接的保活：KeepAlive</h3><p>首先想到的是 TCP 中的 KeepAlive 机制。KeepAlive 并不是 TCP 协议的一部分，但是大多数操作系统都实现了这个机制（所以需要在操作系统层面设置 KeepAlive 的相关参数）。KeepAlive 机制开启后，在一定时间内（一般时间为 7200s，参数 <code>tcp_keepalive_time</code>）在链路上没有数据传送的情况下，TCP 层将发送相应的 KeepAlive 探针以确定连接可用性，探测失败后重试 10（参数 <code>tcp_keepalive_probes</code>）次，每次间隔时间 75s（参数 <code>tcp_keepalive_intvl</code>），所有探测失败后，才认为当前连接已经不可用。</p><p>在 Netty 中开启 KeepAlive：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure><p>Linux 操作系统中设置 KeepAlive 相关参数，修改 <code>/etc/sysctl.conf</code> 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_keepalive_time=90</span><br><span class="line">net.ipv4.tcp_keepalive_intvl=15</span><br><span class="line">net.ipv4.tcp_keepalive_probes=2</span><br></pre></td></tr></table></figure><p><strong>KeepAlive 机制是在网络层面保证了连接的可用性 </strong>，但站在应用框架层面我们认为这还不够。主要体现在三个方面：</p><ul><li>KeepAlive 的开关是在应用层开启的，但是具体参数（如重试测试，重试间隔时间）的设置却是操作系统级别的，位于操作系统的 <code>/etc/sysctl.conf</code> 配置中，这对于应用来说不够灵活。</li><li>KeepAlive 的保活机制只在链路空闲的情况下才会起到作用，假如此时有数据发送，且物理链路已经不通，操作系统这边的链路状态还是 <code>ESTABLISHED</code>，这时会发生什么？自然会走 TCP 重传机制，要知道默认的 TCP 超时重传，指数退避算法也是一个相当长的过程。</li><li>KeepAlive 本身是面向网络的，并不面向于应用，当连接不可用，可能是由于应用本身的 GC 频繁，系统 load 高等情况，但网络仍然是通的，此时，应用已经失去了活性，连接应该被认为是不可用的。</li></ul><p>我们已经为应用层面的连接保活做了足够的铺垫，下面就来一起看看，怎么在应用层做连接保活。</p><h3 id="连接的保活：应用层心跳"><a href="#连接的保活：应用层心跳" class="headerlink" title="连接的保活：应用层心跳"></a>连接的保活：应用层心跳</h3><p>终于点题了，文题中提到的 <strong> 心跳 </strong> 便是一个本文想要重点强调的另一个重要的知识点。上一节我们已经解释过了，网络层面的 KeepAlive 不足以支撑应用级别的连接可用性，本节就来聊聊应用层的心跳机制是实现连接保活的。</p><p>如何理解应用层的心跳？简单来说，就是客户端会开启一个定时任务，定时对已经建立连接的对端应用发送请求（这里的请求是特殊的心跳请求），服务端则需要特殊处理该请求，返回响应。如果心跳持续多次没有收到响应，客户端会认为连接不可用，主动断开连接。不同的服务治理框架对心跳，建连，断连，拉黑的机制有不同的策略，但大多数的服务治理框架都会在应用层做心跳，Dubbo/HSF 也不例外。</p><h3 id="应用层心跳的设计细节"><a href="#应用层心跳的设计细节" class="headerlink" title="应用层心跳的设计细节"></a>应用层心跳的设计细节</h3><p>以 Dubbo 为例，支持应用层的心跳，客户端和服务端都会开启一个 <code>HeartBeatTask</code>，客户端在 <code>HeaderExchangeClient</code> 中开启，服务端将在 <code>HeaderExchangeServer</code> 开启。文章开头埋了一个坑：Dubbo 为什么在服务端同时维护 <code>Map&lt;String,Channel&gt;</code> 呢？主要就是为了给心跳做贡献，心跳定时任务在发现连接不可用时，会根据当前是客户端还是服务端走不同的分支，客户端发现不可用，是重连；服务端发现不可用，是直接 close。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HeartBeatTask</span></span><br><span class="line"><span class="keyword">if</span> (channel <span class="keyword">instanceof</span> Client) &#123;</span><br><span class="line">    ((Client) channel).reconnect();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    channel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Dubbo 2.7.x 相比 2.6.x 做了定时心跳的优化，使用 <code>HashedWheelTimer</code> 更加精准的控制了只在连接闲置时发送心跳。</p></blockquote><p>再看看 HSF 的实现，并没有设置应用层的心跳，准确的说，是在 HSF2.2 之后，使用 Netty 提供的 <code>IdleStateHandler</code> 更加优雅的实现了应用的心跳。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline()</span><br><span class="line">        .addLast(<span class="string">"clientIdleHandler"</span>, <span class="keyword">new</span> IdleStateHandler(getHbSentInterval(), <span class="number">0</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>处理 <code>userEventTriggered</code> 中的 <code>IdleStateEvent</code> 事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">        callConnectionIdleListeners(client, (ClientStream) StreamUtils.streamOfChannel(ctx.channel()));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于客户端，HSF 使用 <code>SendHeartbeat</code> 来进行心跳，每次失败累加心跳失败的耗时，当超过最大限制时断开乱接；对于服务端 HSF 使用 <code>CloseIdle</code> 来处理闲置连接，直接关闭连接。一般来说，服务端的闲置时间会设置的稍长。</p><p>熟悉其他 RPC 框架的同学会发现，不同框架的心跳机制真的是差距非常大。心跳设计还跟连接创建，重连机制，黑名单连接相关，还需要具体框架具体分析。</p><p>除了定时任务的设计，还需要在协议层面支持心跳。最简单的例子可以参考 nginx 的健康检查，而针对 Dubbo 协议，自然也需要做心跳的支持，如果将心跳请求识别为正常流量，会造成服务端的压力问题，干扰限流等诸多问题。</p><p><img src="http://kirito.iocoder.cn/359310b9-b980-3254-aed6-78aa6c482e53.png" alt="dubbo protocol"></p><p>其中 Flag 代表了 Dubbo 协议的标志位，一共 8 个地址位。低四位用来表示消息体数据用的序列化工具的类型（默认 hessian），高四位中，第一位为 1 表示是 request 请求，第二位为 1 表示双向传输（即有返回 response），<strong> 第三位为 1 表示是心跳事件 </strong>。</p><blockquote><p>心跳请求应当和普通请求区别对待。</p></blockquote><h3 id="注意和-HTTP-的-KeepAlive-区别对待"><a href="#注意和-HTTP-的-KeepAlive-区别对待" class="headerlink" title="注意和 HTTP 的 KeepAlive 区别对待"></a>注意和 HTTP 的 KeepAlive 区别对待</h3><ul><li>HTTP 协议的 KeepAlive 意图在于连接复用，同一个连接上串行方式传递请求 - 响应数据</li><li>TCP 的 KeepAlive 机制意图在于保活、心跳，检测连接错误。</li></ul><p>这压根是两个概念。</p><h3 id="KeepAlive-常见错误"><a href="#KeepAlive-常见错误" class="headerlink" title="KeepAlive 常见错误"></a>KeepAlive 常见错误</h3><p>启用 TCP KeepAlive 的应用程序，一般可以捕获到下面几种类型错误</p><ol><li><p>ETIMEOUT 超时错误，在发送一个探测保护包经过 (tcp_keepalive_time + tcp_keepalive_intvl * tcp_keepalive_probes) 时间后仍然没有接收到 ACK 确认情况下触发的异常，套接字被关闭</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.io.IOException: Connection timed out</span><br></pre></td></tr></table></figure></li><li><p>EHOSTUNREACH host unreachable(主机不可达) 错误，这个应该是 ICMP 汇报给上层应用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.io.IOException: No route to host</span><br></pre></td></tr></table></figure></li><li><p>链接被重置，终端可能崩溃死机重启之后，接收到来自服务器的报文，然物是人非，前朝往事，只能报以无奈重置宣告之。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.io.IOException: Connection reset by peer</span><br></pre></td></tr></table></figure></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有三种使用 KeepAlive 的实践方案：</p><ol><li>默认情况下使用 KeepAlive 周期为 2 个小时，如不选择更改，属于误用范畴，造成资源浪费：内核会为每一个连接都打开一个保活计时器，N 个连接会打开 N 个保活计时器。 优势很明显：<ul><li>TCP 协议层面保活探测机制，系统内核完全替上层应用自动给做好了</li><li>内核层面计时器相比上层应用，更为高效</li><li>上层应用只需要处理数据收发、连接异常通知即可</li><li>数据包将更为紧凑</li></ul></li><li>关闭 TCP 的 KeepAlive，完全使用应用层心跳保活机制。由应用掌管心跳，更灵活可控，比如可以在应用级别设置心跳周期，适配私有协议。</li><li>业务心跳 + TCP KeepAlive 一起使用，互相作为补充，但 TCP 保活探测周期和应用的心跳周期要协调，以互补方可，不能够差距过大，否则将达不到设想的效果。</li></ol><p>各个框架的设计都有所不同，例如 Dubbo 使用的是方案三，但阿里内部的 HSF 框架则没有设置 TCP 的 KeepAlive，仅仅由应用心跳保活。和心跳策略一样，这和框架整体的设计相关。</p><p><strong> 欢迎关注我的微信公众号：「Kirito 的技术分享」</strong></p><p><img src="http://kirito.iocoder.cn/qrcode_for_gh_c06057be7960_258%20%281%29.jpg" alt="关注微信公众号"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;可能很多 Java 程序员对 TCP 的理解只有一个三次握手，四次握手的认识，我觉得这样的原因主要在于 TCP 协议本身稍微有点抽象（相比较于应用层的 HTTP 协议）；其次，非框架开发者不太需要接触到 TCP 的一些细节。其实我个人对 TCP 的很多细节也并没有完全理解，这篇文章主要针对微信交流群里有人提出的长连接，心跳问题，做一个统一的整理。 &lt;/p&gt;
&lt;p&gt;在 Java 中，使用 TCP 通信，大概率会涉及到 Socket、Netty，本文将借用它们的一些 API 和设置参数来辅助介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="RPC" scheme="http://lexburner.github.io/categories/RPC/"/>
    
    
      <category term="TCP" scheme="http://lexburner.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo 中的 URL 统一模型</title>
    <link href="http://lexburner.github.io/dubbo-url/"/>
    <id>http://lexburner.github.io/dubbo-url/</id>
    <published>2018-12-25T02:24:09.000Z</published>
    <updated>2019-09-26T09:45:31.376Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在不谈及 dubbo 时，我们大多数人对 URL 这个概念并不会感到陌生。统一资源定位器 (<a href="https://kimnote.com/rfc/cn/rfc1738.txt" target="_blank" rel="noopener">RFC1738</a>――Uniform Resource Locators (URL)）应该是最广为人知的一个 RFC 规范，它的定义也非常简单</p><blockquote><p>因特网上的可用资源可以用简单字符串来表示，该文档就是描述了这种字符串的语法和语<br>义。而这些字符串则被称为：“统一资源定位器”（URL）</p></blockquote><p><strong> 一个标准的 URL 格式 </strong> 至多可以包含如下的几个部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protocol://username:password@host:port/path?key=value&amp;key=value</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong> 一些典型 URL</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://www.facebook.com/friends?param1=value1&amp;amp;param2=value2</span><br><span class="line">https://username:password@10.20.130.230:8080/list?version=1.0.0</span><br><span class="line">ftp://username:password@192.168.1.7:21/1/read.txt</span><br></pre></td></tr></table></figure><p>当然，也有一些 <strong> 不太符合常规的 URL</strong>，也被归类到了 URL 之中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.3:20880</span><br><span class="line">url protocol = null, url host = 192.168.1.3, port = 20880, url path = null</span><br><span class="line"></span><br><span class="line">file:///home/user1/router.js?type=script</span><br><span class="line">url protocol = file, url host = null, url path = home/user1/router.js</span><br><span class="line"></span><br><span class="line">file://home/user1/router.js?type=script&lt;br&gt;</span><br><span class="line">url protocol = file, url host = home, url path = user1/router.js</span><br><span class="line"></span><br><span class="line">file:///D:/1/router.js?type=script</span><br><span class="line">url protocol = file, url host = null, url path = D:/1/router.js</span><br><span class="line"></span><br><span class="line">file:/D:/1/router.js?type=script</span><br><span class="line">同上 file:///D:/1/router.js?type=script</span><br><span class="line"></span><br><span class="line">/home/user1/router.js?type=script</span><br><span class="line">url protocol = null, url host = null, url path = home/user1/router.js</span><br><span class="line"></span><br><span class="line">home/user1/router.js?type=script</span><br><span class="line">url protocol = null, url host = home, url path = user1/router.js</span><br></pre></td></tr></table></figure><h3 id="Dubbo-中的-URL"><a href="#Dubbo-中的-URL" class="headerlink" title="Dubbo 中的 URL"></a>Dubbo 中的 URL</h3><p>在 dubbo 中，也使用了类似的 URL，主要用于在各个扩展点之间传递数据，组成此 URL 对象的具体参数如下:</p><ul><li>protocol：一般是 dubbo 中的各种协议 如：dubbo thrift http zk </li><li>username/password：用户名 / 密码</li><li>host/port：主机 / 端口</li><li>path：接口名称</li><li>parameters：参数键值对</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">URL</span><span class="params">(String protocol, String username, String password, String host, <span class="keyword">int</span> port, String path, Map&lt;String, String&gt; parameters)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> ((username == <span class="keyword">null</span> || username.length() == <span class="number">0</span>) </span><br><span class="line">         &amp;&amp; password != <span class="keyword">null</span> &amp;&amp; password.length()&gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid url, password without username!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">this</span>.protocol = protocol;</span><br><span class="line">   <span class="keyword">this</span>.username = username;</span><br><span class="line">   <span class="keyword">this</span>.password = password;</span><br><span class="line">   <span class="keyword">this</span>.host = host;</span><br><span class="line">   <span class="keyword">this</span>.port = (port &lt; <span class="number">0</span> ? <span class="number">0</span> : port);</span><br><span class="line">   <span class="keyword">this</span>.path = path;</span><br><span class="line">   <span class="comment">// trim the beginning "/"</span></span><br><span class="line">   <span class="keyword">while</span>(path != <span class="keyword">null</span> &amp;&amp; path.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">       path = path.substring(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (parameters == <span class="keyword">null</span>) &#123;</span><br><span class="line">       parameters = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       parameters = <span class="keyword">new</span> HashMap&lt;String, String&gt;(parameters);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">this</span>.parameters = Collections.unmodifiableMap(parameters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，dubbo 认为 protocol，username，passwored，host，port，path 是主要的 URL 参数，其他键值对村房子啊 parameters 之中。</p><p><strong> 一些典型的 Dubbo URL</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dubbo://192.168.1.6:20880/moe.cnkirito.sample.HelloService?timeout=3000</span><br><span class="line">描述一个 dubbo 协议的服务</span><br><span class="line"></span><br><span class="line">zookeeper://127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=demo-consumer&amp;dubbo=2.0.2&amp;interface=org.apache.dubbo.registry.RegistryService&amp;pid=1214&amp;qos.port=33333&amp;timestamp=1545721981946</span><br><span class="line">描述一个 zookeeper 注册中心</span><br><span class="line"></span><br><span class="line">consumer://30.5.120.217/org.apache.dubbo.demo.DemoService?application=demo-consumer&amp;category=consumers&amp;check=false&amp;dubbo=2.0.2&amp;interface=org.apache.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=1209&amp;qos.port=33333&amp;side=consumer&amp;timestamp=1545721827784</span><br><span class="line">描述一个消费者</span><br></pre></td></tr></table></figure><p>可以说，任意的一个领域中的一个实现都可以认为是一类 URL，dubbo 使用 URL 来统一描述了元数据，配置信息，贯穿在整个框架之中。</p><h3 id="URL-相关的生命周期"><a href="#URL-相关的生命周期" class="headerlink" title="URL 相关的生命周期"></a>URL 相关的生命周期</h3><h4 id="解析服务"><a href="#解析服务" class="headerlink" title="解析服务"></a>解析服务</h4><p>基于 dubbo.jar 内的 <code>META-INF/spring.handlers</code> 配置，Spring 在遇到 dubbo 名称空间时，会回调 <code>DubboNamespaceHandler</code>。</p><p>所有 dubbo 的标签，都统一用 <code>DubboBeanDefinitionParser</code> 进行解析，基于一对一属性映射，将 XML 标签解析为 Bean 对象。</p><p>在 <code>ServiceConfig.export()</code> 或 <code>ReferenceConfig.get()</code> 初始化时，将 Bean 对象转换 URL 格式，所有 Bean 属性转成 URL 的参数。</p><p>然后将 URL 传给协议扩展点，基于扩展点自适应机制，根据 URL 的协议头，进行不同协议的服务暴露或引用。</p><h4 id="暴露服务"><a href="#暴露服务" class="headerlink" title="暴露服务"></a>暴露服务</h4><p><strong>1. 只暴露服务端口：</strong></p><p>在没有注册中心，直接暴露提供者的情况下，<code>ServiceConfig</code> 解析出的 URL 的格式为：<code>dubbo://service-host/com.foo.FooService?version=1.0.0</code>。</p><p>基于扩展点自适应机制，通过 URL 的 <code>dubbo://</code> 协议头识别，直接调用 <code>DubboProtocol</code> 的 <code>export()</code> 方法，打开服务端口。</p><p><strong>2. 向注册中心暴露服务：</strong></p><p>在有注册中心，需要注册提供者地址的情况下，<code>ServiceConfig</code> 解析出的 URL 的格式为: <code>registry://registry-host/org.apache.dubbo.registry.RegistryService?export=URL.encode(&quot;dubbo://service-host/com.foo.FooService?version=1.0.0&quot;)</code>，</p><p>基于扩展点自适应机制，通过 URL 的 <code>registry://</code> 协议头识别，就会调用 <code>RegistryProtocol</code> 的 <code>export()</code> 方法，将 <code>export</code> 参数中的提供者 URL，先注册到注册中心。</p><p>再重新传给 <code>Protocol</code> 扩展点进行暴露： <code>dubbo://service-host/com.foo.FooService?version=1.0.0</code>，然后基于扩展点自适应机制，通过提供者 URL 的 <code>dubbo://</code> 协议头识别，就会调用 <code>DubboProtocol</code> 的 <code>export()</code> 方法，打开服务端口。</p><h4 id="引用服务"><a href="#引用服务" class="headerlink" title="引用服务"></a>引用服务</h4><p><strong>1. 直连引用服务：</strong></p><p>在没有注册中心，直连提供者的情况下，<code>ReferenceConfig</code> 解析出的 URL 的格式为：<code>dubbo://service-host/com.foo.FooService?version=1.0.0</code>。</p><p>基于扩展点自适应机制，通过 URL 的 <code>dubbo://</code> 协议头识别，直接调用 <code>DubboProtocol</code> 的 <code>refer()</code> 方法，返回提供者引用。</p><p><strong>2. 从注册中心发现引用服务：</strong></p><p>在有注册中心，通过注册中心发现提供者地址的情况下，<code>ReferenceConfig</code> 解析出的 URL 的格式为：<code>registry://registry-host/org.apache.dubbo.registry.RegistryService?refer=URL.encode(&quot;consumer://consumer-host/com.foo.FooService?version=1.0.0&quot;)</code>。</p><p>基于扩展点自适应机制，通过 URL 的 <code>registry://</code> 协议头识别，就会调用 <code>RegistryProtocol</code> 的 <code>refer()</code> 方法，基于 <code>refer</code> 参数中的条件，查询提供者 URL，如： <code>dubbo://service-host/com.foo.FooService?version=1.0.0</code>。</p><p>基于扩展点自适应机制，通过提供者 URL 的 <code>dubbo://</code> 协议头识别，就会调用 <code>DubboProtocol</code> 的 <code>refer()</code> 方法，得到提供者引用。</p><p>然后 <code>RegistryProtocol</code> 将多个提供者引用，通过 <code>Cluster</code> 扩展点，伪装成单个提供者引用返回。</p><h3 id="URL-统一模型的意义"><a href="#URL-统一模型的意义" class="headerlink" title="URL 统一模型的意义"></a>URL 统一模型的意义</h3><p>对于 dubbo 中的 URL，有人理解为配置总线，有人理解为统一配置模型，说法虽然不同，但都是在表达一个意思，这样的 URL 在 dubbo 中被当做是 <a href="http://dubbo.incubator.apache.org/zh-cn/docs/dev/contract.html" target="_blank" rel="noopener">公共契约</a>，所有扩展点参数都包含 URL 参数，URL 作为上下文信息贯穿整个扩展点设计体系。</p><p>在没有 URL 之前，只能以字符串传递参数，不停的解析和拼装，导致相同类型的接口，参数时而 Map, 时而 Parameters 类包装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export(String url) </span><br><span class="line">createExporter(String host, <span class="keyword">int</span> port, Parameters params)</span><br></pre></td></tr></table></figure><p>使用 URL 一致性模型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export(URL url) </span><br><span class="line">createExporter(URL url)</span><br></pre></td></tr></table></figure><p>在最新的 dubbo 代码中，我们可以看到大量使用 URL 来进行上下文之间信息的传递，这样的好处是显而易见的：</p><ol><li>使得代码编写者和阅读者能够将一系列的参数联系起来，进而形成规范，使得代码易写，易读。</li><li>可扩展性强，URL 相当于参数的集合 (相当于一个 Map)，他所表达的含义比单个参数更丰富，当我们在扩展代码时，可以将新的参数追加到 URL 之中，而不需要改变入参，返参的结构。</li><li>统一模型，它位于 org.apache.dubbo.common 包中，各个扩展模块都可以使用它作为参数的表达形式，简化了概念，降低了代码的理解成本。</li></ol><p>如果你能够理解 final 契约和 restful 契约，那我相信你会很好地理解 URL 契约。契约的好处我还是啰嗦一句：大家都这么做，就形成了默契，沟通是一件很麻烦的事，统一 URL 模型可以省去很多沟通成本，这边是 URL 统一模型存在的意义。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;在不谈及 dubbo 时，我们大多数人对 URL 这个概念并不会感到陌生。统一资源定位器 (&lt;a href=&quot;https://kimnote.com/rfc/cn/rfc1738.txt&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RFC1738&lt;/a&gt;――Uniform Resource Locators (URL)）应该是最广为人知的一个 RFC 规范，它的定义也非常简单&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因特网上的可用资源可以用简单字符串来表示，该文档就是描述了这种字符串的语法和语&lt;br&gt;义。而这些字符串则被称为：“统一资源定位器”（URL）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt; 一个标准的 URL 格式 &lt;/strong&gt; 至多可以包含如下的几个部分&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;protocol://username:password@host:port/path?key=value&amp;amp;key=value&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="RPC" scheme="http://lexburner.github.io/categories/RPC/"/>
    
    
      <category term="DUBBO" scheme="http://lexburner.github.io/tags/DUBBO/"/>
    
  </entry>
  
  <entry>
    <title>PolarDB 数据库性能大赛 Java 选手分享</title>
    <link href="http://lexburner.github.io/polardb-race/"/>
    <id>http://lexburner.github.io/polardb-race/</id>
    <published>2018-12-10T10:43:56.000Z</published>
    <updated>2019-09-26T09:45:31.456Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h3><p><img src="http://kirito.iocoder.cn/image-20181210184521001.png" alt="排名"></p><p>国际惯例，先报成绩，熬了无数个夜晚，最后依旧被绝杀出了第一页，最终排名第 21 名。前十名的成绩分布为 413.69~416.94，我最终的耗时是 422.43。成绩虽然不是特别亮眼，但与众多参赛选手使用 C++ 作为参赛语言不同，我使用的是 Java，一方面是我 C++ 的能力早已荒废，另一方面是我想验证一下使用 Java 编写存储引擎是否与 C++ 差距巨大 (当然，主要还是前者 QAQ)。所以在本文中，我除了介绍整体的架构之外，还会着重笔墨来探讨 Java 编写存储类型应用的一些最佳实践，文末会给出 github 的开源地址。</p><a id="more"></a><h3 id="2-赛题概览"><a href="#2-赛题概览" class="headerlink" title="2 赛题概览"></a>2 赛题概览</h3><p>比赛总体分成了初赛和复赛两个阶段，整体要求实现一个简化、高效的 kv 存储引擎</p><p>初赛要求支持 Write、Read 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] value)</span></span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span>[] read(<span class="keyword">byte</span>[] key);</span><br></pre></td></tr></table></figure><p>复赛在初赛题目基础上，还需要额外实现一个 Range 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">range</span><span class="params">(<span class="keyword">byte</span>[] lower, <span class="keyword">byte</span>[] upper, AbstractVisitor visitor)</span></span>;</span><br></pre></td></tr></table></figure><p>程序评测逻辑 分为 2 个阶段：<br>1）Recover 正确性评测：<br>此阶段评测程序会并发写入特定数据（key 8B、value 4KB）同时进行任意次 kill -9 来模拟进程意外退出（参赛引擎需要保证进程意外退出时数据持久化不丢失），接着重新打开 DB，调用 Read、Range 接口来进行正确性校验</p><p>2）性能评测</p><ul><li>随机写入：64 个线程并发随机写入，每个线程使用 Write 各写 100 万次随机数据（key 8B、value 4KB）</li><li>随机读取：64 个线程并发随机读取，每个线程各使用 Read 读取 100 万次随机数据</li><li>顺序读取：64 个线程并发顺序读取，每个线程各使用 Range 有序（增序）遍历全量数据 2 次<br>注：<br>2.2 阶段会对所有读取的 kv 校验是否匹配，如不通过则终止，评测失败；<br>2.3 阶段除了对迭代出来每条的 kv 校 验是否匹配外，还会额外校验是否严格字典序递增，如不通过则终止，评测失败。</li></ul><p>语言限定：C++ &amp; JAVA，一起排名</p><h3 id="3-赛题剖析"><a href="#3-赛题剖析" class="headerlink" title="3 赛题剖析"></a>3 赛题剖析</h3><p>关于文件 IO 操作的一些基本常识，我已经在专题文章中进行了介绍，如果你没有浏览那篇文章，建议先行浏览一下：<a href="https://www.cnkirito.moe/file-io-best-practise/" target="_blank" rel="noopener">文件 IO 操作的一些最佳实践</a>。再回归赛题，先对赛题中的几个关键词来进行解读。</p><h4 id="3-1-key-8B-value-4kb"><a href="#3-1-key-8B-value-4kb" class="headerlink" title="3.1 key 8B, value 4kb"></a>3.1 key 8B, value 4kb</h4><p>key 为固定的 8 字节，因此可使用 long 来表示。</p><p>value 为 4kb，这节省了我们很大的工作量，因为 4kb 的整数倍落盘是非常磁盘 IO 友好的。</p><p>value 为 4kb 的另一个好处是我们再内存做索引时，可以使用 int 而不是 long，来记录数据的逻辑偏移量：LogicOffset = PhysicalOffset / 4096，可以将 offset 的内存占用量减少一半。</p><h4 id="3-2-kill-9-数据不丢失"><a href="#3-2-kill-9-数据不丢失" class="headerlink" title="3.2 kill -9 数据不丢失"></a>3.2 kill -9 数据不丢失</h4><p>首先赛题明确表示会进行 kill -9 并验证数据的一致性，这加大了我们在内存中做 write buffer 的难度。但它并没有要求断电不丢失，这间接地阐释了一点：我们可以使用 pageCache 来做写入缓存，在具体代码中我使用了 PageCache 来充当数据和索引的写入缓冲（两者策略不同）。同时这点也限制了参赛选手，不能使用 AIO 这样的异步落盘方式。</p><h4 id="3-3-分阶段测评"><a href="#3-3-分阶段测评" class="headerlink" title="3.3 分阶段测评"></a>3.3 分阶段测评</h4><p>赛题分为了随机写，随机读，顺序读三个阶段，每个阶段都会重新 open，且不会发生随机写到一半校验随机读这样的行为，所以我们在随机写阶段不需要在内存维护索引，而是直接落盘。随机读和顺序读阶段，磁盘均存在数据，open 阶段需要恢复索引，可以使用多线程并发恢复。</p><p><strong> 同时，赛题还有存在一些隐性的测评细节没有披露给大家，但通过测试，我们可以得知这些信息。</strong></p><h4 id="3-4-清空-PageCache-的耗时"><a href="#3-4-清空-PageCache-的耗时" class="headerlink" title="3.4 清空 PageCache 的耗时"></a>3.4 清空 PageCache 的耗时</h4><p>虽然我们可以使用 PageCache，但评测程序在每个阶段之后都使用脚本清空了 PageCache，并且将这部分时间也算进了最终的成绩之中，所以有人感到奇怪：三个阶段的耗时相加比输出出来的成绩要差，其实那几秒便是清空 PageCache 的耗时。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>清理 pagecache (页缓存)</span><br><span class="line">sysctl -w vm.drop_caches=1</span><br><span class="line"><span class="meta">#</span>清理 dentries（目录缓存）和 inodes</span><br><span class="line">sysctl -w vm.drop_caches=2</span><br><span class="line"><span class="meta">#</span>清理 pagecache、dentries 和 inodes</span><br><span class="line">sysctl -w vm.drop_caches=3</span><br></pre></td></tr></table></figure><p>这一点启发我们，不能毫无节制的使用 PageCache，也正是因为这一点，一定程度上使得 Direct IO 这一操作成了本次竞赛的银弹。</p><h4 id="3-5-key-的分布"><a href="#3-5-key-的分布" class="headerlink" title="3.5 key 的分布"></a>3.5 key 的分布</h4><p>这一个隐性条件可谓是本次比赛的关键，因为它涉及到 Range 部分的架构设计。本次比赛的 key 共计 6400w，但是他们的分布都是 <strong> 均匀 </strong> 的，在 <a href="https://www.cnkirito.moe/file-io-best-practise/" target="_blank" rel="noopener">《文件 IO 操作的一些最佳实践》</a> 一文中我们已经提到了数据分区的好处，可以大大减少顺序读写的锁冲突，而 key 的分布均匀这一特性，启发我们在做数据分区时，可以按照 key 的搞 n 位来做 hash，从而确保 key 两个分区之间整体有序 (分区内部无序)。实际我尝试了将数据分成 1024、2048 个分区，效果最佳。</p><h4 id="3-6-Range-的缓存设计"><a href="#3-6-Range-的缓存设计" class="headerlink" title="3.6 Range 的缓存设计"></a>3.6 Range 的缓存设计</h4><p>赛题要求 64 个线程 Range 两次全量的数据，限时 1h，这也启发了我们，如果不对数据进行缓存，想要在 1h 内完成比赛是不可能的，所以，我们的架构设计应该尽量以 Range 为核心，兼顾随机写和随机读。Range 部分也是最容易拉开差距的一个环节。</p><h3 id="4-架构详解"><a href="#4-架构详解" class="headerlink" title="4 架构详解"></a>4 架构详解</h3><p>首先需要明确的是，随机写指的是 key 的写入是随机的，但我们可以根据 key hash，将随机写转换为对应分区文件的顺序写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * using high ten bit of the given key to determine which file it hits.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HighTenPartitioner</span> <span class="keyword">implements</span> <span class="title">Partitionable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPartition</span><span class="params">(<span class="keyword">byte</span>[] key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((key[<span class="number">0</span>] &amp; <span class="number">0xff</span>)&lt;&lt; <span class="number">2</span>) | ((key[<span class="number">1</span>] &amp; <span class="number">0xff</span>)&gt;&gt; <span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明确了高位分区的前提再来看整体的架构就变得明朗了</p><p><strong> 全局视角 </strong></p><p><img src="http://kirito.iocoder.cn/KiritoDB.png" alt="全局视角"></p><p><strong> 分区视角 </strong></p><p><img src="http://kirito.iocoder.cn/image-20181210204156199.png" alt="分区视角"></p><p><strong> 内存视角 </strong></p><p>内存中仅仅维护有序的 <code>key[1024][625000]</code> 数组和 <code>offset[1024][625000]</code> 数组。</p><p>上述两张图对整体的架构进行了一个很好的诠释，利用数据分布均匀的特性，可以将全局数据 hash 成 1024 个分区，在每个分区中存放两类文件：索引文件和数据文件。在随机写入阶段，根据 key 获得该数据对应分区位置，并按照时序，顺序追加到文件末尾，将全局随机写转换为局部顺序写。利用索引和数据一一对应的特性，我们也不需要将 data 的逻辑偏移量落盘，在 recover 阶段可以按照恢复 key 的次序，反推出 value 的逻辑偏移量。</p><p>在 range 阶段，由于我们事先按照 key 的高 10 为做了分区，所以我们可以认定一个事实，patition(N) 中的任何一个数据一定大于 partition(N-1) 中的任何一个数据，于是我们可以采用大块读，将一个 partition 整体读进内存，供 64 个 visit 线程消费。到这儿便奠定了整体的基调：读盘线程负责按分区读盘进入内存，64 个 visit 线程负责消费内存，按照 key 的次序随机访问内存，进行 Visitor 的回调。</p><h3 id="5-随机写流程"><a href="#5-随机写流程" class="headerlink" title="5 随机写流程"></a>5 随机写流程</h3><p>介绍完了整体架构，我们分阶段来看一下各个阶段的一些细节优化点，有一些优化在各个环节都会出现，未避免重复，第二次出现的同一优化点我就不赘述了，仅一句带过。</p><h4 id="使用-pageCache-实现写入缓冲区"><a href="#使用-pageCache-实现写入缓冲区" class="headerlink" title="使用 pageCache 实现写入缓冲区"></a>使用 pageCache 实现写入缓冲区</h4><p>主要看数据落盘，后讨论索引落盘。磁盘 IO 类型的比赛，第一步便是测量磁盘的 IOPS 以及多少个线程一次读写多大的缓存能够打满 IO，在固定 64 线程写入的前提下，16kb，64kb 均可以达到最理想 IOPS，所以理所当然的想到，可以为每一个分区分配一个写入缓存，凑齐 4 个 value 落盘。但是此次比赛，要做到 kill -9 不丢失数据，不能简单地在内存中分配一个 <code>ByteBuffer.allocate(4096 * 4);</code>， 而是可以考虑使用 mmap 内存映射出一片写入缓冲，凑齐 4 个刷盘，这样在 kill -9 之后，PageCache 不会丢失。实测 16kb 落盘比 4kb 落盘要快 6s 左右。</p><p>索引文件的落盘则没有太大的争议，由于 key 的数据量为固定的 8B，所以 mmap 可以发挥出它写小数据的优势，将 pageCache 利用起来，实测 mmap 相比 filechannel 写索引要快 3s 左右，相信如果把 polardb 这块盘换做其他普通的 ssd，这个数值还要增加。</p><h4 id="写入时不维护内存索引，不写入数据偏移"><a href="#写入时不维护内存索引，不写入数据偏移" class="headerlink" title="写入时不维护内存索引，不写入数据偏移"></a>写入时不维护内存索引，不写入数据偏移</h4><p>一开始审题不清，在随机写之后误以为会立刻随机读，实际上每个阶段都是独立的，所以不需要在写入时维护内存索引；其次，之前的架构图中也已经提及，不需要写入连带 key+offset 一起写入文件，recover 阶段可以按照恢复索引的顺序，反推出 data 的逻辑偏移，因为我们的 key 和 data 在同一个分区内的位置是一一对应的。</p><h3 id="6-恢复流程"><a href="#6-恢复流程" class="headerlink" title="6 恢复流程"></a>6 恢复流程</h3><p>recover 阶段的逻辑实际上包含在程序的 open 接口之中，我们需要再数据库引擎启动时，将索引从数据文件恢复到内存之中，在这之中也存在一些细节优化点。</p><p>由于 1024 个分区的存在，我们可以使用 64 个线程 (经验值) 并发地恢复索引，使用快速排序对 <code>key[1024][625000]</code> 数组和 <code>offset[1024][625000]</code> 进行 sort，之后再 compact，对 key 进行去重。需要注意的一点是，不要使用结构体，将 key 和 offset 封装在一起，这会使得排序和之后的二分效率非常低，这之中涉及到 CPU 缓存行的知识点，不了解的读者可以翻阅我之前的博客: <a href="https://www.cnkirito.moe/cache-line/" target="_blank" rel="noopener">《CPU Cache 与缓存行》</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wrong</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyOffset</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> key;</span><br><span class="line">    <span class="keyword">int</span> offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个 recover 阶段耗时为 1s，跟 cpp 选手交流后发现恢复流程比之慢了 600ms，这中间让我觉得比较诡异，加载索引和排序不应该这么慢才对，最终也没有优化成功。</p><h3 id="7-随机读流程"><a href="#7-随机读流程" class="headerlink" title="7 随机读流程"></a>7 随机读流程</h3><p>随机读流程没有太大的优化点，优化空间实在有限，实现思路便是先根据 key 定位到分区，之后在有序的 key 数据中二分查找到 key/offset，拿到 data 的逻辑偏移和分区编号，便可以愉快的随机读了，随机读阶段没有太大的优化点，但仍然比 cpp 选手慢了 2-3s，可能是语言无法越过的差距。</p><h3 id="8-顺序读流程"><a href="#8-顺序读流程" class="headerlink" title="8 顺序读流程"></a>8 顺序读流程</h3><p>Range 环节是整个比赛的大头，也是拉开差距的分水岭。前面我们已经大概提到了 Range 的整体思路是一个生产者消费者模型，n 个生成者负责从磁盘读数据进入内存（n 作为变量，通过 benchmark 来确定多少合适，最终实测 n 为 4 时效果最佳），64 个消费者负责调用 visit 回调，来验证数据，visit 过程就是随机读内存的过程。在 Range 阶段，剩余的内存还有大概 1G 左右，所以我分配了 4 个堆外缓冲，一个 256M，从而可以缓存 4 个分区的数据，并且，我为每一个分区分配了一个读盘线程，负责 load 数据进入缓存，供 64 个消费者消费。</p><p>具体的顺序读架构可以参见下图：</p><p><img src="http://kirito.iocoder.cn/image-20181210215200345.png" alt="range"></p><p>大体来看，便是 4 个 fetch 线程负责读盘，fetch thread n 负责 <code>partitionNo % 4 == n</code> 编号的分区，完成后通知 visit 消费。这中间充斥着比较多的互斥等待逻辑，并未在图中体现出来，大体如下：</p><ol><li>fetch thread 1~4 加载磁盘数据进入缓存是并发的</li><li>visit group 1~64 访问同一个 buffer 是并发的</li><li>visit group 1~64 访问不同 partition 对应的 buffer 是按照次序来进行的 (打到全局有序)</li><li>加载 partitonN 会阻塞 visit bufferN，visit bufferN 会阻塞加载 partitionN+4(相当于复用 4 块缓存)</li></ol><p>大块的加载读进缓存，最大程度复用，是 ReadSeq 部分的关键。顺序读两轮的成绩在 196~198s 左右，相比 C++ 又慢了 4s 左右。</p><h3 id="9-魔鬼在细节中"><a href="#9-魔鬼在细节中" class="headerlink" title="9 魔鬼在细节中"></a>9 魔鬼在细节中</h3><p>这儿是个分水岭，介绍完了整体架构和四个阶段的细节实现，下面就是介绍下具体的优化点了。</p><h3 id="10-Java-实现-Direct-IO"><a href="#10-Java-实现-Direct-IO" class="headerlink" title="10 Java 实现 Direct IO"></a>10 Java 实现 Direct IO</h3><p>由于这次比赛将 drop cache 的时间算进了测评程序之中，所以在不必要的地方应当尽量避免 pageCache，也就是说除了写索引之外，其他阶段不应该出现 pageCache。这对于 Java 选手来说可能是不小的障碍，因为 Java 原生没有提供 Direct IO，需要自己封装一套 JNA 接口，封装这套接口借鉴了开源框架 jaydio 的思路，感谢 @尘央的协助，大家可以在文末的代码中看到实现细节。这一点可以说是拦住了一大票 Java 选手。</p><p>Direct IO 需要注意的两个细节：</p><ol><li>分配的内存需要对齐，对应 jna 方法：posix_memalign</li><li>写入的数据需要对齐通常是 pageSize 的整数倍，实际使用了 pread 的 O_DIRECT</li></ol><h3 id="11-直接内存优于堆内内存"><a href="#11-直接内存优于堆内内存" class="headerlink" title="11 直接内存优于堆内内存"></a>11 直接内存优于堆内内存</h3><p>这一点在《文件 IO 操作的一些最佳实践》中有所提及，堆外内存的两大好处是减少了一份内存拷贝，并且对 gc 友好，在 Direct IO 的实现中，应该配备一套堆外内存的接口，才能发挥出最大的功效。尤其在 Range 阶段，一个缓存区的大小便对应一个 partition 数据分区的大小：256M，大块的内存，更加适合用 DirectByteBuffer 装载。</p><h3 id="12-JVM-调优"><a href="#12-JVM-调优" class="headerlink" title="12 JVM 调优"></a>12 JVM 调优</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-server -Xms2560m -Xmx2560m -XX:MaxDirectMemorySize=1024m -XX:NewRatio=4 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:-UseBiasedLocking</span><br></pre></td></tr></table></figure><p>众所周知 newRatio 控制的是 young 区和 old 区大小的比例，官方推荐参数为  <code>-XX:NewRatio=1</code>，很多不注意的 Java 选手可能没有意识去修改它，会在无形中被 gc 拖累。经过和 @阿杜的讨论，最终得出的结论：</p><ol><li>young 区过大，对象在年轻代待得太久，多次拷贝</li><li>old 区过小，会频繁触发 old 区的 cms gc</li></ol><p>在比赛中这显得尤为重要，<code>-XX:NewRatio=4</code> 放大老年代可以有效的减少 cms gc 的次数，将 126 次 cms gc，下降到最终的 5 次。</p><h3 id="13-池化对象"><a href="#13-池化对象" class="headerlink" title="13 池化对象"></a>13 池化对象</h3><p>无论是 apache 的 ObjectPool 还是 Netty 中的 Recycler，还是 RingBuffer 中预先分配的对象，都在传达一种思想，对于那些反复需要 new 出来的东西，都可以池化，分配内存再回收，这也是一笔不小的开销。在此次比赛的场景下，没必要大费周章地动用对象池，直接一个 ThreadLocal 即可搞定，事实上我对 key/value 的写入和读取都进行了 ThreadLocal 的缓存，做到了永远不再循环中分配对象。</p><h3 id="14-减少线程切换"><a href="#14-减少线程切换" class="headerlink" title="14 减少线程切换"></a>14 减少线程切换</h3><p>无论是网络 IO 还是磁盘 IO，io worker 线程的时间片都显得尤为的可贵，在我的架构中，range 阶段主要分为了两类线程：64 个 visit 线程并发随机读内存，4 个 io 线程并发读磁盘。木桶效应，我们很容易定位到瓶颈在于 4 个 io 线程，在 wait/notify 的模型中，为了尽可能的减少 io 线程的时间片流失，可以考虑使用 while(true) 进行轮询，而 visit 线程则可以 sleep(1us) 避免 cpu 空转带来的整体性能下降，由于评测机拥有 64 core，所以这样的分配算是较为合理的，为此我实现了一个简单粗暴的信号量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoopQuerySemaphore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> permit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoopQuerySemaphore</span><span class="params">(<span class="keyword">boolean</span> permit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.permit = permit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for 64 visit thread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!permit) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        permit = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for 4 fetch thread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireNoSleep</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!permit) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        permit = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        permit = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的在 IO 中 acquireNoSleep，在 Visit 中 acquire，可以让成绩相比使用普通的阻塞 Semaphore 提升 6s 左右。</p><h3 id="15-绑核"><a href="#15-绑核" class="headerlink" title="15 绑核"></a>15 绑核</h3><p>线上机器的抖动在所难免，避免 IO 线程的切换也并不仅仅能够用依靠 while(true) 的轮询，一个 CPU 级别的优化便是腾出 4 个核心专门给 IO 线程使用，完全地避免 IO 线程的时间片争用。在 Java 中这也不难实现，依赖万能的 github，我们可以轻松地实现 Affinity。github 传送门：<a href="https://github.com/OpenHFT/Java-Thread-Affinity" target="_blank" rel="noopener">https://github.com/OpenHFT/Java-Thread-Affinity</a></p><p>使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="keyword">final</span> AffinityLock al2 = AffinityLock.acquireLock()) &#123;</span><br><span class="line">    <span class="comment">// do fetch ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方式可以让你的代码快 1~2 s，并且保持测评的稳定性。</p><h3 id="0-聊聊-FileChannel，MMAP，Direct-IO，聊聊比赛"><a href="#0-聊聊-FileChannel，MMAP，Direct-IO，聊聊比赛" class="headerlink" title="0 聊聊 FileChannel，MMAP，Direct IO，聊聊比赛"></a>0 聊聊 FileChannel，MMAP，Direct IO，聊聊比赛</h3><p>我在最终版本的代码中，几乎完全抛弃了 FileChannel，事实上，在不 Drop Cache 的场景下，它已经可以发挥出它利用 PageCache 的一些优势，并且优秀的 Java 存储引擎都主要使用了 FileChannel 来进行读写，在少量的场景下，使用了 MMAP 作为辅助，毕竟，MMAP 在写小数据量文件时存在其价值。</p><p>另外需要注意的一点，在跟 @96 年的亚普长谈的一个夜晚，发现 FileChannel 中出人意料的一个实现，在分配对内内存时，它仍然会拷贝一份堆外内存，这对于实际使用 FileChannel 的场景需要额外注意，这部分意料之外分配的内存很容易导致线上的问题（实际上已经遇到了，和 glibc 的 malloc 相关，当 buffer 大于 128k 时，会使用 mmap 分配一块内存作为缓存）</p><p>说回 FileChannel，MMAP，最容易想到的是 RocketMQ 之中对两者灵活的运用，不知道在其他 Java 实现的存储引擎之中，是不是可以考虑使用 Direct IO 来提升存储引擎的性能呢？我们可以设想一下，利用有限并且少量的 PageCache 来保证一致性，在主流程中使用 Direct IO 配合顺序读写是不是一种可以配套使用的方案，不仅仅 PolarDB，算作是参加本次比赛给予我的一个启发。</p><p>虽然无缘决赛，但使用 Java 取得这样的成绩还算不是特别难过，在 6400w 数据随机写，随机读，顺序读的场景下，Java 可以做到仅仅相差 C++ 不到 10s 的 overhead，我倒是觉得完全是可以接受的，哈哈。还有一些小的优化点就不在此赘述了，欢迎留言与我交流优化点和比赛感悟。</p><p><strong> 欢迎关注我的微信公众号：「Kirito 的技术分享」，关于文章的任何疑问都会得到回复，带来更多 Java 相关的技术分享。</strong></p><p><img src="http://kirito.iocoder.cn/qrcode_for_gh_c06057be7960_258%20%281%29.jpg" alt="关注微信公众号"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1 前言&quot;&gt;&lt;/a&gt;1 前言&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://kirito.iocoder.cn/image-20181210184521001.png&quot; alt=&quot;排名&quot;&gt;&lt;/p&gt;
&lt;p&gt;国际惯例，先报成绩，熬了无数个夜晚，最后依旧被绝杀出了第一页，最终排名第 21 名。前十名的成绩分布为 413.69~416.94，我最终的耗时是 422.43。成绩虽然不是特别亮眼，但与众多参赛选手使用 C++ 作为参赛语言不同，我使用的是 Java，一方面是我 C++ 的能力早已荒废，另一方面是我想验证一下使用 Java 编写存储引擎是否与 C++ 差距巨大 (当然，主要还是前者 QAQ)。所以在本文中，我除了介绍整体的架构之外，还会着重笔墨来探讨 Java 编写存储类型应用的一些最佳实践，文末会给出 github 的开源地址。&lt;/p&gt;
    
    </summary>
    
      <category term="性能挑战赛" scheme="http://lexburner.github.io/categories/%E6%80%A7%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B/"/>
    
    
      <category term="数据库" scheme="http://lexburner.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>文件 IO 操作的一些最佳实践</title>
    <link href="http://lexburner.github.io/file-io-best-practise/"/>
    <id>http://lexburner.github.io/file-io-best-practise/</id>
    <published>2018-11-27T15:22:22.000Z</published>
    <updated>2019-09-26T09:45:30.439Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>已经过去的中间件性能挑战赛，和正在进行中的 <a href="https://tianchi.aliyun.com/programming/introduction.htm?spm=5176.11165320.5678.1.483b4682l8fBSf&amp;raceId=231689" target="_blank" rel="noopener">第一届 PolarDB 数据性能大赛</a> 都涉及到了文件操作，合理地设计架构以及正确地压榨机器的读写性能成了比赛中获取较好成绩的关键。正在参赛的我收到了几位公众号读者朋友的反馈，他们大多表达出了这样的烦恼：“对比赛很感兴趣，但不知道怎么入门”，“能跑出成绩，但相比前排的选手，成绩相差 10 倍有余”…为了能让更多的读者参与到之后相类似的比赛中来，我简单整理一些文件 IO 操作的最佳实践，而不涉及整体系统的架构设计，希望通过这篇文章的介绍，让你能够欢快地参与到之后类似的性能挑战赛之中来。</p><a id="more"></a><h3 id="知识点梳理"><a href="#知识点梳理" class="headerlink" title="知识点梳理"></a>知识点梳理</h3><p>本文主要关注的 Java 相关的文件操作，理解它们需要一些前置条件，比如 PageCache，Mmap(内存映射)，DirectByteBuffer(堆外缓存)，顺序读写，随机读写… 不一定需要完全理解，但至少知道它们是个啥，因为本文将会主要围绕这些知识点来展开描述。</p><h3 id="初识-FileChannel-和-MMAP"><a href="#初识-FileChannel-和-MMAP" class="headerlink" title="初识 FileChannel 和 MMAP"></a>初识 FileChannel 和 MMAP</h3><p>首先，文件 IO 类型的比赛最重要的一点，就是选择好读写文件的方式，那 JAVA 中文件 IO 有多少种呢？原生的读写方式大概可以被分为三种：普通 IO，FileChannel(文件通道)，MMAP(内存映射)。区分他们也很简单，例如 FileWriter,FileReader 存在于 java.io 包中，他们属于普通 IO；FileChannel 存在于 java.nio 包中，属于 NIO 的一种，但是注意 NIO 并不一定意味着非阻塞，这里的 FileChannel 就是阻塞的；较为特殊的是后者 MMAP，它是由 FileChannel 调用 map 方法衍生出来的一种特殊读写文件的方式，被称之为内存映射。</p><p>使用 FIleChannel 的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileChannel fileChannel = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">"db.data"</span>), <span class="string">"rw"</span>).getChannel();</span><br></pre></td></tr></table></figure><p>获取 MMAP 的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MappedByteBuffer mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, filechannel.size();</span><br></pre></td></tr></table></figure><p>MappedByteBuffer 便是 JAVA 中 MMAP 的操作类。</p><p>面向于字节传输的传统 IO 方式遭到了我们的唾弃，我们重点探讨 FileChannel 和 MMAP 这两种读写方式的区别。</p><h3 id="FileChannel-读写"><a href="#FileChannel-读写" class="headerlink" title="FileChannel 读写"></a>FileChannel 读写</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写</span></span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line"><span class="keyword">long</span> position = <span class="number">1024L</span>;</span><br><span class="line"><span class="comment">// 指定 position 写入 4kb 的数据</span></span><br><span class="line">fileChannel.write(ByteBuffer.wrap(data), position);</span><br><span class="line"><span class="comment">// 从当前文件指针的位置写入 4kb 的数据</span></span><br><span class="line">fileChannel.write(ByteBuffer.wrap(data));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读</span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">4096</span>);</span><br><span class="line"><span class="keyword">long</span> position = <span class="number">1024L</span>;</span><br><span class="line"><span class="comment">// 指定 position 读取 4kb 的数据</span></span><br><span class="line">fileChannel.read(buffer,position)；</span><br><span class="line"><span class="comment">// 从当前文件指针的位置读取 4kb 的数据</span></span><br><span class="line">fileChannel.read(buffer);</span><br></pre></td></tr></table></figure><p>FileChannel 大多数时候是和 ByteBuffer 这个类打交道，你可以将它理解为一个 byte[] 的封装类，提供了丰富的 API 去操作字节，不了解的同学可以去熟悉下它的 API。值得一提的是，write 和 read 方法均是 <strong> 线程安全 </strong> 的，FileChannel 内部通过一把 <code>private final Object positionLock = new Object();</code> 锁来控制并发。</p><p>FileChannel 为什么比普通 IO 要快呢？这么说可能不严谨，因为你要用对它，FileChannel 只有在一次写入 4kb 的整数倍时，才能发挥出实际的性能，这得益于 FileChannel 采用了 ByteBuffer 这样的内存缓冲区，让我们可以非常精准的控制写盘的大小，这是普通 IO 无法实现的。4kb 一定快吗？也不严谨，这主要取决你机器的磁盘结构，并且受到操作系统，文件系统，CPU 的影响，例如中间件性能挑战赛时的那块盘，一次至少写入 64kb 才能发挥出最高的 IOPS。</p><p><img src="http://kirito.iocoder.cn/image-20180714180739936.png" alt="中间件性能挑战复赛的盘"></p><p>然而 PolarDB 这块盘就完全不一样了，可谓是异常彪悍，具体是如何的表现由于比赛仍在进行中，不予深究，但凭借着 benchmark everyting 的技巧，我们完全可以测出来。</p><p>另外一点，成就了 FileChannel 的高效，介绍这点之前，我想做一个提问：FileChannel 是直接把 ByteBuffer 中的数据写入到磁盘吗？思考几秒…答案是：NO。ByteBuffer 中的数据和磁盘中的数据还隔了一层，这一层便是 PageCache，是用户内存和磁盘之间的一层缓存。我们都知道磁盘 IO 和内存 IO 的速度可是相差了好几个数量级。我们可以认为 filechannel.write 写入 PageCache 便是完成了落盘操作，但实际上，操作系统最终帮我们完成了 PageCache 到磁盘的最终写入，理解了这个概念，你就应该能够理解 FileChannel 为什么提供了一个 force() 方法，用于通知操作系统进行及时的刷盘。</p><p>同理，当我们使用 FileChannel 进行读操作时，同样经历了：磁盘 -&gt;PageCache-&gt; 用户内存这三个阶段，对于日常使用者而言，你可以忽略掉 PageCache，但作为挑战者参赛，PageCache 在调优过程中是万万不能忽视的，关于读操作这里不做过多的介绍，我们再下面的小结中还会再次提及，这里当做是引出 PageCache 的概念。</p><h3 id="MMAP-读写"><a href="#MMAP-读写" class="headerlink" title="MMAP 读写"></a>MMAP 读写</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写</span></span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> position = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 从当前 mmap 指针的位置写入 4b 的数据</span></span><br><span class="line">mappedByteBuffer.put(data);</span><br><span class="line"><span class="comment">// 指定 position 写入 4b 的数据</span></span><br><span class="line">MappedByteBuffer subBuffer = mappedByteBuffer.slice();</span><br><span class="line">subBuffer.position(position);</span><br><span class="line">subBuffer.put(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读</span></span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> position = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 从当前 mmap 指针的位置读取 4b 的数据</span></span><br><span class="line">mappedByteBuffer.get(data)；</span><br><span class="line"><span class="comment">// 指定 position 读取 4b 的数据</span></span><br><span class="line">MappedByteBuffer subBuffer = mappedByteBuffer.slice();</span><br><span class="line">subBuffer.position(position);</span><br><span class="line">subBuffer.get(data);</span><br></pre></td></tr></table></figure><p>FileChannel 已经足够强大了，MappedByteBuffer 还能玩出什么花来呢？请容许我卖个关子先，先介绍一下 MappedByteBuffer 的使用注意点。</p><p>当我们执行 <code>fileChannel.map(FileChannel.MapMode.READ_WRITE, 0, 1.5 * 1024 * 1024 * 1024);</code> 之后，观察一下磁盘上的变化，会立刻获得一个 1.5G 的文件，但此时文件的内容全部是 0（字节 0）。这符合 MMAP 的中文描述：内存映射文件，我们之后对内存中 MappedByteBuffer 做的任何操作，都会被最终映射到文件之中，</p><blockquote><p>mmap 把文件映射到用户空间里的虚拟内存，省去了从内核缓冲区复制到用户空间的过程，文件中的位置在虚拟内存中有了对应的地址，可以像操作内存一样操作这个文件，相当于已经把整个文件放入内存，但在真正使用到这些数据前却不会消耗物理内存，也不会有读写磁盘的操作，只有真正使用这些数据时，也就是图像准备渲染在屏幕上时，虚拟内存管理系统 VMS 才根据缺页加载的机制从磁盘加载对应的数据块到物理内存进行渲染。这样的文件读写文件方式少了数据从内核缓存到用户空间的拷贝，效率很高</p></blockquote><p>看了稍微官方一点的描述，你可能对 MMAP 有了些许的好奇，有这么厉害的黑科技存在的话，还有 FileChannel 存在的意义吗！并且网上很多文章都在说，MMAP 操作大文件性能比 FileChannel 搞出一个数量级！然而，通过我比赛的认识，MMAP 并非是文件 IO 的银弹，它只有在 <strong> 一次写入很小量数据的场景 </strong> 下才能表现出比 FileChannel 稍微优异的性能。紧接着我还要告诉你一些令你沮丧的事，至少在 JAVA 中使用 MappedByteBuffer 是一件非常麻烦并且痛苦的事，主要表现为三点：</p><ol><li>MMAP 使用时必须实现指定好内存映射的大小，并且一次 map 的大小限制在 1.5G 左右，重复 map 又会带来虚拟内存的回收、重新分配的问题，对于文件不确定大小的情形实在是太不友好了。</li><li>MMAP 使用的是虚拟内存，和 PageCache 一样是由操作系统来控制刷盘的，虽然可以通过 force() 来手动控制，但这个时间把握不好，在小内存场景下会很令人头疼。</li><li>MMAP 的回收问题，当 MappedByteBuffer 不再需要时，可以手动释放占用的虚拟内存，但…方式非常的诡异。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">(MappedByteBuffer mappedByteBuffer)</span> </span>&#123;</span><br><span class="line">    ByteBuffer buffer = mappedByteBuffer;</span><br><span class="line">    <span class="keyword">if</span> (buffer == <span class="keyword">null</span> || !buffer.isDirect() || buffer.capacity()== <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    invoke(invoke(viewed(buffer), <span class="string">"cleaner"</span>), <span class="string">"clean"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> Object target, <span class="keyword">final</span> String methodName, <span class="keyword">final</span> Class&lt;?&gt;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Method method = method(target, methodName, args);</span><br><span class="line">                method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">return</span> method.invoke(target);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Method <span class="title">method</span><span class="params">(Object target, String methodName, Class&lt;?&gt;[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target.getClass().getMethod(methodName, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> target.getClass().getDeclaredMethod(methodName, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ByteBuffer <span class="title">viewed</span><span class="params">(ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">    String methodName = <span class="string">"viewedBuffer"</span>;</span><br><span class="line">    Method[] methods = buffer.getClass().getMethods();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (methods[i].getName().equals(<span class="string">"attachment"</span>)) &#123;</span><br><span class="line">            methodName = <span class="string">"attachment"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ByteBuffer viewedBuffer = (ByteBuffer) invoke(buffer, methodName);</span><br><span class="line">    <span class="keyword">if</span> (viewedBuffer == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> viewed(viewedBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对的，你没看错，这么长的代码仅仅是为了干回收 MappedByteBuffer 这一件事。</p><p>所以我建议，优先使用 FileChannel 去完成初始代码的提交，在必须使用小数据量 (例如几个字节) 刷盘的场景下，再换成 MMAP 的实现，其他场景 FileChannel 完全可以 cover(前提是你理解怎么合理使用 FileChannel)。至于 MMAP 为什么在一次写入少量数据的场景下表现的比 FileChannel 优异，我还没有查到理论根据，如果你有相关的线索，欢迎留言。理论分析下，FileChannel 同样是写入内存，但是在写入小数据量时，MMAP 表现的更加优秀，所以在索引数据落盘时，大多数情况应该选择使用 MMAP。至于 MMAP 分配的虚拟内存是否就是真正的 PageCache 这一点，我觉得可以近似理解成 PageCache。</p><h3 id="顺序读比随机读快，顺序写比随机写快"><a href="#顺序读比随机读快，顺序写比随机写快" class="headerlink" title="顺序读比随机读快，顺序写比随机写快"></a>顺序读比随机读快，顺序写比随机写快</h3><p>无论你是机械硬盘还是 SSD，这个结论都是一定成立的，虽然背后的原因不太一样，我们今天不讨论机械硬盘这种古老的存储介质，重点 foucs 在 SSD 上，来看看在它之上进行的随机读写为什么比顺序读写要慢。即使各个 SSD 和文件系统的构成具有差异性，但我们今天的分析同样具备参考价值。</p><p>首先，什么是顺序读，什么是随机读，什么是顺序写，什么是随机写？可能我们刚接触文件 IO 操作时并不会有这样的疑惑，但写着写着，自己都开始怀疑自己的理解了，不知道你有没有经历过这样类似的阶段，反正我有一段时间的确怀疑过。那么，先来看看两段代码：</p><p>写入方式一：64 个线程，用户自己使用一个 atomic 变量记录写入指针的位置，并发写入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">64</span>);</span><br><span class="line">AtomicLong wrotePosition = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1024</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">    executor.execute(()-&gt;&#123;</span><br><span class="line">        fileChannel.write(ByteBuffer.wrap(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>*<span class="number">1024</span>]),wrote.getAndAdd(<span class="number">4</span>*<span class="number">1024</span>));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写入方式二：给 write 加了锁，保证了同步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">64</span>);</span><br><span class="line">AtomicLong wrotePosition = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1024</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">    executor.execute(()-&gt;&#123;</span><br><span class="line">        write(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>*<span class="number">1024</span>]);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] data)</span></span>&#123;</span><br><span class="line">    fileChannel.write(ByteBuffer.wrap(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>*<span class="number">1024</span>]),wrote.getAndAdd(<span class="number">4</span>*<span class="number">1024</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是方式二才算顺序写，顺序读也是同理。对于文件操作，加锁并不是一件非常可怕的事，不敢同步 write/read 才可怕！有人会问：FileChannel 内部不是已经有 positionLock 保证写入的线程安全了吗，为什么还要自己加同步？为什么这样会快？我用大白话来回答的话就是多线程并发 write 并且不加同步，会导致文件空洞，它的执行次序可能是 </p><p>时序 1：thread1 write position[0~4096)</p><p>时序 2：thread3 write position[8194~12288)</p><p>时序 3：thread2 write position[4096~8194)</p><p>所以并不是完全的“顺序写”。不过你也别担心加锁会导致性能下降，我们会在下面的小结介绍一个优化：通过文件分片来减少多线程读写时锁的冲突。</p><p>在来分析原理，顺序读为什么会比随机读要快？顺序写为什么比随机写要快？这两个对比其实都是一个东西在起作用：PageCache，前面我们已经提到了，它是位于 application buffer(用户内存) 和 disk file(磁盘) 之间的一层缓存。</p><p><img src="http://kirito.iocoder.cn/1364556742_9652.gif" alt="PageCache"></p><p>以顺序读为例，当用户发起一个 fileChannel.read(4kb) 之后，实际发生了两件事</p><ol><li>操作系统从磁盘加载了 16kb 进入 PageCache，这被称为预读</li><li>操作通从 PageCache 拷贝 4kb 进入用户内存</li></ol><p>最终我们在用户内存访问到了 4kb，为什么顺序读快？很容量想到，当用户继续访问接下来的 [4kb,16kb] 的磁盘内容时，便是直接从 PageCache 去访问了。试想一下，当需要访问 16kb 的磁盘内容时，是发生 4 次磁盘 IO 快，还是发生 1 次磁盘 IO+4 次内存 IO 快呢？答案是显而易见的，这一切都是 PageCache 带来的优化。</p><p>深度思考：当内存吃紧时，PageCache 的分配会受影响吗？PageCache 的大小如何确定，是固定的 16kb 吗？我可以监控 PageCache 的命中情况吗？ PageCache 会在哪些场景失效，如果失效了，我们又要哪些补救方式呢？</p><p>我进行简单的自问自答，背后的逻辑还需要读者去推敲：</p><ul><li>当内存吃紧时，PageCache 的预读会受到影响，实测，并没有搜到到文献支持</li><li>PageCache 是动态调整的，可以通过 linux 的系统参数进行调整，默认是占据总内存的 20%</li><li><a href="https://github.com/brendangregg/perf-tools" target="_blank" rel="noopener">https://github.com/brendangregg/perf-tools</a> github 上一款工具可以监控 PageCache</li><li>这是很有意思的一个优化点，如果用 PageCache 做缓存不可控，不妨自己做预读如何呢？</li></ul><p>顺序写的原理和顺序读一致，都是收到了 PageCache 的影响，留给读者自己推敲一下。</p><h3 id="直接内存-堆外-VS-堆内内存"><a href="#直接内存-堆外-VS-堆内内存" class="headerlink" title="直接内存 (堆外) VS 堆内内存"></a>直接内存 (堆外) VS 堆内内存</h3><p>前面 FileChannel 的示例代码中已经使用到了堆内内存： <code>ByteBuffer.allocate(4 * 1024)</code>，ByteBuffer 提供了另外的方式让我们可以分配堆外内存 ： <code>ByteBuffer.allocateDirect(4 * 1024)</code>。这就引来的一系列的问题，我什么时候应该使用堆内内存，什么时候应该使用直接内存？</p><p>我不花太多笔墨去阐述了，直接上对比：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">堆内内存</th><th style="text-align:center">堆外内存</th></tr></thead><tbody><tr><td style="text-align:center"><strong> 底层实现 </strong></td><td style="text-align:center">数组，JVM 内存</td><td style="text-align:center">unsafe.allocateMemory(size) 返回直接内存</td></tr><tr><td style="text-align:center"><strong> 分配大小限制 </strong></td><td style="text-align:center">-Xms-Xmx 配置的 JVM 内存相关，并且数组的大小有限制，在做测试时发现，当 JVM free memory 大于 1.5G 时，ByteBuffer.allocate(900M) 时会报错</td><td style="text-align:center">可以通过 -XX:MaxDirectMemorySize 参数从 JVM 层面去限制，同时受到机器虚拟内存（说物理内存不太准确）的限制</td></tr><tr><td style="text-align:center"><strong> 垃圾回收 </strong></td><td style="text-align:center">不必多说</td><td style="text-align:center">当 DirectByteBuffer 不再被使用时，会出发内部 cleaner 的钩子，保险起见，可以考虑手动回收：((DirectBuffer) buffer).cleaner().clean();</td></tr><tr><td style="text-align:center"><strong> 内存复制 </strong></td><td style="text-align:center">堆内内存 -&gt; 堆外内存 -&gt; pageCache</td><td style="text-align:center">堆外内存 -&gt; pageCache</td></tr></tbody></table><p>关于堆内内存和堆外内存的一些最佳实践：</p><ol><li>当需要申请大块的内存时，堆内内存会受到限制，只能分配堆外内存。</li><li>堆外内存适用于生命周期中等或较长的对象。(如果是生命周期较短的对象，在 YGC 的时候就被回收了，就不存在大内存且生命周期较长的对象在 FGC 对应用造成的性能影响)。</li><li>堆内内存刷盘的过程中，还需要复制一份到堆外内存，这部分内容可以在 FileChannel 的实现源码中看到细节，至于 Jdk 为什么需要这么做，可以参考我的另外一篇文章：<a href="https://www.cnkirito.moe/nio-buffer-recycle/" target="_blank" rel="noopener">《一文探讨堆外内存的监控与回收》</a></li><li>同时，还可以使用池 + 堆外内存 的组合方式，来对生命周期较短，但涉及到 I/O 操作的对象进行堆外内存的再使用 (Netty 中就使用了该方式)。在比赛中，尽量不要出现在频繁 <code>new byte[]</code> ，创建内存区域再回收也是一笔不小的开销，使用 <code>ThreadLocal&lt;ByteBuffer&gt;</code>  和 <code>ThreadLocal&lt;byte[]&gt;</code> 往往会给你带来意外的惊喜 ~</li><li>创建堆外内存的消耗要大于创建堆内内存的消耗，所以当分配了堆外内存之后，尽可能复用它。</li></ol><h3 id="黑魔法：UNSAFE"><a href="#黑魔法：UNSAFE" class="headerlink" title="黑魔法：UNSAFE"></a>黑魔法：UNSAFE</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field field = Unsafe.class.getDeclaredField(<span class="string">"theUnsafe"</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            UNSAFE = (Unsafe) field.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用 UNSAFE 这个黑魔法实现很多无法想象的事，我这里就稍微介绍一两点吧。</p><p>实现直接内存与内存的拷贝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"><span class="keyword">long</span> addresses = ((DirectBuffer) buffer).address();</span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">UNSAFE.copyMemory(data, <span class="number">16</span>, <span class="keyword">null</span>, addresses, <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br></pre></td></tr></table></figure><p>copyMemory 方法可以实现内存之间的拷贝，无论是堆内和堆外，1~2 个参数是 source 方，3~4 是 target 方，第 5 个参数是 copy 的大小。如果是堆内的字节数组，则传递数组的首地址和 16 这个固定的 ARRAY_BYTE_BASE_OFFSET 偏移常量；如果是堆外内存，则传递 null 和直接内存的偏移量，可以通过 ((DirectBuffer) buffer).address() 拿到。为什么不直接拷贝，而要借助 UNSAFE？当然是因为它快啊！少年！另外补充：MappedByteBuffer 也可以使用 UNSAFE 来 copy 从而达到写盘 / 读盘的效果哦。</p><p>至于 UNSAFE 还有那些黑科技，可以专门去了解下，我这里就不过多赘述了。</p><h3 id="文件分区"><a href="#文件分区" class="headerlink" title="文件分区"></a>文件分区</h3><p>前面已经提到了顺序读写时我们需要对 write，read 加锁，并且我一再强调的一点是：加锁并不可怕，文件 IO 操作并没有那么依赖多线程。但是加锁之后的顺序读写必然无法打满磁盘 IO，如今系统强劲的 CPU 总不能不压榨吧？我们可以采用文件分区的方式来达到一举两得的效果：既满足了顺序读写，又减少了锁的冲突。</p><p>那么问题又来了，分多少合适呢？文件多了，锁冲突变降低了；文件太多了，碎片化太过严重，单个文件的值太少，缓存也就不容易命中，这样的 trade off 如何平衡？没有理论答案，benchmark everything~</p><h3 id="Direct-IO"><a href="#Direct-IO" class="headerlink" title="Direct IO"></a>Direct IO</h3><p><img src="http://kirito.iocoder.cn/linux-io.png" alt="linux io"></p><p>最后我们来探讨一下之前从没提到的一种 IO 方式，Direct IO，什么，Java 还有这东西？博主你骗我？之前怎么告诉我只有三种 IO 方式！别急着骂我，严谨来说，这并不是 JAVA 原生支持的方式，但可以通过 JNA/JNI 调用 native 方法做到。从上图我们可以看到 ：Direct IO 绕过了 PageCache，但我们前面说到过，PageCache 可是个好东西啊，干嘛不用他呢？再仔细推敲一下，还真有一些场景下，Direct IO 可以发挥作用，没错，那就是我们前面没怎么提到的：<strong> 随机读 </strong>。当使用 fileChannel.read() 这类会触发 PageCache 预读的 IO 方式时，我们其实并不希望操作系统帮我们干太多事，除非真的踩了狗屎运，随机读都能命中 PageCache，但几率可想而知。Direct IO 虽然被 Linus 无脑喷过，但在随机读的场景下，依旧存在其价值，减少了 Block IO Layed（近似理解为磁盘） 到 Page Cache 的 overhead。</p><p>话说回来，Java 怎么用 Direct IO 呢？有没有什么限制呢？前面说过，Java 目前原生并不支持，但也有好心人封装好了 Java 的 JNA 库，实现了 Java 的 Direct IO，github 地址：<a href="https://github.com/smacke/jaydio" target="_blank" rel="noopener">https://github.com/smacke/jaydio</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bufferSize = <span class="number">20</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">DirectRandomAccessFile directFile = <span class="keyword">new</span> DirectRandomAccessFile(<span class="keyword">new</span> File(<span class="string">"dio.data"</span>), <span class="string">"rw"</span>, bufferSize);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>;i&lt; bufferSize / <span class="number">4096</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * <span class="number">1024</span>];</span><br><span class="line">    directFile.read(buffer);</span><br><span class="line">    directFile.readFully(buffer);</span><br><span class="line">&#125;</span><br><span class="line">directFile.close();</span><br></pre></td></tr></table></figure><p>但需要注意的是，<strong> 只有 Linux 系统才支持 DIO</strong>! 所以，少年，是时候上手装一台 linux 了。值得一提的是，据说在 Jdk10 发布之后，Direct IO 将会得到原生的支持，让我们拭目以待吧！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上均是个人的实践积累而来的经验，有部分结论没有找到文献的支撑，所以如有错误，欢迎指正。关于 PolarDB 数据性能大赛的比赛分析，等复赛结束后我会专门另起一篇文章，分析下具体如何使用这些优化点，当然这些小技巧其实很多人都知道，决定最后成绩的还是整体设计的架构，以及对文件 IO，操作系统，文件系统，CPU 和语言特性的理解。虽然 JAVA 搞这种性能挑战赛并不吃香，但依旧是乐趣无穷，希望这些文件 IO 的知识能够帮助你，等下次比赛时看到你的身影 ~</p><p><strong> 欢迎关注我的微信公众号：「Kirito 的技术分享」，关于文章的任何疑问都会得到回复，带来更多 Java 相关的技术分享。</strong></p><p><img src="http://kirito.iocoder.cn/qrcode_for_gh_c06057be7960_258%20%281%29.jpg" alt="关注微信公众号"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;已经过去的中间件性能挑战赛，和正在进行中的 &lt;a href=&quot;https://tianchi.aliyun.com/programming/introduction.htm?spm=5176.11165320.5678.1.483b4682l8fBSf&amp;amp;raceId=231689&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;第一届 PolarDB 数据性能大赛&lt;/a&gt; 都涉及到了文件操作，合理地设计架构以及正确地压榨机器的读写性能成了比赛中获取较好成绩的关键。正在参赛的我收到了几位公众号读者朋友的反馈，他们大多表达出了这样的烦恼：“对比赛很感兴趣，但不知道怎么入门”，“能跑出成绩，但相比前排的选手，成绩相差 10 倍有余”…为了能让更多的读者参与到之后相类似的比赛中来，我简单整理一些文件 IO 操作的最佳实践，而不涉及整体系统的架构设计，希望通过这篇文章的介绍，让你能够欢快地参与到之后类似的性能挑战赛之中来。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://lexburner.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="PolarDB 性能挑战赛" scheme="http://lexburner.github.io/tags/PolarDB-%E6%80%A7%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B/"/>
    
  </entry>
  
</feed>
